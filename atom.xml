<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x08 0x17</title>
  
  <subtitle>Build something useful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ryan-hou.github.io/"/>
  <updated>2020-04-17T07:19:20.678Z</updated>
  <id>https://ryan-hou.github.io/</id>
  
  <author>
    <name>0x08 0x17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM类加载器</title>
    <link href="https://ryan-hou.github.io/2019/06/01/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://ryan-hou.github.io/2019/06/01/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2019-06-01T13:42:58.000Z</published>
    <updated>2020-04-17T07:19:20.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载器是什么"><a href="#类加载器是什么" class="headerlink" title="类加载器是什么"></a>类加载器是什么</h2><p>定义摘自<code>深入理解Java虚拟机</code></p><blockquote><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。而实现这个动作的代码模块称为“类加载器”</p></blockquote><p>从上面的定义中，我们可以得到如下信息：</p><a id="more"></a><ul><li>类加载器的作用：获取描述此类的二进制字节流，也就是 <code>.class</code> 文件，那么什么是 <code>.class</code> 文件？</li><li>获取类的二进制字节流只是类加载阶段中的一部分，那么整个类加载过程是怎样的？</li><li>类加载器的目的是让应用程序自己决定如何获取需要的类，这样做有什么好处？换句话说，我什么时候可能需要自己定义一个类加载器？</li></ul><h2 id="关于类加载涉及的一些定义"><a href="#关于类加载涉及的一些定义" class="headerlink" title="关于类加载涉及的一些定义"></a>关于类加载涉及的一些定义</h2><h3 id="class-文件"><a href="#class-文件" class="headerlink" title="class 文件"></a>class 文件</h3><p>每个 <code>.class</code> 文件都对应着唯一一个类或者接口的定义信息，该文件是一个二进制字节流，每个字节的数据都有严格的定义和顺序。虚拟机通过该文件实现了语言无关性，其他编程语言也可以编译为 <code>.class</code> 文件，然后使用 JVM</p><h3 id="类加载的步骤"><a href="#类加载的步骤" class="headerlink" title="类加载的步骤"></a>类加载的步骤</h3><p>包括加载，验证，准备，解析和初始化，其中验证，准备和解析合称为连接。类型的加载，连接和初始化都是在程序运行期间完成的，增加了类加载带来的性能负担但是提高了灵活性，比如：</p><blockquote><p>编写一个面向接口的应用程序，可以等到运行时再指定其实现类；用户可以通过自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分，这种组装程序的方式广泛应用于 Java 程序之中，如 JSP，OSGi 等</p></blockquote><h3 id="加载与类加载"><a href="#加载与类加载" class="headerlink" title="加载与类加载"></a>加载与类加载</h3><p>加载是类加载的第一个步骤，加载阶段虚拟机完成三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流，也就是<strong>类加载器实现的功能</strong></li><li>将这个字节流所代表的静态存储结构转为方法区的运行时数据结构</li><li>在堆内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口</li></ul><h2 id="类加载器的-parent-delegation-model"><a href="#类加载器的-parent-delegation-model" class="headerlink" title="类加载器的 parent-delegation model"></a>类加载器的 parent-delegation model</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>parent-delegation model 中文通常翻译为双亲委派模式，这里的“双亲”其实翻译的不准确，存在误导，父辈代理模型可能更恰当。为了沿用中文习惯，下文还是以双亲委派模型来指代。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（在它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。模型如下图：</p><p><img src="http://ryan-hou.github.io/assets/img/blogPic/classLoader.png" alt></p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>实现双亲委派的代码集中在 <code>java.lang.ClassLoader</code> 类的 <code>loadClass()</code> 方法中，很清晰易懂：先检查是否已被加载过，若没有则递归调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类的加载器作为父加载器。如果父加载器加载不到该类，再调用自己的 <code>findClass()</code> 方法进行加载</p><h3 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h3><p>保证 Java 程序稳定运行</p><blockquote><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</strong>例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果自己去编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但永远无法被加载运行</p></blockquote><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下应用使用默认的系统类加载器（AppClassLoader）就可以满足要求，但如果我们需要加载远程服务器的类，或者说加载网络上的不是本机上的类的时候，就需要自定义类加载器</p><p>自定义类加载器实现过程：</p><ul><li>继承 ClassLoader 类</li><li>如果只是想重新定义如何获取字节码文件的字节流，只需重写 <code>findClass()</code> 方法即可。如果需要打破默认的双亲委派模式，则需要重写 <code>loadClass()</code> 方法</li></ul><p>在 <code>ClassLoader</code> 抽象类中，有三个重要的方法：</p><ul><li><code>loadClass(String name, Boolean reslove)</code>方法，该方法前面说过了，实现了双亲委派模型，一般不重写</li><li><code>defineClass(String name, byte[] b, int off, int len)</code> 用于将原始字节码转为 Class 对象，通过 JNI 实现，一般也不用重写</li><li><code>findClass(String name)</code>方法，根据类的 binary name 来查找类的数据，把找到的 <code>.class</code> 文件的内容加载到内存的字节数组，供 defineClass() 方法使用，一般我们会改写这个方法，这里前面也描述过，一旦所有的父加载器无法加载到对应的类，就会调用自己的 <code>findClass(String name)</code> 方法来加载</li></ul><p>下面举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String CLASSLOADER_NAME;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String PATH = <span class="string">""</span>; <span class="comment">// .class file's location</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FILE_TYPE = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.CLASSLOADER_NAME = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String filePath = PATH + name + FILE_TYPE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(filePath));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (index = in.read())) &#123;</span><br><span class="line">                baos.write(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = baos.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            log.error(<span class="string">"File not found error, file path = &#123;&#125;"</span>, filePath, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"read class file error!"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"close io stream error!"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end finally</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类加载器是什么&quot;&gt;&lt;a href=&quot;#类加载器是什么&quot; class=&quot;headerlink&quot; title=&quot;类加载器是什么&quot;&gt;&lt;/a&gt;类加载器是什么&lt;/h2&gt;&lt;p&gt;定义摘自&lt;code&gt;深入理解Java虚拟机&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机设计团队把类加载阶段中的“通过一个类的全限定名获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。而实现这个动作的代码模块称为“类加载器”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的定义中，我们可以得到如下信息：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://ryan-hou.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>null awareness</title>
    <link href="https://ryan-hou.github.io/2019/04/07/null-awareness/"/>
    <id>https://ryan-hou.github.io/2019/04/07/null-awareness/</id>
    <published>2019-04-07T14:30:20.000Z</published>
    <updated>2020-04-08T07:05:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>前面翻译了一篇关于如何合理使用 null 的文章:<a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a>，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的</p><h3 id="null-是什么"><a href="#null-是什么" class="headerlink" title="null 是什么"></a>null 是什么</h3><p>null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:</p><a id="more"></a><ul><li>null 是关键字，大小写敏感</li><li>null 既不是对象也不是一种类型，它仅是一个<strong>特殊值</strong>，你可以将它赋予任何引用类型，你也可以将 null 强制转化为任何引用类型</li><li>可以使用 == 和 = 来操作 null 值，但是不能使用其他逻辑操作，在 Java 中 <code>null == null</code> 返回 true</li><li>使用作为引用类型变量默认值的 null，instanceof 操作符将会返回 false</li></ul><h3 id="null-带来的问题"><a href="#null-带来的问题" class="headerlink" title="null 带来的问题"></a>null 带来的问题</h3><p>null 本身不是一个对象，通过 null 访问对象的成员方法或者成员变量(解引用)会导致空指针异常(NPE)；由于我们很容易忽略判断一个对象是否为 null，所以想当然的进行解引用操作时会带来 NPE 问题</p><h3 id="如何规避-null-的问题"><a href="#如何规避-null-的问题" class="headerlink" title="如何规避 null 的问题"></a>如何规避 null 的问题</h3><p><strong>意识非常重要，意识非常重要，意识非常重要</strong>，重要的事情说三遍！当我们拿到一个引用类型的变量时，条件反射的就要考虑这个变量是不是 null，如果是 null 该怎么处理？我自己写的代码导致了 NPE 时，我总会反思自己: 代码里的 NPE 都解决不了，难怪现实中也没对象……</p><p>有了上面的意识，下面再介绍一些实用的方法来规避 NPE。部分内容在 <a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a> 也有提到，可以互为参考。</p><p>既然 NPE 的源头在于 null，那么避免使用 null 就可以从源头上解决这个问题。比如可以使用 Guava 提供的 <code>ImmutableMap, ImmutableList</code> 等不允许元素为 null 的集合类。尽量不要用 null 来初始化变量，函数尽量不要返回 null。对于必须要用 null 的场景考虑单独定义相应的 null object</p><p>采用防御性编程。作为函数作者，我们要对入参进行必要的校验，不允许参数为空时直接抛出异常而不是继续执行。由函数的调用者对程序异常负责；尽量不返回 null，比如可以返回 Optional 对象，或者 null object</p><p>作为函数调用者，要对返回值是否为 null 保持敏感。明确返回的 null 值含义，进行相应的检查和处理。比如远程调用时，对于返回值通常要进行判空处理</p><p>使用 @NotNull 和 @Nullable 注解配合 IntelliJ 尽量在早期发现和预防 NPE</p><p>对于链式调用要格外注意，很容易在某个调用过程发生 NPE。比如 <code>obj.methodA().methodB().methodC()</code></p><p>警惕包装类型的自动装箱和拆箱。相比基本数据类型，包装类型存在 null 这个默认值，在自动拆箱时很容易 NPE。而且正是由于这个语法糖，我们会下意识的把包装类和基本类型等同，实际上两者是很不一样的。所以对于这个语法糖我个人持弊大于利的观点。总之，在使用包装类型时，要格外留心，他们是包装类型而不是基本类型，不能闭着眼睛混用！</p><p>以上是对于 null 的总结，概括来说，就是<strong>要时刻对于 null 这个 corner case 保持警惕，然后采取合理的处理方式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面翻译了一篇关于如何合理使用 null 的文章:&lt;a href=&quot;https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/&quot;&gt;Using and avoiding null&lt;/a&gt;，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的&lt;/p&gt;
&lt;h3 id=&quot;null-是什么&quot;&gt;&lt;a href=&quot;#null-是什么&quot; class=&quot;headerlink&quot; title=&quot;null 是什么&quot;&gt;&lt;/a&gt;null 是什么&lt;/h3&gt;&lt;p&gt;null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="经验" scheme="https://ryan-hou.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Using and avoiding null</title>
    <link href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/"/>
    <id>https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/</id>
    <published>2019-04-06T15:50:20.000Z</published>
    <updated>2020-04-08T02:58:57.690Z</updated>
    
    <content type="html"><![CDATA[<p>文章翻译自 Google Guava 文档，原文链接: <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Using and avoiding null</a></p><h3 id="Why-avoid-null？"><a href="#Why-avoid-null？" class="headerlink" title="Why avoid null？"></a>Why avoid null？</h3><blockquote><p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p></blockquote><p>随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的</p><a id="more"></a><p>此外，null 非常有歧义性。很难从返回的 null 得到具体的含义－－例如，<code>Map.get(key)</code> 返回 null，既可能是因为该 key 对应的 value 是 null，也可能是因为该 key 不存在。null 可以表示失败，也可以表示成功，可以表示几乎所有东西。使用其他表意更清晰的东西而不是 null 可以增强代码可读性</p><p>上面说了，绝大部分情况下都不要随意使用 null，同时这也说明了 null 在一些场景下的使用是合理的。从内存和速度的角度来看，使用 null 很”廉价”，而且在对象数组中也不可避免。不同于类库，在应用代码中，null 通常会因表义不清，进而带来歧义和奇葩的 bug－－比如，当 <code>Map.get</code> 返回 null，它可以表示值不存在或者值存在但是为 null。更要命的是，null 不会给 null 值本身到底意味着什么提供任何提示</p><p>综上原因，只要存在可以方便使用 null 的 workaround，Guava 中相应的很多工具类都采用 fail fast 策略拒绝 null 值。此外，Guava 提供了很多工具避免你使用 null，或者在你必须要使用 null 时用起来更简单</p><h3 id="Specific-Cases"><a href="#Specific-Cases" class="headerlink" title="Specific Cases"></a>Specific Cases</h3><p>如果你想要在 <code>Set</code> 或者 <code>Map</code> 的 key 中使用 null，不要这么做！在查询操作中单独定义关于 null 值的 <strong>special-case</strong> 会使代码更加清晰</p><p>如果你想在 <code>Map</code> 中使用值为 null 的 value，那么把这个键值对单独定义出来。把 <code>Set</code> 中非空的 key (或者为空的 key)单独定义。因为我们很容易把 Map 中不存在某个 key 和 Map 中存在某个 key，该 key 对应的 value 值为 null 这两种完全不同的情景搞混。把这样的 key 单独定义出来要好得多，同时这样会<strong>强迫你去思考</strong>你的应用中一个 key 对应的 value 值为空，是怎样的一种场景</p><p>如果你在 <code>List</code> 中使用 null，而这个 List 是稀疏的，可能定义一个 <code>Map&lt;Integer, E&gt;</code> (key 为 List 元素的下标值，value 为对应的 List 元素)会让代码更加高效，同时也可能更符合你的需求</p><p>考虑一下是否存在一个 “null object” 可以使用，这种情况不总是存在，但是有些场景，比如一个枚举类可以加一个常量来代表你希望 null 值所表示的含义。例如，在 <code>java.math.RoundingMode</code> 中有一个 <code>UNNECESSARY</code> 值来表示 “do no rounding, and throw an exception if rounding would be necessary.”</p><p>如果你确实需要 null 值，那就不要使用 null-hostile 的集合类（比如 <code>ImmutableList, ImmutableMap</code>），可以使用支持 null 的集合类实现。比如，使用 <code>Collections.unmodifiableList(Collection&lt;? extends T&gt; c)</code> 而不是 <code>ImmutableList</code></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>注: JDK 1.8 中已经引入了类似的 Optional 工具类，基本思想是一致的: null 指针之所以存在问题，是因为你可以在不检查 null 的情况下访问对象的成员方法和成员变量(null 解引用导致 NPE)。使用 Optional 可以强迫你去思考 null 这种情况或者通过类似 <code>ifPresent(Consumer&lt;? super T&gt; consumer)</code> 这样的方法把判断是否为 null 和访问操作合二为一，只有不为 null 时才能进行相应操作</p><p>在很多场景下，我们程序员使用 null 是用来<strong>表示某种缺失</strong>：在某个地方可能会存在一个值，但是现在没有或者找不到。<code>Optional&lt;T&gt;</code> 把可为空的引用T替换为一个非空的 Optional 值。一个 Optional 要么包含一个非空的引用T(在这种场景下我们说这个引用是 <strong>present</strong> 的)，要么什么也不包含（在这种场景下，我们说这个引用是 <strong>absent</strong> 的）。即引用要么 present 要么 absent，不存在 <strong>contain null</strong>，避免产生歧义</p><p>下面列一些常用的操作：（注: 下述方法均为 JDK 中 <code>Optional&lt;T&gt;</code> 类的方法，使用方式和 Guava 基本一致 ）</p><h4 id="Making-an-Optional"><a href="#Making-an-Optional" class="headerlink" title="Making an Optional"></a>Making an Optional</h4><p>Optional 中的静态方法:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>Make an Optional containing the given non-null value, or fail fast on null.</td></tr><tr><td>Optional.ofNullable(T)</td><td>Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.</td></tr></tbody></table><h4 id="Query-methods"><a href="#Query-methods" class="headerlink" title="Query methods"></a>Query methods</h4><p>下面是常用的实例方法</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>boolean isPresent()</td><td>Returns true if this Optional contains a non-null instance.</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</td></tr><tr><td>T get()</td><td>Returns the contained T instance, which must be present; otherwise, throws an NoSuchElementException</td></tr><tr><td>T orElse(T other)</td><td>Return the value if present, otherwise return other.</td></tr><tr><td>Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></td><td>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an Optional describing the result.  Otherwise return an empty Optional.</td></tr></tbody></table><p>Optional 还提供了其它有用的方法，具体信息可以去看 Javadoc</p><h4 id="What’s-the-point"><a href="#What’s-the-point" class="headerlink" title="What’s the point?"></a>What’s the point?</h4><p>除了通过给 null 一个名字(缺失与否)来增强可读性，Optional 带来的最大好处在于它是 idiot-proof-ness 的，它迫使你去思考 absent 的场景到底是怎样的，否则你的程序可能会编译不过去，因为你必须手动 unwrap the Optional 并处理 absent 的情况。直接使用 null 使这些情况很容易被忽略，尽管 FindBugs 也可以提供帮助，但是我们不认为它能像 Optional 一样解决这个问题</p><p><strong>当返回一个可能存在或者可能不存在的值时，使用Optional 更加有用。</strong>对于 <code>other.method(a, b)</code>方法，相比我们在实现这个方法时忘记判断 a,b 可能为 null 这种情况，我们更容易忘记这个方法可能会返回 null。而返回 Optional 则使调用者不可能忘记处理这种情况，因为他们必须 unwrap 这个对象来使他们的代码能编译</p><h3 id="Convenience-methods"><a href="#Convenience-methods" class="headerlink" title="Convenience methods"></a>Convenience methods</h3><p>无论何时你想使用一个默认值来代替 null，可以使用 <code>MoreObjects.firstNonNull(T, T)</code>，正如该方法的名字所示，如果两个输入都是 null，该方法会通过抛出NPE来实现 fail fast。如果你在使用 Optional 对象，那么 <code>first.orElse(second)</code> 是更好的替代方法</p><p>在<code>Strings</code>类中提供了几个处理可能为空的方法，而且我们专门定义了恰当的名字：</p><ul><li>emptyToNull(String)</li><li>isNullOrEmpty(String)</li><li>nullToEmpty(String)</li></ul><p>我们想强调一下，这些方法主要是用来处理那些把 null 字符串和 empty 字符串等同看待的API。每当你写出把 null 和 empty 字符串混用的代码，Guava 团队的小伙伴都”哭了”(null 字符串和 empty 字符串混用通常是令人不安的 code smell)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章翻译自 Google Guava 文档，原文链接: &lt;a href=&quot;https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using and avoiding null&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Why-avoid-null？&quot;&gt;&lt;a href=&quot;#Why-avoid-null？&quot; class=&quot;headerlink&quot; title=&quot;Why avoid null？&quot;&gt;&lt;/a&gt;Why avoid null？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“Null sucks.” -Doug Lea&lt;br&gt;&lt;br&gt;&lt;br&gt;“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>作用域与闭包</title>
    <link href="https://ryan-hou.github.io/2019/03/08/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>https://ryan-hou.github.io/2019/03/08/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</id>
    <published>2019-03-08T15:16:52.000Z</published>
    <updated>2020-04-13T08:46:12.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>简单来说一句话：<strong>带上下文的函数</strong>，下面展开说明一下</p><p>声明：接下来的部分内容来自对 StackOverflow 回答的翻译，原答案链接 <a href="http://stackoverflow.com/questions/36636/what-is-a-closure" target="_blank" rel="noopener">What is a ‘Closure’?</a></p><p>要想理解好闭包，首先要弄清楚 <code>Scope</code>，当我们声明一个局部变量时，这个变量会有一个 Scope，通常局部变量仅在声明它的 block 或 function 中有效，比如下面 JS 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// fails</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>当我们访问一个局部变量时，大部分语言会先在当前 Scope 中寻找这个变量，找不到再去该 Scope 的父 Scope 中去寻找，直到找到根 Scope 为止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br></pre></td></tr></table></figure><p>当一个 block 或者 function 结束时，他的局部变量会被清理掉，这符合我们的预期</p><h3 id="闭包是持有局部变量的持续存在的-Scope"><a href="#闭包是持有局部变量的持续存在的-Scope" class="headerlink" title="闭包是持有局部变量的持续存在的 Scope"></a>闭包是持有局部变量的持续存在的 Scope</h3><p>闭包是一个持续存在的 Scope，该 Scope 会持有局部变量，即使在代码执行结束并跳出局部变量所在的 block 仍然有效。支持闭包的语言(如 JS，Swift 和 Ruby)允许你持有一个指向 Scope 对象(包括他的 parent scopes)的引用，即使在这些变量被声明的 block 执行完，你仍然可以在其他的地方持有指向这个 block 或者 function 的引用</p><p><strong>这些 Scope 对象和在该 Scope 下的局部变量被绑定到 function，并且只要该 function 存在，那么这些局部变量就存在 (函数和函数声明时的 scope 共存亡)</strong></p><p>这给我们使用函数提供了便利性，<strong>在函数第一次被声明的 Scope 中的局部变量会始终保持在该 Scope 中，即使我们下次从不同的 context 调用该 function 依然可以得到该局部变量</strong></p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this returns a function</span></span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute outer to get inner</span></span><br><span class="line"><span class="keyword">var</span> fuc = outer(); </span><br><span class="line"><span class="comment">// prints the value of a, which is 1</span></span><br><span class="line">fuc(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面在一个函数中定义了一个函数，内部的函数可以访问外部函数所有的局部变量，包括 <code>a</code>，变量 a 在内部函数的父 Scope 中</p><p>通常当一个函数退出，他所声明的所有的局部变量都会被回收，然而在这里，当我们返回内部函数并把它指向变量 fnc 时，外部函数(outer)退出后，<strong>在内部函数(inner)被定义的 Scope 中的所有的局部变量会持续存在。</strong><code>变量a within a closure.</code></p><p><strong>在上面的例子中，变量 a 完全是 fnc 函数私有的(函数加数据)，这为我们在函数式语言中创建私有变量提供了一种方式。(函数加上私有变量, 是不是看起来很像 OOP 中的对象(方法加上数据), 确实可以基于 Closure 构建对象系统 )</strong></p><p>上面的示例代码中，a 属于 <code>outer</code> scope，<code>inner</code> scope 存在一个指向父scope<code>outer</code>的指针。<code>fnc</code> 是一个指向 <code>inner</code> 的变量，a 会和 <code>fnc</code> 共存亡，a 在闭包中</p><p>以上，翻译结束，下面再对照下 OO 下的闭包</p><h2 id="OO-化的闭包"><a href="#OO-化的闭包" class="headerlink" title="OO 化的闭包"></a>OO 化的闭包</h2><p>在 JS 中，函数是一等公民，可以作为参数或者返回值传递，可以用于高阶函数，但是在 Java 中，函数不能独立存在，需要依附于类或者对象(函数在类中被称为方法，其实函数应该是可以单独存在的一种抽象)，正因此才有了类似函数对象，命令模式等一些东西，看似高大上，实际上是编程语言的限制带来的无奈之举</p><p>有人曾说过，<strong>类是带函数的数据，闭包是带数据的函数</strong>，上面我们看到了在 JS 中是如何使用闭包的，下面我们看一下在 OO 中如何使用闭包</p><p>在 <code>Thinking in Java</code> 中对于闭包与回调一节曾提到过：</p><blockquote><p>闭包(closure)是一个可调用的对象，它记录了一些信息，这些信息来自于创建他的作用域。通过这个定义，可以看出<strong>内部类是面向对象的闭包</strong>，因为他不仅包含外围类对象(创建内部类对象的作用域)的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类对象有权操作外部类对象所有的成员，包括 private 成员</p></blockquote><p>举个例子(代码修改自 <code>Thinking in Java</code>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callee</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other methods...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise you'd</span></span><br><span class="line">            <span class="comment">// get an infinite recursion:</span></span><br><span class="line">            Callee.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementable callbackReference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackReference = callbackReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Other operations...</span></span><br><span class="line">        <span class="comment">// 调用回调接口</span></span><br><span class="line">        callbackReference.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee c = <span class="keyword">new</span> Callee();</span><br><span class="line">        Caller caller = <span class="keyword">new</span> Caller(c.getCallbackReference());</span><br><span class="line">        caller.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中，内部类 Closure 实现了 Incrementable，以提供一个返回 Callee 的“钩子”，而且是一个安全的钩子，无论谁获得此 Incrementable 的引用，都只能调用 increment() (如果直接使用 Callee 类的实例作为钩子，该钩子还可以调用 Callee 类的其它方法，控制的力度不够细)，除此之外没有其他的功能。Caller 的构造器需要一个 Incrementable 的引用作为参数 (也可以通过 set 方法注入的方式在运行时动态设置回调引用)，然后在以后某个时刻，Caller 对象可以使用此引用回调 Callee 类。<strong>回调的价值在于它的灵活性，可以在运行时动态的决定需要调用什么方法</strong> (更多关于回调的内容可以参考之前整理的文章: <a href="https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">回调及在Java中的使用</a>)</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最近看了R大关于闭包的一篇博客，又有了一些新的思考，原文地址: <a href="https://rednaxelafx.iteye.com/blog/245022" target="_blank" rel="noopener">关于对象与闭包的关系的一个有趣小故事</a>，总结一些要点:</p><blockquote><p>闭包的要点有两个:<br>1、一个含有自由变量的函数；<br>2、这些自由变量所在的环境。<br><strong>外部环境持有内部函数所使用的自由变量，对内部函数形成“闭包”，就这样。</strong><br>简单但不严格的说，一个函数的“自由变量”就是既不是参数也不是局部变量的变量。基于类的面向对象程序语言中有一种情况，就是方法使用的自由变量来自其所在的类的实例</p></blockquote><blockquote><p>OO 里一般不提闭包<br>面向对象的语言里一般不把类称为闭包，没为什么，就是种习惯。<br><strong>当然严格来说方法(类的成员方法)所捕获的自由变量不是类的字段 x，而是this；x 是通过 this 来访问到的，完整写出应该是 <code>this.x</code></strong></p></blockquote><p>综上，通过对象或者闭包都可以获取函数的自由变量，没有高低之分</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h2&gt;&lt;p&gt;简单来说一句话：&lt;strong&gt;带上下文的函数&lt;/strong&gt;，下面展开说明一下&lt;/p&gt;
&lt;p&gt;声明：接下来的部分内容来自对 StackOverflow 回答的翻译，原答案链接 &lt;a href=&quot;http://stackoverflow.com/questions/36636/what-is-a-closure&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is a ‘Closure’?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要想理解好闭包，首先要弄清楚 &lt;code&gt;Scope&lt;/code&gt;，当我们声明一个局部变量时，这个变量会有一个 Scope，通常局部变量仅在声明它的 block 或 function 中有效，比如下面 JS 代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;// works&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;// fails&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>重新认识信息隐藏</title>
    <link href="https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    <id>https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/</id>
    <published>2019-02-22T12:25:51.000Z</published>
    <updated>2020-04-10T07:28:04.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个重要却容易忽略的问题"><a href="#一个重要却容易忽略的问题" class="headerlink" title="一个重要却容易忽略的问题"></a>一个重要却容易忽略的问题</h2><p>在谈到 OOP 时，大家一般会想到<strong>封装，继承和多态</strong>，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，<strong>信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。</strong>那信息隐藏为什么如此重要？</p><p>引用一段<code>Effective Java</code>中的话：</p><blockquote><p>要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信</p></blockquote><a id="more"></a><p>除了设计好的需要对外公开的 API 外，其他的成员原则上都要隐藏，如果不能很好的实现信息隐藏，意外暴露的成员被客户端操作会导致对象状态的不可控，<strong>这也要求我们在写代码时要保持有意识的状态，每一行代码都是一种“承诺”</strong></p><h2 id="封装与访问控制"><a href="#封装与访问控制" class="headerlink" title="封装与访问控制"></a>封装与访问控制</h2><p>谈信息隐藏，自然避不开封装。广义上的封装仅仅只是打包，把一些数据和行为封闭到一个盒子，这个盒子可能是黑盒子也可能是白盒子。相比 C 语言，Java 的封装引入了一种<strong>新的模块机制: 把相关的数据和作用在其上的运算打包为称为类的模块，从而为域和函数(准确的说应该是成员方法)提供了一个上下文。</strong></p><p>我们通常所说的狭义的封装是指<strong>在打包的基础上加上访问控制，以实现信息隐藏；访问控制不仅仅是语法上的限制，也是语义上的规范</strong>，标有 public 的是接口，标有 private 的是实现；这种语义显然比文档注释更加直观。</p><p>访问控制是对静态代码的控制，并非牢不可破，通过反射机制一样可以访问到 private 成员，这里也引出一个常见的误区，认为信息隐藏是为了安全性，不能说错，但信息隐藏的本意并不在此，<strong>信息隐藏通过屏蔽一个模块中非本质，容易变化的部分，从而保证了内部的修改不会波及客户，它的目的是为了提高稳定性和灵活性</strong>，通过信息隐藏，一个类相当于被划分为阴阳两面，阴面的实现对于客户是透明的</p><h2 id="如何更好的隐藏信息"><a href="#如何更好的隐藏信息" class="headerlink" title="如何更好的隐藏信息"></a>如何更好的隐藏信息</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><p>这个很好理解，举个简单例子，把一个类的 <code>private</code> 成员改为 <code>public</code> 不会产生问题，反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广，具体可以采用如下操作</p><h4 id="顶层类如果可以包级私有，那就包级私有"><a href="#顶层类如果可以包级私有，那就包级私有" class="headerlink" title="顶层类如果可以包级私有，那就包级私有"></a>顶层类如果可以包级私有，那就包级私有</h4><p>我们通过 IDE 生成类时，一般会默认用 public 修饰类，这里值得商榷，一个包中的类大部分都是为本包提供服务的，没有必要作为包的 API 导出，因为一旦导出，你就要负责一直维护他</p><h4 id="在公有类中使用访问方法而非公有域"><a href="#在公有类中使用访问方法而非公有域" class="headerlink" title="在公有类中使用访问方法而非公有域"></a>在公有类中使用访问方法而非公有域</h4><p><strong>公有类永远都不应该暴露可变的域。在特殊情况下，暴露公有的静态的 final域是可以接受的，但是这里的域要么是基本类型，要么是不可变的。</strong>比如一个很常见的错误就是：<code>public Date getBirthday() { return birthday }</code> 这里即使 birthday 使用了 <code>private</code> 的访问修饰符，但仍然没用，因为 Date 类不是不可变的（当然了 Date 类是可变的属于类库设计的缺陷），这里应该提供防御性复制</p><h4 id="private-frist"><a href="#private-frist" class="headerlink" title="private frist"></a>private frist</h4><p>使用 private 不需要理由，不使用才需要理由，这也是为什么如 C# 之类的语言默认的访问修饰符是 private（Java默认是包级私有）</p><h4 id="警惕长度不为0的数组"><a href="#警惕长度不为0的数组" class="headerlink" title="警惕长度不为0的数组"></a>警惕长度不为0的数组</h4><p><strong>长度不为0的数组总是可变的，类具有公有的静态的 final 数组域或者返回这种域的访问方法，几乎总是错误的。</strong>可以通过把数组域私有，并添加一个公有方法，返回私有数组域的一个备份:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="comment">// shallow copy, Thing need to be Immutable</span></span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者很多时候，并不需要一次性返回一整个数组，而是返回数组中的某一个元素，提供这样细粒度的 API 可能会更方便，而且效率更好更安全</p><h4 id="隐藏实现方式"><a href="#隐藏实现方式" class="headerlink" title="隐藏实现方式"></a>隐藏实现方式</h4><p>信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如<code>public int computeAge()</code> 这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏</p><h3 id="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"><a href="#如果内部数据必须要暴露出来，那么要尽量使可变性最小化" class="headerlink" title="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"></a>如果内部数据必须要暴露出来，那么要尽量使可变性最小化</h3><h4 id="能设计为不可变类就不要设计为可变类"><a href="#能设计为不可变类就不要设计为可变类" class="headerlink" title="能设计为不可变类就不要设计为可变类"></a>能设计为不可变类就不要设计为可变类</h4><p>除非有很好的理由使类成为可变的，不然就应该是不可变的类。构造一个不可变的类遵循相应的规则即可(参考<code>Effective Java</code>)。不可变的类只有一种状态，那就是被创建时的状态；而且不可变的类本质上是线程安全的，不需要同步，可以被自由的共享而不用进行保护性拷贝。对于频繁用到的值，可以使用公有静态 final 常量，或者使用静态工厂替换构造器提供缓存功能。但是不可变类也有缺点，那就是每一个值都是一个对象，有时为了性能和内存考量需要提供可变的配套类，如<code>StringBuilder</code></p><h4 id="能用-final-域就不要不用"><a href="#能用-final-域就不要不用" class="headerlink" title="能用 final 域就不要不用"></a>能用 final 域就不要不用</h4><p>如果类不能做成不可变的，那也要尽可能的降低它的可变性，减少对象可存在的状态，可以更容易的分析它的行为，减少出错的几率。<strong>除非有令人信服的理由，不然所有的域都应该是  final的</strong></p><h4 id="数据修改接口慎重提供"><a href="#数据修改接口慎重提供" class="headerlink" title="数据修改接口慎重提供"></a>数据修改接口慎重提供</h4><p>不要追求 get/set 方法对称的教条，set 方法能不提供就不提供</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于信息隐藏的一些重要知识，很基础但也很重要，通过合理的信息隐藏，我们才能构建出稳健的类和包，<strong>使他们提供尽可能少的开口，以更好的面对变化，不至于失控</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;a href=&quot;#一个重要却容易忽略的问题&quot; class=&quot;headerlink&quot; title=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;/a&gt;一个重要却容易忽略的问题&lt;/h2&gt;&lt;p&gt;在谈到 OOP 时，大家一般会想到&lt;strong&gt;封装，继承和多态&lt;/strong&gt;，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，&lt;strong&gt;信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。&lt;/strong&gt;那信息隐藏为什么如此重要？&lt;/p&gt;
&lt;p&gt;引用一段&lt;code&gt;Effective Java&lt;/code&gt;中的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>回调及在Java中的使用</title>
    <link href="https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-02-10T15:39:14.000Z</published>
    <updated>2020-04-13T04:16:01.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回调是什么"><a href="#回调是什么" class="headerlink" title="回调是什么"></a>回调是什么</h2><p>维基百科的定义如下:</p><blockquote><p>In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.</p></blockquote><p>可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)</p><a id="more"></a><h2 id="回调的过程"><a href="#回调的过程" class="headerlink" title="回调的过程"></a>回调的过程</h2><p>通过上面的定义我们不难得出，使用回调有这么几个步骤：<code>1)定义回调接口/方法；2)注册回调；3)当事件发生时，调用回调方法</code></p><p>本质上来说就是我们利用某种方式(函数指针，lambda 表达式等)，把回调函数像参数一样传入中间函数(Model code as data)，在适当的时机中间函数会调用传入的回调函数。在传入一个回调函数之前，中间函数是不完整的。也就是说程序可以在运行时，通过注册不同的回调函数，来决定、改变中间函数的行为，比简单的函数调用灵活多了，使代码在空间上解耦，如果使用异步回调的话，相当于在时间上也做了解耦。像 Java 中的模版方法模式，观察者模式，策略模式等都使用了回调</p><h2 id="Java中回调的使用"><a href="#Java中回调的使用" class="headerlink" title="Java中回调的使用"></a>Java中回调的使用</h2><p>在 Java 中，因为函数不能作为参数直接传递，我们一般通过定义接口(或者抽象类也可以)的方式来封装方法以实现回调，并且经常结合匿名类表达式(Anonymous class expression)和匿名方法(lambda 表达式)一起使用</p><p>通常先定义一个回调接口，接口中定义需要被回调的方法，然后把该接口作为参数传入需要调用回调方法的中间函数，最后在需要的时候，通过传入实现了该接口的类实例或者直接使用匿名内部类或 lambda 表达式的方式来作为参数传入中间函数，回调接口中定义的回调方法，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallbackInterface</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 定义回调方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testCallback</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间函数，通过 CallbackInterface 接口封装回调方法，作为中间函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCall</span><span class="params">(<span class="keyword">int</span> a, String param, CallbackInterface callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// concrete opearaions...</span></span><br><span class="line">        <span class="comment">// 调用回调方法</span></span><br><span class="line">        callback.testCallback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Caller caller = <span class="keyword">new</span> Caller();</span><br><span class="line">        CallbackInterface callback = <span class="keyword">new</span> CallbackInterfaceImpl();</span><br><span class="line">        <span class="comment">// 1.实现回调接口的类实例注册到中间函数</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, callback);</span><br><span class="line">        <span class="comment">// 2.直接使用匿名类表达式</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, <span class="keyword">new</span> CallbackInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Test Anonymous class and callback."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 3. 使用 lambda 表达式</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, () -&gt; &#123; System.out.println(<span class="string">"Test lambda expression and callback."</span>); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调在设计模式中的应用"><a href="#回调在设计模式中的应用" class="headerlink" title="回调在设计模式中的应用"></a>回调在设计模式中的应用</h2><p>以模版方法模式为例简单说一下，我们都知道模版方法模式的主要思想是<strong>定义出算法的骨架，然后留出扩展点供子类实现</strong>，在抽象父类中，我们通常会设计一些钩子方法，并提供默认实现，并由子类决定是否要进行覆盖，这里的<strong>钩子方法其实就是一种回调方法</strong>，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件（高层组件决定如何使用回调方法）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回调是什么&quot;&gt;&lt;a href=&quot;#回调是什么&quot; class=&quot;headerlink&quot; title=&quot;回调是什么&quot;&gt;&lt;/a&gt;回调是什么&lt;/h2&gt;&lt;p&gt;维基百科的定义如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>反转单链表三种经典的思路</title>
    <link href="https://ryan-hou.github.io/2019/01/20/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>https://ryan-hou.github.io/2019/01/20/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E6%80%9D%E8%B7%AF/</id>
    <published>2019-01-20T13:20:02.000Z</published>
    <updated>2020-04-11T10:17:12.819Z</updated>
    
    <content type="html"><![CDATA[<p>基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路</p><h2 id="头插法构建单链表"><a href="#头插法构建单链表" class="headerlink" title="头插法构建单链表"></a>头插法构建单链表</h2><p>头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 <code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    LinkNode dummy = <span class="keyword">new</span> LinkNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LinkNode cur = <span class="keyword">new</span> LinkNode(head.val);</span><br><span class="line">        cur.next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="指针移动实现反转"><a href="#指针移动实现反转" class="headerlink" title="指针移动实现反转"></a>指针移动实现反转</h2><p>反转一个单链表还有一种很直观的解决方法就是遍历这个单链表，然后依次反转每个需要反转的节点。但是这里存在一个问题，在反转当前节点的时候，当前节点的下一个节点需要先提前保存一下，不然会丢失下一个节点。对于算法的边界，需要考虑链表为空，链表只有一个节点，有两个节点和多于两个节点这几种情况。时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode pre = head;</span><br><span class="line">    LinkNode cur = head.next;</span><br><span class="line">    LinkNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// next 保存指针指向将要反转的节点原本的下一个节点</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// pre, cur 同时后移</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>链表的定义和二叉树类似，也是一个递归的定义，因此使用递归的思路来处理链表也是可行的。反转一个单链表，可以分解为，先反转单链表除了头节点之后的单链表，然后处理反转后的单链表与头节点的关系即可。递归出口是头节点为空或者头节点的下一个节点为空。使用递归这种声明式的实现方式使代码更加简洁，重在描述代码做什么而不是怎么做。空间复杂度为<code>O(n)</code>，时间复杂度为<code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode headOfLeft = reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> headOfLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路&lt;/p&gt;
&lt;h2 id=&quot;头插法构建单链表&quot;&gt;&lt;a href=&quot;#头插法构建单链表&quot; class=&quot;headerlink&quot; title=&quot;头插法构建单链表&quot;&gt;&lt;/a&gt;头插法构建单链表&lt;/h2&gt;&lt;p&gt;头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 &lt;code&gt;O(n)&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; LinkNode &lt;span class=&quot;title&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LinkNode head)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LinkNode dummy = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (head != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LinkNode cur = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(head.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur.next = dummy.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dummy.next = cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head = head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dummy.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="https://ryan-hou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>创建一个对象的思考</title>
    <link href="https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2019-01-01T05:59:25.000Z</published>
    <updated>2020-04-09T09:01:03.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事情可能没有看起来那么简单"><a href="#事情可能没有看起来那么简单" class="headerlink" title="事情可能没有看起来那么简单"></a>事情可能没有看起来那么简单</h2><p>Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？</p><ul><li>创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？</li><li>数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？</li><li>时间: 是立即构建，还是延迟构建呢？</li><li>形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？</li></ul><a id="more"></a><p>以上这些，在不同的场景下，我们需要做不同的考量，本文仅从构造器的弊端来谈一下静态工厂方法，工厂方法模式，抽象工厂模式和 Builder 模式</p><h2 id="构造器有什么问题"><a href="#构造器有什么问题" class="headerlink" title="构造器有什么问题"></a>构造器有什么问题</h2><p>用构造器来创建对象，是很自然也很简单的，大部分场景下直接通过构造器构建对象就足够了。但构造器也存在一些问题，下面具体谈一下</p><h3 id="构造器缺乏表现力"><a href="#构造器缺乏表现力" class="headerlink" title="构造器缺乏表现力"></a>构造器缺乏表现力</h3><p><strong>构造器的名字必须和类名保持一致，缺乏表现力。</strong>而且在构造器参数除了名字不同外(参数类型，个数和顺序完全相同)，会导致构造器的方法签名重复，比如很经典的一个例子就是用 Point 类代表平面坐标系的点，通过构造器提供直角坐标和极坐标的创建方式，代码会出现：<code>Point(double x, double y) 和 Point(double r, double theta)</code> 不仅表现力不足，而且方法签名冲突，我们可以使用<strong>静态工厂方法</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">cartesian</span><span class="params">(<span class="keyword">double</span> x, doubly y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">polar</span><span class="params">(doule r, <span class="keyword">double</span> theta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(r * Math.cos(theta), r * Math.sin(theta));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码可读性要好很多，而且不存在方法签名冲突的问题</p><h3 id="构造器的每次调用都会创建新对象"><a href="#构造器的每次调用都会创建新对象" class="headerlink" title="构造器的每次调用都会创建新对象"></a>构造器的每次调用都会创建新对象</h3><p>通常情况下每次调用构造器都会创建对象（构造器方法里做了自定义的特殊处理不考虑在内），而这并非总是合适的。不公开构造器而是借助静态方法创建对象，可以控制对象的个数。不管是出于管理的原因，如单例模式，还是出于性能的考虑，如对象池技术，这些都是单纯使用构造器做不到的。</p><p>典型的代表就是 JDK 中 Boolean 类提供的 <code>static valueOf(boolean b)</code> 方法，但是该方法提出的比较晚，Boolean 类还是可以用构造器创建多余的对象，因此 <code>valueOf</code> 方法的文档中说明了在大部分场景下应该用该方法替代构造器（除非就是需要创建一个全新的 Boolean 对象）</p><h3 id="构造器无法被继承，也就无法提供多态"><a href="#构造器无法被继承，也就无法提供多态" class="headerlink" title="构造器无法被继承，也就无法提供多态"></a>构造器无法被继承，也就无法提供多态</h3><p><strong>要使用构造器，就要知道具体的类型，这违背了针对接口编程的原则，同时也违背了依赖倒置原则(依赖尽量通过抽象来完成)，当然了这里不能一概而论，如果是依赖像 String 这样稳定的类，也是无可厚非的，但是在实际编程中，考虑减少对具体类的依赖是好的习惯</strong>，这里就可以引出工厂方法模式了</p><p>我们把创建对象的过程封装到工厂中，这实际上就是<strong>保变原则</strong>的使用，提供了一个<strong>中间层</strong>，我们的客户端代码不需要知道对象如何创建，只需要知道我去工厂里拿就可以了，这样将来创建对象的代码发生变化也不会波及客户端代码。同时<strong>工厂方法一般是一个抽象的方法，由工厂的实现类来决定要实例化的具体类是哪个，而且经常结合模版方法模式一起使用</strong>，下面是一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里经常结合模版方法模式提供一个骨架，把可扩展的部分也就是创建对象的代码交由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        pizza  = createPizza(type);</span><br><span class="line">        </span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法,由子类来具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式-抽象工厂模式与-Builder-模式"><a href="#工厂方法模式-抽象工厂模式与-Builder-模式" class="headerlink" title="工厂方法模式/抽象工厂模式与 Builder 模式"></a>工厂方法模式/抽象工厂模式与 Builder 模式</h2><p>有时候我们要创建的对象需要各种组件来构成，这些组件构成一个系列，这里我们可以使用抽象工厂模式来定义一套接口（工厂方法模式只能生产一种产品，抽象工厂模式可以生产一系列产品）。<strong>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族,而不需要明确指定具体类</strong></p><p>与工厂方法模式相比，两种模式都能将对象的创建封装起来，使应用程序解耦，并降低其对特定实现的依赖；但是，<strong>工厂方法使用继承</strong>: 把对象的创建委托给子类，子类实现工厂方法来创建对象；<strong>抽象工厂使用对象组合</strong>: 对象的创建被实现在工厂接口所暴露出的方法中；抽象工厂提供创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法，要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中，部分示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    Veggies[] createVeggies();</span><br><span class="line">    <span class="function">Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体对象的创建通过组合方式传入的具体工厂类来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory pizzaIngredientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = pizzaIngredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原料工厂生产pizza原料,代码中使用抽象类型的接口,把客户从使用的实际具体产品中解耦</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Preparing "</span> + name);</span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式是把一个对象的创建分成不同的组件，而 Builder 模式则是把创建对象分为一系列步骤，两者经常结合使用；Builder 模式不关心中间的过程，只关心最后得到的对象，符合<strong>最少知识原则</strong>，而且可以结合链式调用构造复杂的对象，Builder 模式的基本思路如下：</p><p>定义一个静态内部类，并且静态内部类的内部属性就是我们要赋值的属性。通过各个方法把我们要赋的值封装到静态内部类对象中，返回 <strong>this</strong>，目的是要使用链式的结构；定义一个方法，创建目标对象，并且传入已经封装了各个参数的静态内部类对象。目标类定义一个参数为静态内部类的构造函数；完成创建目标对象，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexObj</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String s1;</span><br><span class="line">    <span class="keyword">private</span> String s2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="comment">// getter methods and other methods...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComplexObj</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s1 = builder.s1;</span><br><span class="line">        <span class="keyword">this</span>.s2 = builder.s2;</span><br><span class="line">        <span class="keyword">this</span>.n1 = builder.n1;</span><br><span class="line">        <span class="keyword">this</span>.n2 = builder.n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String s1;</span><br><span class="line">        <span class="keyword">private</span> String s2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s1</span><span class="params">(String s1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s1 = s1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s2</span><span class="params">(String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s2 = s2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n1</span><span class="params">(<span class="keyword">int</span> n1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n1 = n1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n2</span><span class="params">(<span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n2 = n2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComplexObj <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComplexObj(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of class Builder</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实际调用时就可以通过链式调用，使代码更清晰</span></span><br><span class="line">ComplexObj test = <span class="keyword">new</span> ComplexObj.Builder()</span><br><span class="line">                    .s1(<span class="string">"test"</span>).s2(<span class="string">"ff"</span>).n2(<span class="number">2</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于使用构造器创建对象可能需要思考的各种问题，以及引出的几种设计模式，这里只是做一个介绍，并不是教条；面对不同的使用场景，需要有不同的考量，要做不同的取舍，程序设计也是设计，<strong>做设计就要懂得取舍</strong>，这需要经验，思考和功夫，共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;a href=&quot;#事情可能没有看起来那么简单&quot; class=&quot;headerlink&quot; title=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;/a&gt;事情可能没有看起来那么简单&lt;/h2&gt;&lt;p&gt;Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？&lt;/li&gt;
&lt;li&gt;数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？&lt;/li&gt;
&lt;li&gt;时间: 是立即构建，还是延迟构建呢？&lt;/li&gt;
&lt;li&gt;形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>模版方法模式VS策略模式</title>
    <link href="https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-12-22T14:58:32.000Z</published>
    <updated>2020-04-09T03:25:54.808Z</updated>
    
    <content type="html"><![CDATA[<p>模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述</p><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote><p>在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤</p></blockquote><a id="more"></a><p>模版方法模式符合<strong>好莱坞原则(Don’t call us, we’ll call u.)</strong>，好莱坞原则给我们提供了一种防止”依赖腐败”的方法(代码中的依赖关系尽量要保持单向且不循环)，在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件。换句话说，<strong>高层组件对待低层组件的方式是”别调用我们,我们会调用你”</strong></p><p>模版方法模式也符合<strong>开闭原则(OCP)</strong>，算法骨架保持稳定，对修改封闭；通过子类对扩展保持开放</p><p>下面是<code>Head First 设计模式</code>中的一段代码，代码中有关于如何在抽象基类中定义算法骨架并定义子类扩展点的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverageWithHook</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模版方法,定义算法骨架和子类扩展点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 提供钩子方法,控制部分算法的执行,由子类决定是否覆盖该钩子方法</span></span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 交由不同子类具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Boiling water"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pouring into cup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个钩子方法,通常是空的缺省实现,由子类决定是否覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版方法模式在实际使用中是很广泛的，比如 Spring 框架中 <code>BeanFactory</code> 就使用了该模式，并把 getBean() 方法交给不同的子类具体实现；JDK 中 <code>ThreadPoolExecutor</code> 类的 runWorker() 方法就定义了 <code>beforeExecute</code> 和 <code>afterExecute</code> 钩子方法。在实际工作中，我个人也比较喜欢用这个模式，当存在两个行为类似但又不完全相同的类时，可以考虑提取公共流程和可复用的代码到父类，保留不同的地方作为 abstract 方法，交由不同的子类去实现</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</p></blockquote><p>策略模式重在定义不同的算法(行为)接口，然后为每个接口提供不同的实现类，在客户端代码中，通过组合的方式使用抽象的接口，甚至可以提供动态改变算法策略的 API，利用多态和依赖注射的方式灵活的组合和替换具体的算法</p><h3 id="涉及到的设计原则"><a href="#涉及到的设计原则" class="headerlink" title="涉及到的设计原则"></a>涉及到的设计原则</h3><p><strong>封装变化</strong>: 找出应用中可能会变化的部分，把它们抽象出来，这样系统中该部分改变不会影响其他部分</p><p><strong>针对接口编程而不是针对实现编程</strong>: 这里针对接口编程的真正意思是<strong>针对超类型(supertype)编程。</strong>针对接口编程的精髓在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上（为程序提供了动态性）</p><p><strong>多用组合，少用继承(实现继承)</strong>: “有一个”可能比”是一个”更好。当将两个类组合起来使用时,就是组合(composition)，使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以在”运行时动态的改变行为”</p><p>具体的示例代码建议去看<code>Head First 设计模式</code>一书，清晰易懂</p><p>策略模式在实际应用中也比较广泛，比如在 Netty 中，<code>EventExecutorChooser</code> 作为事件执行器选择策略接口，存在<code>PowerOfTwoEventExecutorChooser</code> 和 <code>GenericEventExecutorChooser</code> 两个具体实现类，<code>DefaultEventExecutorChooserFactory</code> 的 newChooser 方法作为策略选择者，会根据执行器数量是否能被2整数选择具体的策略实现。我自己在实际工作中也用过多次，比如在重构系统中一个关于车辆出库的方法时，该方法会判断不同的出库类型，根据类型不同，执行不同的出库逻辑，整个代码通过 if-else 组合，足足有近千行，而且不同的出库逻辑会根据需求存在变动，每次变动都要修改这里的 if-else 逻辑，维护和测试很不方便。通过抽象出一个出库策略接口，然后为不同的出库方式提供不同的实现，并提供一个根据出库方式选择具体策略实现类的策略者，该方法被简化为只有几十行代码，当出库需求变动时，只需要修改需求变动的出库方式对应的出库策略实现类即可，其他的代码均保持不变，符合开闭原则</p><h2 id="比较两种模式"><a href="#比较两种模式" class="headerlink" title="比较两种模式"></a>比较两种模式</h2><ul><li>策略模式侧重于定义一个<strong>算法家族</strong>，并且让算法可以互换，强调灵活性</li><li>而模版方法模式侧重于定义出<strong>算法骨架</strong>，子类可以通过钩子方法指定部分行为。方便代码复用和框架定义，强调的是算法骨架的稳定性</li><li>策略模式采用组合的方式实现，更加有弹性; 模版方法模式采用继承的方式实现</li></ul><p>最后再举个例子，在 <code>Head Fist 设计模式</code> 中提到，Java <code>Arrays</code>类的排序方法也提供了一种模版方法模式的变式: 在 <code>mergeSort</code> 模版方法中, 依赖于 <code>comparable</code> 接口的 <code>compareTo</code> 方法来完成算法；我认为这里理解为策略模式也是合理的，<code>comparable</code> 可以理解为一个算法家族的接口，可以有不同的实现方法，当 <code>mergeSort</code> 方法接收到此类型的具体参数，实质上就是采用了某个具体的策略。从不同的角度来看，我认为这两种观点都有道理，所以说这两种模式确实存在相似性。还是一贯的观点，编程是一门实践性很强的学科，很多时候死抠概念是没意思的，况且有的概念本身就没有定论，而有自己的思考和想法非常重要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述&lt;/p&gt;
&lt;h2 id=&quot;模版方法模式&quot;&gt;&lt;a href=&quot;#模版方法模式&quot; class=&quot;headerlink&quot; title=&quot;模版方法模式&quot;&gt;&lt;/a&gt;模版方法模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的各种姿势</title>
    <link href="https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/</id>
    <published>2018-12-01T02:58:05.000Z</published>
    <updated>2020-04-08T12:49:13.491Z</updated>
    
    <content type="html"><![CDATA[<p>在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other operatons...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 防止通过反射创建多个实例</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"instance already existed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他初始化操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>优点：实现简单，线程安全(依赖 JVM 在加载这个类时创建唯一的实例)</li><li>缺点：不能延迟初始化(类加载时即创建实例对象，至于类加载时机，虚拟机规范并没有强制约束)，如果该类实例化需要的资源很多，会影响内存和性能</li></ul><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>在 jdk5 之后，通过单元素的枚举可以实现单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 其他实例方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举构造单例，写法简单，线程安全，可以防御反射攻击，并且是序列化/反序列化安全的；但是不能延迟初始化</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span> ? <span class="keyword">new</span> Singleton() : instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持延迟初始化，在使用时才去创建单例实例。但是不能保证线程安全，当有多个线程同时执行 <code>instance == null</code> 时，可能会创建多个实例</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>使用同步方法</li></ul><p>在上面代码的基础上，把 <code>getInstance()</code> 方法加上 synchronized 关键字，变为同步方法，保证了不会同时有多个线程进入这个方法</p><p>优点：简单且有效，而且 JVM 会不断优化 synchronized 关键字的实现方式，如果应用程序可以接受同步的开销，推荐使用</p><p>缺点当然是同步方法带来的开销问题，而且在这里实际上只有第一次执行时才真正需要同步，一旦设置好 instance 变量后，就不再需要同步这个方法了，所以我们有必要寻找更优的线程安全实现</p><ul><li>double-checked locking</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查实例，如果不存在才进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//  再次检查是否存在实例，不存在时才创建实例，避免创建多个实例</span></span><br><span class="line">                    <span class="comment">// volatile 关键字保证了实例化对象的指令不被重排序，避免返回未正确初始化的对象实例</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uniqueInstace;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：通过同步代码块，缩小了同步范围（实例一旦创建便不再需要同步），通过 double-checked 避免了多线程创建多个实例</p><p>缺点：在 jdk5 之前，这种实现方式是错误的，当时的 JVM 对于 volatile 的实现不能保证返回的是正确初始化的对象(jdk5 及之后的版本，volatile 增强了语义，避免了指令重排带来的问题)</p><ul><li>On demand holder idiom</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This code is guaranteed to be correct because of the initialization guarantees</span></span><br><span class="line"><span class="comment">     * for static fields; if a field is set in a static initializer, it it guaranteed</span></span><br><span class="line"><span class="comment">     * to be made visible, correctly, to any thread that accesses that class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过静态字段实例化保证了在实例变量被任何线程访问时返回正确初始化的变量，且静态字段只被初始化一次，满足了线程安全和实例唯一性；又因为静态内部类的加载不需要依附外部类，在使用时才加载，满足了延迟初始化</p><p>总结一下，上述各种单例模式的实现方式说明了<strong>在不同场景和需求下会有不同的设计方案，即使是相同场景下也可能会有不同的设计，而每种设计也存在不同的侧重和取舍</strong>。如果延迟初始化不是我们要考量的问题，推荐使用枚举方式实现单例，否则推荐最后一种实现方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下&lt;/p&gt;
&lt;h2 id=&quot;懒汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式&quot;&gt;&lt;/a&gt;懒汉模式&lt;/h2&gt;&lt;p&gt;因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Other operatons...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 防止通过反射创建多个实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;instance already existed!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://ryan-hou.github.io/2018/11/26/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ryan-hou.github.io/2018/11/26/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-11-26T13:01:39.000Z</published>
    <updated>2020-04-13T10:30:28.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间</p></blockquote><p>举个简单例子，插头与插座，通过电源适配器，可以把插头与本来不相匹配的插座进行适配，这样做的好处显然易见，<strong>既不用重新更换插头，也不用更换插座，只需要使用一个适配器就可以使插头与插座适配工作</strong>，而这也就是适配器模式的设计初衷，通过引入一个中间层，屏蔽底层变动对于上层的影响</p><a id="more"></a><h2 id="为什么需要适配器"><a href="#为什么需要适配器" class="headerlink" title="为什么需要适配器"></a>为什么需要适配器</h2><p>考虑这样的场景，在已有的系统中，希望可以使用不同厂商提供的接口，但是很不幸，这些厂商提供的接口并不完全一致，应该如何处理？</p><p>当然最笨的办法就是，每增加一个厂商，就根据该厂商提供的接口来修改我们的客户端代码，缺点显然易见，客户端代码是面向具体的实现的，耦合性强，违背开闭原则。<strong>通过适配器模式，创建适配器来进行接口转换，让不兼容的接口变的兼容，这样可以让客户端代码从实现中解耦</strong></p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>实际上有两种适配器，类适配器与对象适配器，其中类适配器需要使用多继承实现，在 Java 中没有提供多继承，所以下面主要讲述对象适配器的实现</p><p>对象适配器<strong>使用对象组合</strong>。现在的场景是，厂商提供了接口 A，而我们的客户端代码需要使用接口 B，那么适配器需要做的工作就是把接口 A 转为接口 B，整个实现过程有几个点需要关注：</p><ul><li>适配器要实现接口 B (接口B的所有方法，如果实现不了可以抛出异常)</li><li>把 A 接口的实例对象传入适配器(比如通过构造器的方式)，实现对象的组合</li><li>在适配器中实现 B 接口的方法，实际上是调用 A 接口相应的方法</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>最初 JDK 中提供了枚举器来遍历集合中的元素，如 <code>Vector</code> <code>Hashtable</code> 等都有返回实现 <code>Enumeration</code> 接口的方法，该接口中有 <code>hasMoreElements()</code> 和 <code>nextElement()</code> 方法，而在后期的集合类中使用 <code>Iterator</code> 接口来实现遍历</p><p>面对返回 Enumeration 的遗留代码，我们可以构造一个适配器来完成从 Enumeration 到 Iterator 的转换，从而在客户端代码中统一使用 Iterator 接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationAdapter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Enumeration&lt;E&gt; enumeration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumerationAdapter</span><span class="params">(Enumeration&lt;E&gt; enumeration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enumeration = enumeration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个例子，在 Java 集合类中，Set 接口实现类的内部一般都是直接调用 Map 接口实现类的方法（忽略 Map 接口实现类中的 value 域）。我们可以看到 HashSet 的源码实际上都是在调用 HashMap 的方法，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet 内部通过定义私有成员域 HashMap 来进行适配，把对于 HashSet 的方法调用适配为对 HashMap 方法的调用 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing HashMap instance has default initial</span></span><br><span class="line"><span class="comment"> * capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other operations...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个简单例子，插头与插座，通过电源适配器，可以把插头与本来不相匹配的插座进行适配，这样做的好处显然易见，&lt;strong&gt;既不用重新更换插头，也不用更换插座，只需要使用一个适配器就可以使插头与插座适配工作&lt;/strong&gt;，而这也就是适配器模式的设计初衷，通过引入一个中间层，屏蔽底层变动对于上层的影响&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式及fail-fast策略</title>
    <link href="https://ryan-hou.github.io/2018/11/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8Afail-fast%E7%AD%96%E7%95%A5/"/>
    <id>https://ryan-hou.github.io/2018/11/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8Afail-fast%E7%AD%96%E7%95%A5/</id>
    <published>2018-11-11T12:49:35.000Z</published>
    <updated>2020-04-14T14:06:57.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>迭代器模式提供了一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部数据结构的方式。把遍历的任务放在迭代器上而不是聚合上</p><h2 id="为什么需要迭代器"><a href="#为什么需要迭代器" class="headerlink" title="为什么需要迭代器"></a>为什么需要迭代器</h2><p>思考这样一个问题，客户端中有一个类，需要访问不同的聚合对象，遍历各个聚合对象的所有元素，来进行相应的操作，应该怎么做？</p><p>最简单直接的方式当然是由各个聚合对象来提供遍历的接口，在客户端的类中调用这个接口来实现遍历，这样当然可以，但我们可以思考一下这样做的弊端：</p><a id="more"></a><ul><li>由各个聚合类分别提供迭代接口可能会暴露聚合类内部的数据结构</li><li>客户端的代码需要分别遍历不同的聚合对象(通过多个循环操作实现)，存在代码冗余</li><li>客户端代码是面向具体的实现编程，而不是针对接口，灵活性差</li></ul><p>如何做？这就需要用到迭代器模式来提供统一的抽象，迭代器模式有几个要点：</p><ul><li>在面向对象对象编程中，有一个很重要的思想就是<strong>封装变化</strong>，上面例子中，发生变化的部分很明显是<strong>由不同集合类型的遍历造成的</strong>，所以我们通过迭代器模式对这个遍历操作进行封装</li><li>封装的操作其实很简单，<strong>就是定义一个迭代器接口，然后由不同的聚合类根据自己的数据结构来自定义实现遍历操作，而客户端代码只需要调用一致的迭代器接口即可，也面向接口编程</strong></li><li>把遍历相关的操作单独拿出去，作为一个接口定义，然后由具体的类来实现，符合<strong>单一责任原则</strong>，有利于创建高内聚的类或模块</li></ul><h2 id="JDK-中的实现"><a href="#JDK-中的实现" class="headerlink" title="JDK 中的实现"></a>JDK 中的实现</h2><p>根据上面的思路，我们以 ArrayList 为例来看一下 JDK 中的实现</p><p>在 java.util 包中，定义了 <code>Iterator&lt;E&gt;</code> 接口，接口中定义了遍历相关的操作，主要是: <code>boolean hasNext(); E next(); void remove();</code></p><p>在 ArrayList 类的内部，提供一个私有内部类 <code>Itr</code> 来实现了上面的迭代器接口，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor; <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面迭代器的实现，实现了 <code>fail-fast</code> 的机制，以保证在多线程并发访问时尽最大可能抛出 <code>ConcurrentModificationException</code> 异常，下面会具体谈到</p><h2 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for-each 循环"></a>for-each 循环</h2><p>借助 Iterable 接口和迭代器 Iterator，可以使用 for-each 语法糖。JDK 1.5 提供的 for-each 循环，通过隐藏迭代器或者索引变量(编译器语法糖)，避免了混乱和出错的可能性，for-each 循环不仅可以让你遍历数组和集合，还可以让你遍历任何实现了 Iterable 接口的对象。在遍历元素时，<strong>for-each循环优于传统的循环</strong> （但是需要注意参与遍历的聚合对象不能为 null，否则会 NPE）</p><h2 id="关于迭代器的-fail-fast"><a href="#关于迭代器的-fail-fast" class="headerlink" title="关于迭代器的 fail-fast"></a>关于迭代器的 fail-fast</h2><p>在迭代器创建之后，如果从<strong>结构</strong>上对其进行修改(比如删除或者增加新的元素)，除非通过<strong>迭代器本身</strong>的 <code>remove</code> 方法，其他任何方式的修改，迭代器都将尽可能抛出 <code>ConcurrentModificationException</code>。这一现象，我们称作<code>fail-fast</code></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 该操作会产生 ConcurrentModfication 异常，应该使用迭代器 iterator 自身的 remove 方法来进行操作</span></span><br><span class="line">        list.remove(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现方式可以参见 JDK 源码，主要是通过 <code>modCout</code> 和 <code>expectedModCount</code> 变量值的比对来实现</p><h2 id="为什么要-fail-fast"><a href="#为什么要-fail-fast" class="headerlink" title="为什么要 fail-fast"></a>为什么要 fail-fast</h2><p>从抛出异常 <code>ConcurrentModificationException</code> 的名字我们也可以猜到，这是为了防止多线程并发操作带来的问题而设计的，<code>modCount</code> 变量是可变共享的，我们用迭代器来迭代数据，应该保证迭代器遍历的聚合对象处于单线程操作，否则在我们迭代数据时，其他线程对于该集合结构的修改会导致当前线程出现不可预知的异常，比如<code>ArrayIndexOutOfBoundsException</code> </p><p>需要注意迭代器的 fail-fast 行为不能得到保证，也就是说迭代器只会尽最大努力抛出 ConcurrentModificationException。因此，在 JDK 源码注释中也写到，编写依赖于此异常的程序是错误的，正确做法是迭代器的 fail-fast 行为应该仅用于检测程序可能出现的错误</p><p><strong>最后，fail-fast 并不仅仅用于迭代器，它本身也是一个非常重要的设计原则，尤其是在处理在线业务时，比如当业务量突然增大，导致大量任务堆积或者阻塞时，如果没有 fail-fast，那么可能会导致整个在线系统崩溃。因此在设计系统或者接口时，fail-fast 也是一个需要重要考虑的点</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;p&gt;迭代器模式提供了一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部数据结构的方式。把遍历的任务放在迭代器上而不是聚合上&lt;/p&gt;
&lt;h2 id=&quot;为什么需要迭代器&quot;&gt;&lt;a href=&quot;#为什么需要迭代器&quot; class=&quot;headerlink&quot; title=&quot;为什么需要迭代器&quot;&gt;&lt;/a&gt;为什么需要迭代器&lt;/h2&gt;&lt;p&gt;思考这样一个问题，客户端中有一个类，需要访问不同的聚合对象，遍历各个聚合对象的所有元素，来进行相应的操作，应该怎么做？&lt;/p&gt;
&lt;p&gt;最简单直接的方式当然是由各个聚合对象来提供遍历的接口，在客户端的类中调用这个接口来实现遍历，这样当然可以，但我们可以思考一下这样做的弊端：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Checked&amp;Unchecked Exception</title>
    <link href="https://ryan-hou.github.io/2018/10/07/Checked-Unchecked-Exception/"/>
    <id>https://ryan-hou.github.io/2018/10/07/Checked-Unchecked-Exception/</id>
    <published>2018-10-07T12:12:50.000Z</published>
    <updated>2020-04-16T03:48:59.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Is-checked-exception-necessary"><a href="#Is-checked-exception-necessary" class="headerlink" title="Is checked exception necessary?"></a>Is checked exception necessary?</h2><p>很多言论认为 Java 受检异常(checked exception，也就是那些你需要明确的捕获或者 rethrow 的异常)的存在是没有必要的，例如在 C# 语言中就取消了受检异常，而且大部分的语言都没有受检异常这一概念，无论何时直接声明异常为 RuntimeException 或其子类(即 unchecked exception)会更加方便，事实是如此吗？</p><a id="more"></a><h2 id="Oracle-的官方声明"><a href="#Oracle-的官方声明" class="headerlink" title="Oracle 的官方声明"></a>Oracle 的官方声明</h2><p>关于这个争议，Oracle 在官方文档中作出过解释，下面是一些重要观点的翻译：</p><p>因为 Java 语言不强制要求方法捕获或处理非受检异常(RuntionException, Error 及其子类)，所以程序员会倾向于让自己的异常类继承 RuntimeException，从而只抛出非受检的异常。这种“捷径”使程序员的代码不受编译器编译错误的影响，也不用费心去捕获或处理任何异常。这种方式看似非常便捷，但是破坏了 <code>catch</code> 和 <code>specity</code> 的设计目的，对其他程序员操作自己的方法也埋下了隐患</p><p>为什么设计者会要求去处理方法中抛出的所有受检异常呢？因为任何可以被方法抛出的异常都是该方法的公共编程接口。<strong>其他调用该方法的用户必须知道当前方法可能抛出的异常，以便于作出合理的处理。这些异常和方法中的参数列表及返回值一样，都是方法接口的一部分。</strong>那么接下来一个问题就是，“如果把方法 API 文档化(包括该方法的异常)有这么多好处，那为什么不对 runtime exception 也做这种特殊的处理呢？” 那是因为<strong>运行时异常是程序代码错误导致的，因此调用 API 的用户不应该也不知道如何恢复或处理这类异常</strong>。导致运行时异常的问题有算术异常，比如除数为0；空指针异常；数组下标越界异常等等，这类异常可以发生在程序代码中的任何地方，因而数量也是很多的，如果把这类异常加到方法声明中，会降级程序的可读性。因此编译器不会强制要求捕获或处理非受检异常(当然你可以处理，但是大多数情况下没有必要)</p><p>总的来说，不能仅仅因为你不想处理方法抛出的异常就粗暴的使用 RuntimeException 或他的子类</p><h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><p>如果方法的调用者可以合理的处理或者恢复这个异常，那么该异常应该被声明为受检的异常；如果方法的调用者不需要关心或者无法做出合理的处理，那么就声明该异常为非受检的异常。Never swallow the Exception！</p><h2 id="实践中的问题"><a href="#实践中的问题" class="headerlink" title="实践中的问题"></a>实践中的问题</h2><p>在实际编程中，尤其是一些框架(比如 iBatis )和类库，通常会把抛出 RuntimeException 作为习惯用法，这是出于对向后兼容性和设计库函数的难度(在设计一个公用组件时，很难把所有可能出现的异常都考虑清楚)的折衷，但是我们在写一些特定的业务代码时，个人还是建议，根据这个异常是否需要被处理或者能不能被用户处理，把异常声明为受检异常或者非受检异常，而不是直接无脑的抛出 RuntimeException。<strong>正确的使用异常对于程序的正确性和健壮性至关重要，无论何时都要仔细思考程序的边界和可能出现的所有情况，尤其是在分布式环境下，异常的处理往往比正常情况的处理逻辑更加复杂，也更加考验一个程序员思考问题的严谨性。</strong></p><p>关于受检异常和非受检异常，要在合适的情况下进行判断和选用，不能偏废，关于这方面的讨论，推荐两篇阅读文章:</p><ul><li><a href="http://www.yinwang.org/blog-cn/2017/05/23/kotlin" target="_blank" rel="noopener">Kotlin 和 Checked Exception</a></li><li><a href="https://zhuanlan.zhihu.com/p/33731510" target="_blank" rel="noopener">有人知道Java异常声明的正确用法吗？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Is-checked-exception-necessary&quot;&gt;&lt;a href=&quot;#Is-checked-exception-necessary&quot; class=&quot;headerlink&quot; title=&quot;Is checked exception necessary?&quot;&gt;&lt;/a&gt;Is checked exception necessary?&lt;/h2&gt;&lt;p&gt;很多言论认为 Java 受检异常(checked exception，也就是那些你需要明确的捕获或者 rethrow 的异常)的存在是没有必要的，例如在 C# 语言中就取消了受检异常，而且大部分的语言都没有受检异常这一概念，无论何时直接声明异常为 RuntimeException 或其子类(即 unchecked exception)会更加方便，事实是如此吗？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型与通配符</title>
    <link href="https://ryan-hou.github.io/2018/10/04/Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>https://ryan-hou.github.io/2018/10/04/Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/</id>
    <published>2018-10-04T13:34:50.000Z</published>
    <updated>2020-04-14T07:56:32.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从一个问题说起"><a href="#从一个问题说起" class="headerlink" title="从一个问题说起"></a>从一个问题说起</h2><p>String 类是 Object 类的 subtype，但是 <code>List&lt;String&gt;</code> 却不是  <code>List&lt;Object&gt;</code>的 subtype，为什么？</p><p>最核心的原因在于<strong>不满足里氏替换原则(LSP)</strong>，这就引出了里氏替换原则的定义，简单来说，A 是 B 的子类型当且仅当一个有效的使用了 B 类型的程序，把其中所有的 B 类型换成 A 类型，程序的有效性依然存在，那么类型 A 就是类型 B 的子类型 (<strong>里式替换原则要求所有使用 supertype 的地方都可以透明的使用其 subtype</strong>)</p><a id="more"></a><p>根据里氏替换原则，下面这个有效(可以正确编译)的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doThing</span><span class="params">(List&lt;Object&gt; x)</span> </span>&#123;</span><br><span class="line">    x.add(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>List&lt;Object&gt;</code> 可以正确的被替换为 <code>List&lt;String&gt;</code>,那么 <code>List&lt;String&gt;</code> 就是 <code>List&lt;Object&gt;</code> 的子类型，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doThing</span><span class="params">(List&lt;String&gt; y)</span> </span>&#123;</span><br><span class="line">    y.add(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然上面的代码不能编译通过，也就是说 <code>List&lt;String&gt;</code> 不是 <code>List&lt;Object&gt;</code> 的子类型，那么问题来了，各种参数化类型集合的超类是谁呢？答案是 <code>Collection&lt;?&gt;</code> 念做 <strong>collection of unknow</strong> 其中 <code>?</code> 是一个泛型通配符，可以匹配任何类型，下面展开介绍</p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p><strong>注：任何关于Java语言的概念，最权威的参考一定是 JLS，这里给出链接 <a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html" target="_blank" rel="noopener">Wildcards</a>，下面的内容会参考 JLS 来做说明。</strong></p><p>由上面我们知道了，各种参数化类型集合的超类是 <code>Collection&lt;?&gt;</code>，<strong>?</strong> 就是我们说的通配符，有了这个超类，我们就可以构造一个方法来接收任何参数实例化的 Collection 了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中我们读取集合中的每一个元素时都转为 Object，这样做总是安全的，因为 Object 是任何一个元素类型的超类。但是像下面这样就是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">c.add(<span class="string">"test"</span>); <span class="comment">// Compiler error</span></span><br></pre></td></tr></table></figure><p>因为当类型参数是 <strong>?</strong> 时，代表这是一个未知的类型，所以我们不能向其传入任何类型的参数，只有一个例外，那就是 <code>null</code> (所用引用类型变量的默认值)，后面在说 <strong>&lt;? extends T&gt; vs &lt;? super T&gt;</strong> 时会再谈到</p><h2 id="受限的类型参数"><a href="#受限的类型参数" class="headerlink" title="受限的类型参数"></a>受限的类型参数</h2><p>在实际使用中，我们可能需要限制泛型的类型参数，比如，一个方法接收数字类型的参数，那么就可以把泛型的类型参数限定为 Number 类型或者他的子类型，使用的语法是：<strong>列出该参数的名字，然后跟上 extends 关键字，再跟上 upper bound</strong>，比如： <code>List&lt;T extends Number&gt;</code></p><p><strong>注意，在上面的上下文语境中，extends 既代表类中的 extends，也代表接口中的 implements</strong></p><p>一个类型参数可以同时存在有多个上界，比如：<code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code>, 该类型参数就是 B1，B2 和 B3 的子类型，B1，B2，B3 中只能存在一个 class，且该 class 必须放在第一个位置上</p><p>这里 <code>&amp;</code> 还可以用于返回值中，也只能存在一个 class，比如：<br><code>return (Comparator&lt;T&gt; &amp; Serializable) a</code> 表示 a 被转型为 Comparator <strong>and</strong> Serializable (也就是一个可序列化的比较器)</p><h2 id="lt-T-extends-Comparable-lt-super-T-gt-gt-怎么理解"><a href="#lt-T-extends-Comparable-lt-super-T-gt-gt-怎么理解" class="headerlink" title="&lt;T extends Comparable&lt;? super T&gt;&gt;怎么理解"></a><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code>怎么理解</h2><p>在 <code>Collections.sort</code> 的 javadoc 中我们可以看到这样的签名：<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>，我们可能会有这样的疑问，为什么不写成<code>&lt;T implements Comparable&lt;T&gt;&gt;</code>?</p><p>首先在上面受限的泛型参数中说到 extends 既可以表示 extends 也可以表示 implements；其次，javadoc 中的方法签名表示 T 能够实现 <code>Comparable&lt;? super T&gt;</code> 而不仅仅是 <code>Comparable&lt;T&gt;</code>。举个例子，一个 Student 类可以实现 <code>Comparable&lt;Person&gt;</code>，其中 Student 是 Person 的子类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Other operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person that)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，一个 <code>List&lt;Student&gt;</code> 可以被 Collections.sort() 方法进行排序，但是<strong>只能根据 Person 类的属性</strong>，因为把 Student 实例传入 compareTo 方法中是按照超类型 Person 来处理的(除非你自己 downcast)</p><p>在实际使用中，我们不会用 Student 类来实现 <code>Comparable&lt;Person&gt;</code>，因为 Person 类很可能已经实现了 <code>Comparable&lt;Person&gt;</code> 接口，Student 类会继承该实现，但结果是一样的，你可以把 <code>List&lt;Student&gt;</code> 传给 Collections.sort() 调用，但还是根据 Person 的属性来排序</p><h2 id="lt-extends-T-gt-VS-lt-super-T-gt"><a href="#lt-extends-T-gt-VS-lt-super-T-gt" class="headerlink" title="&lt;? extends T&gt; VS &lt;? super T&gt;"></a>&lt;? extends T&gt; VS &lt;? super T&gt;</h2><p>解释这种用法的最佳例子就是 <code>Collections.copy()</code> 方法:<br><code>public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></p><p>注意到在这个方法签名中，src list 声明为 extends，允许我传入相关的 List 类型的 family，保证会产生类型 T 或者他的子类型，但是不能向 src list 中添加新的元素，因为我们无法确定元素的类型</p><p>dest list 声明为 super, 允许我们传入相关的 List 类型的  family(类型 T 或者其超类)，保证我可以写入一个 T 类型元素到该 list 中。但是不能保证从该 list 中读出的元素是 T 类型的元素</p><p>使用上面的泛型通配符，我们可以用一个方法签名，满足下面不同方法的调用，大大增强了算法的普适性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy(dest, src)</span></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Number&gt;(), <span class="keyword">new</span> ArrayList&lt;Number&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Number&gt;(), <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Object&gt;(), <span class="keyword">new</span> ArrayList&lt;Number&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Object&gt;(), <span class="keyword">new</span> ArrayList&lt;Double&gt;());</span><br></pre></td></tr></table></figure><p>总结来说就是：<strong>PECS（Producer Extends, Consumer Super）</strong>。其中 Producer 和 Consumer 都是相对集合对象自身来说的</p><ul><li>Producer Extends: 如果你需要一个 List 来产生 T 类型的值(也就是说你想从 List 中读取 T 类型的值)，你需要使用 <code>? extends T</code>，即<code>List&lt;? extends T&gt;</code>。但是你不能往该 list 中添加元素</li><li>Consumer Super: 如果你需要一个 List 来消费 T 类型的值(也就是说你想把 T 类型的值写入到 list 中)，你需要使用 <code>？ super T</code>，即 <code>List&lt;? super T&gt;</code>。但是不能保证你从 list 中读取的值的类型是 T</li><li>如果你需要同时从 list 中进行读和写，那么就不要使用通配符，即 <code>List&lt;T&gt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从一个问题说起&quot;&gt;&lt;a href=&quot;#从一个问题说起&quot; class=&quot;headerlink&quot; title=&quot;从一个问题说起&quot;&gt;&lt;/a&gt;从一个问题说起&lt;/h2&gt;&lt;p&gt;String 类是 Object 类的 subtype，但是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 却不是  &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;的 subtype，为什么？&lt;/p&gt;
&lt;p&gt;最核心的原因在于&lt;strong&gt;不满足里氏替换原则(LSP)&lt;/strong&gt;，这就引出了里氏替换原则的定义，简单来说，A 是 B 的子类型当且仅当一个有效的使用了 B 类型的程序，把其中所有的 B 类型换成 A 类型，程序的有效性依然存在，那么类型 A 就是类型 B 的子类型 (&lt;strong&gt;里式替换原则要求所有使用 supertype 的地方都可以透明的使用其 subtype&lt;/strong&gt;)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简谈Java泛型</title>
    <link href="https://ryan-hou.github.io/2018/10/01/%E7%AE%80%E8%B0%88Java%E6%B3%9B%E5%9E%8B/"/>
    <id>https://ryan-hou.github.io/2018/10/01/%E7%AE%80%E8%B0%88Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2018-10-01T13:09:25.000Z</published>
    <updated>2020-04-14T06:28:35.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关术语和入门使用"><a href="#相关术语和入门使用" class="headerlink" title="相关术语和入门使用"></a>相关术语和入门使用</h2><p><strong>关于泛型的几个术语</strong></p><ul><li>ArrayList<e> 中的 <code>&lt;&gt;</code> 念作 <code>typeof</code>，E 称为类型参数变量</e></li><li><code>ArrayList&lt;Integer&gt;</code> 中的 Integer 称为实际类型参数</li><li>整个 <code>ArrayList&lt;E&gt;</code> 称为泛型类型；整个 <code>ArrayList&lt;Integer&gt;</code> 称为参数化的类型</li></ul><p>关于泛型几个需要注意的点: (由于 Java 的泛型采用类型擦除来现实，存在相关问题，后面会继续讨论)</p><a id="more"></a><ul><li>泛型的类型参数必须是引用数据类型</li><li>泛型类型实例化时，两边的实际类型参数必须完全一致，或者一边带实际类型参数，一边不带(&lt;&gt;: the diamond)</li><li>Java 泛型是编译器提供的语法糖，可用于<strong>限定集合的输入类型；让编译器在源码级别上即可防止非法数据的插入</strong>，但是编译生成 class 文件后，将不再存在泛型信息，这个过程叫做<strong>擦除</strong>(在类的元数据中通过反射还可以取到泛型信息，所以我们可以通过反射来绕过泛型)　</li><li>泛型在编译阶段保证了类型安全，在后续使用中也避免了强制类型转换，但牺牲了一定的代码简洁性</li></ul><p><strong>定义泛型方法和泛型类</strong></p><p>使用场景：需要传入或返回一个<strong>暂时未知</strong>的类型，而 Java 中遵循<strong>先定义再使用</strong>，可以通过泛型来解决这个问题</p><p>使用泛型方法可以接收不同类型的参数，返回值不需要强转</p><ul><li>泛型方法</li></ul><p>Java 程序中，普通方法，构造方法和静态方法都可以使用泛型。方法使用泛型前，必须对泛型进行声明，语法为：<code>&lt;T&gt;</code>，T 可以是任意字母，但通常大写，<code>&lt;T&gt;</code> 通常需要放在方法的返回类型之前，如：<code>public &lt;T&gt; T test(T t) { return t; }</code>，这样在调用该方法时，比如 <code>test(&quot;aaa&quot;)</code>，返回值的类型就是 <code>String</code>，不需要强转</p><ul><li>泛型类</li></ul><p>如果在一个类中多次用到同一个泛型参数，就可以把该参数提取到类的定义上来，使用泛型类，比如 JDK 中的 Map 接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A map entry(key-value pair).</span></span><br><span class="line"><span class="comment">     * The Map.entrySet method returns a collection-view</span></span><br><span class="line"><span class="comment">     * of the map, whose elements are of this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举个实际使用的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"first"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"second"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// Use Integer instead of int to avoid NPE</span></span><br><span class="line">    Integer key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要引入泛型"><a href="#为什么要引入泛型" class="headerlink" title="为什么要引入泛型"></a>为什么要引入泛型</h2><p>主要有两方面原因：</p><ul><li>在编译期进行类型检查，比如 <code>ArrayList&lt;Integer&gt;</code> 只能插入 Integer 类型的数据，同时在使用时可以省去强制类型的转换的麻烦（<strong>Stronger type checks at compile time.</strong>）</li><li>更重要的是提供了对于泛型范式的支持，对于一个方法，我们可以抽象出方法的算法骨架，通过泛型的支持，使同一个算法应用到不同的数据类型，增强了方法的普适性，举个例子：</li></ul><p>reverse 数组中的元素(数组的元素可以是字符串类型，Integer 类型等，算法思路：定义首尾两个指针，然后同时移动)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个泛型方法，接收任意类型数组，并颠倒数组中的所有元素</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"arr is null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        T tmp = arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-泛型的问题"><a href="#Java-泛型的问题" class="headerlink" title="Java 泛型的问题"></a>Java 泛型的问题</h2><p>Java 泛型是在 JDK5 中新增的语言特性，为了兼容之前的类库，采用了类型擦除的实现方式(个人觉得这样实现改动最小也是很重要的一个原因，在泛型之前，通过使用共同父类 Object 来实现的容器类运行良好，采用泛型擦除只需要编译器提供自动转换和类型检查的语法糖即可，runtime 不用改动)，这也导致外界对 Java 的泛型实现一直存在批判</p><p>因为采用类型擦除的实现方式，那么一个类的类型参数 E 的实际类型在运行期是被擦除的(全部为 Object 类型，这也是为什么泛型类型参数必须是引用数据类型)，这对于Java 泛型的使用带来了一定的制约，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123;</span><br><span class="line">            <span class="comment">// Compiler error</span></span><br><span class="line">            <span class="comment">// The type used with instanceof has to be reifiable, </span></span><br><span class="line">            <span class="comment">// which means that all information about the type has to be available at runtime</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compiler error</span></span><br><span class="line">        <span class="comment">// You can't create an instance of a type parameter</span></span><br><span class="line">        E item2 = <span class="keyword">new</span> E(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类也不能继承 Throwable 类，因为 catch 语句在运行时无法确定该执行哪个，例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compiler error ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GenericException&lt;Integer&gt;();</span><br><span class="line">&#125; <span class="keyword">catch</span> (GenericException&lt;Integer&gt; e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (GenericException&lt;String&gt; e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型参数也不能用于类中的静态变量，因为泛型类的类型参数可能会对应不同的实际类型参数，而静态变量是一个类的所有实例共享的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Compiler error</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建参数化类型的数组也是非法的：<code>List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</code></p><p>类型擦除会影响方法重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// Compiler error</span></span><br><span class="line">    <span class="comment">// The overloads would all share the same classfile representation and will generate a compile-time error.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多具体内容参见 Oracle 官方文档: <a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html" target="_blank" rel="noopener">Restrictions on Generics</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;相关术语和入门使用&quot;&gt;&lt;a href=&quot;#相关术语和入门使用&quot; class=&quot;headerlink&quot; title=&quot;相关术语和入门使用&quot;&gt;&lt;/a&gt;相关术语和入门使用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关于泛型的几个术语&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList&lt;e&gt; 中的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 念作 &lt;code&gt;typeof&lt;/code&gt;，E 称为类型参数变量&lt;/e&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt; 中的 Integer 称为实际类型参数&lt;/li&gt;
&lt;li&gt;整个 &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 称为泛型类型；整个 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt; 称为参数化的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于泛型几个需要注意的点: (由于 Java 的泛型采用类型擦除来现实，存在相关问题，后面会继续讨论)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射概述</title>
    <link href="https://ryan-hou.github.io/2018/09/22/Java%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://ryan-hou.github.io/2018/09/22/Java%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0/</id>
    <published>2018-09-21T16:18:00.000Z</published>
    <updated>2020-04-20T10:08:42.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>反射作为 Java 语言的一大特性，在底层框架实现中应用广泛，从字面上来理解，反射就类似于照镜子，是一个类自己在“照镜子”。在 Java 中我们提供了 <code>Class</code> 类及相关的类如 <code>Field</code>，<code>Method</code> 等来实现反射，<strong>Class 类封装了当前对象对应的类的信息，也就是 Class 类是描述我们定义的类的类。相当于在我们自己定义的类上又抽象了一层。</strong>对于每个类而言，JVM 中最多都只有一个不变的 Class 类型的对象来标示该类</p><p>Reflection VS Introspection</p><blockquote><p>The ability to inspect the code in the system and see object types is not reflection, but rather Type Introspection. Reflection is then the ability to make modifications at runtime by making use of introspection. </p></blockquote><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><a id="more"></a><h3 id="创建-Class-类对象"><a href="#创建-Class-类对象" class="headerlink" title="创建 Class 类对象"></a>创建 Class 类对象</h3><p>Class 对象只能由 JVM 在类加载时创建，一个类在 JVM 中最多只有一个对应的 Class 实例</p><h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>我们有三种方式获取 Class 对象</p><ul><li>通过类的 class 属性获取，该方法最安全可靠，性能更高： <code>Class&lt;String&gt; clazz = String.class;</code></li><li>通过对象的<strong>getClass() 方法</strong>获取：<code>Class&lt;String&gt; clazz = &quot;hello&quot;.getClass();</code></li><li>通过 Class 的<strong>static forName()方法</strong>获取，但可能抛出 <strong>ClassNotFoundException 异常</strong>(这个方法常在框架中使用，比如使用 JDBC 时获取数据库驱动类的 Class 类对象)：<code>Class&lt;?&gt; contextClass = Class.forName(&quot;org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;);</code></li></ul><h3 id="实例化-Class-对象对应的类的对象"><a href="#实例化-Class-对象对应的类的对象" class="headerlink" title="实例化 Class 对象对应的类的对象"></a>实例化 Class 对象对应的类的对象</h3><p>获取了 Class 对象，就可以实例化对应的类对象了，可以通过 Class 对象的<strong>newInstance()方法</strong>来创建类的一个实例:<code>Object obj = clazz.newInstance()</code>，实际上调用的是类的无参构造器（如果想要通过该方式实例化一个对象，需要保证类的无参构造器存在）</p><h3 id="Class-类对象可以做什么"><a href="#Class-类对象可以做什么" class="headerlink" title="Class 类对象可以做什么"></a>Class 类对象可以做什么</h3><p>既然 Class 是对类的描述，那么 Class对象就应该可以使用该类的属性(Filed)，该类的方法(Method)，该类的构造器(Constructor)。我们都知道 Java 是面向对象的语言，这种OO 思想在这里也得以体现：一个成员方法就是一个<strong>Method对象</strong>，一个成员变量就是一个<strong>Field对象</strong>，在 Java 中提供了相应的 <code>Method类</code> 和 <code>Field类</code>等，还有具体的 API 方法，举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"coim.javase.Person"</span>);</span><br><span class="line"><span class="comment">// 获取 Class 对象声明的所有方法，包括 private 方法，但是不包括继承的方法</span></span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">Method method = clazz.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若通过反射执行私有方法权限不够，先使该方法变为可被访问的</span></span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">Field[] fiedls = clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">// 获取指定名字的 Field</span></span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the Class representing the superclass of the entity (class, interface, primitive type or void) represented by this Class</span></span><br><span class="line">Class&lt;?&gt; parentClazz = clazz.getSuperclass();</span><br></pre></td></tr></table></figure><p>通过上面那些方法可以得到一堆好东西，包括方法啊，字段啊，构造器啊等，接下来就可以按需应用了，Method 类有一个方法很重要，单独提一下: <code>public Object invoke(Object obj, Object ... args)</code>，我们可以通过 Method 对象的此方法来执行对象相应的方法。在调用这个方法的前后，我们可以加些自定义的操作，比如打印日志，开启事务等，这就可以用来实现 AOP</p><h3 id="反射与动态加载"><a href="#反射与动态加载" class="headerlink" title="反射与动态加载"></a>反射与动态加载</h3><p>使用<strong>关键字new</strong>创建对象时，需要在编译期就知道要使用到的具体的类，这会影响程序的灵活性。使用反射我们可以在运行期动态加载需要的类，即 <code>Class&lt;?&gt; c = Class.forName(args[0]);</code>这里还可以再扩展一下，在通过 c 实例化具体的对象时（T newInstance()），我们需要做强制类型转换，可是转换成谁呢？我们应该马上想到定义一个抽象接口，然后用不同的类来具体实现，以实现动态绑定。使用这种面向接口编程的方式，可以提供更好的灵活性和稳定性</p><h2 id="反射与泛型"><a href="#反射与泛型" class="headerlink" title="反射与泛型"></a>反射与泛型</h2><p>Java 泛型是编译器实现的语法糖，在运行期泛型信息会被擦除，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">"hello"</span>);</span><br><span class="line">list1.add(<span class="number">20</span>); <span class="comment">// 编译报错，泛型提供了类型安全检查</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c = list.getClass();</span><br><span class="line">Class&lt;?&gt; c1 = list1.getClass();</span><br><span class="line"><span class="keyword">boolean</span> b = (c == c1); <span class="comment">// 这里 b 的值为 true</span></span><br></pre></td></tr></table></figure><p>布尔值 b 为 ture 这件事告诉我们<strong>编译之后集合的泛型信息被擦除了</strong>，这句话非常有价值，有了这个基础我们就可以在上面例子中加入我们想要加入的整数而不出现错误，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射绕过泛型限制</span></span><br><span class="line">Method m = c1.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">m.invoke(list1, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>我们有时还需要获取泛型的实际类型参数，下面介绍一下通过反射获得实际类型参数的方法:（这里需要用到 Type 接口和ParameterizedType 接口，具体内容可以查看相应的接口文档）</p><p>例：<code>public EmployeeDao extends BaseDao&lt;Employee, String&gt;</code>，下面方法中，clazz 为子类对应的 Class对象，index 为子类继承父类时传入的泛型参数索引，从 0 开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父类指定索引的实际类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getSuperClassGenericType(Class&lt;?&gt; clazz, <span class="keyword">int</span> index) &#123;</span><br><span class="line">    Type t = clazz.getGenericSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type[] types = ((ParameterizedType) t).getActualTypeArguments();</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= param.length || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal index param."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Class)types[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射与注解"><a href="#反射与注解" class="headerlink" title="反射与注解"></a>反射与注解</h2><p>反射经常搭配注解一起使用，注解信息可以在运行时通过反射获取，然后根据获取的注解执行相应的逻辑。通过使用 Annotation 我们可以在不改变原有逻辑的情况下，在代码中嵌入一些补充信息和逻辑，举例说明比较直观：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 Annotation</span></span><br><span class="line"><span class="meta">@Rentetion</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = &#123; ElementType.METHOD &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AgeValidator &#123;</span><br><span class="line">    <span class="comment">// 注解和接口类似，内部可以定义常量和方法</span></span><br><span class="line">    <span class="comment">// 注解定义的方法有一些限制：方法不能有参数；返回值只能是基本类型、字符串、Class、枚举、注解、及以上类型的数组；可以包含默认值</span></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_MIN = <span class="number">18</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> DEFAULT_MIN</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@AgeValidator</span>(max = <span class="number">30</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取注解信息，进行相应的处理</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">Method method = clazz.getDeclaredMdthod(<span class="string">"setAge"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Annotation an = method.getAnnotation(AgeValidator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (an != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AgeValidator av = (AgeValidator) an;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; av.min() || val &gt; av.max()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid age"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">method.invoke(obj, val);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>上述代码就是通过反射和注解来进行元编程的一个简单实现，当然这里只是抛砖引玉，像这样的使用你可以在框架中(比如 SpringBoot 中等)发现很多，我们在使用框架时也要多考虑一下底层实现，只有这样才不会对层出不穷的新框架感到害怕</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;反射作为 Java 语言的一大特性，在底层框架实现中应用广泛，从字面上来理解，反射就类似于照镜子，是一个类自己在“照镜子”。在 Java 中我们提供了 &lt;code&gt;Class&lt;/code&gt; 类及相关的类如 &lt;code&gt;Field&lt;/code&gt;，&lt;code&gt;Method&lt;/code&gt; 等来实现反射，&lt;strong&gt;Class 类封装了当前对象对应的类的信息，也就是 Class 类是描述我们定义的类的类。相当于在我们自己定义的类上又抽象了一层。&lt;/strong&gt;对于每个类而言，JVM 中最多都只有一个不变的 Class 类型的对象来标示该类&lt;/p&gt;
&lt;p&gt;Reflection VS Introspection&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The ability to inspect the code in the system and see object types is not reflection, but rather Type Introspection. Reflection is then the ability to make modifications at runtime by making use of introspection. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;怎么用&quot;&gt;&lt;a href=&quot;#怎么用&quot; class=&quot;headerlink&quot; title=&quot;怎么用&quot;&gt;&lt;/a&gt;怎么用&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java嵌套类的使用</title>
    <link href="https://ryan-hou.github.io/2018/09/13/Java%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://ryan-hou.github.io/2018/09/13/Java%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-09-13T12:21:47.000Z</published>
    <updated>2020-04-15T03:27:10.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>嵌套类是指被定义在另一个类内部的类，嵌套类存在的目的应该只是为了他的外围类(enclosing class)提供服务，如果将来还会出现在其他的环境中，他就该是顶层类(top-level class)。嵌套类有四种，静态成员类(static member class)，成员类(member class)，匿名类和局部类，除了第一种，其他三种都是内部类</p><h2 id="不同嵌套类的使用"><a href="#不同嵌套类的使用" class="headerlink" title="不同嵌套类的使用"></a>不同嵌套类的使用</h2><p>下面部分内容和示例来自 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html" target="_blank" rel="noopener">Oracle官方文档</a></p><a id="more"></a><h3 id="静态成员类"><a href="#静态成员类" class="headerlink" title="静态成员类"></a>静态成员类</h3><p>最简单的一种嵌套类，<strong>当需要使用嵌套类时，优先考虑使用静态成员类</strong>。可以把静态成员类看作一个普通类，只是恰好被声明在另一个类内部而已，静态成员类是外围类的静态成员，与其它静态成员一样，遵守同样的访问性规则(只能访问外部类的静态成员和静态方法)</p><p>公有静态成员类：常用作公有的辅助类，仅当他与外围类一起使用时才有意义。比如考虑一个枚举，他描述了计算器支持的运算，Operation 枚举应该是 Calculator 类的公有静态成员，然后，Calculator 类的客户端就可以用诸如 Calculator.Opeartion.PLUS 这样的名称来引用这些操作</p><p>私有静态成员类：常用来代表外围类所代表的对象的组件。例如 Map 中的 Entry，虽然每个 entry 都与一个 Map 关联，但是 entry 上的方法（getKey, getValue）并不需要访问该 Map，使用非静态成员类也可以，但是每个 entry 将会包含一个指向该 Map 的引用，浪费了时间和空间，最好是使用私有的静态成员类</p><p>如果嵌套类的实例可以在外围类的实例之外独立存在，这个嵌套类就必须是静态成员类，在没有外围类的实例下，要创建成员类的实例是不可能的。创建公有静态成员类对象的方法为 <code>OuterClass.InnerClass inner = new OuterClass.InnerClass()</code>，举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员类，生成的类名为: StaticInnerClass$InnerClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态成员类可以声明静态成员，而其他嵌套类不可以（static final 除外）</span></span><br><span class="line">        <span class="comment">// you are required to define all static members within a top-level or static member class or interface</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 静态成员类只能访问外围类的静态成员</span></span><br><span class="line">            System.out.println(test);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员类"><a href="#成员类" class="headerlink" title="成员类"></a>成员类</h3><p>成员类可以访问外部类的静态和非静态成员变量和方法；生成公有成员类对象的方法：<code>OuterClass.InnerClass inner = new OuterClass().new InnerClass()</code></p><p>成员类的常见用法是定义一个 Adapter，它允许外部类的实例被看做另一个不相关类的实例。例如 Map 接口的实现往往使用成员类来实现集合视图（由 Map 的 keySet，entrySet 方法返回），Set 和 List 中也使用成员类来实现它们的迭代器，如 ArrayList 类部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h3><p>定义在 <code>block(a group of zero or more statements between balanced braces)</code> 作用域的类；常见的情形是在一个方法体中出现的类，因此局部内部类不能用 <code>public, private, protected, static</code>修饰，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 创建局部类，对外部完全不可见，更安全</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 局部内部类只能访问 final(or effectively final) 类型的局部变量。原因与局部变量和局部类对象的生命周期有关</span></span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end InnerClass</span></span><br><span class="line">        <span class="comment">// 只能在相应的 block 中创建</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass().execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>匿名类可以继承某个类，也可以实现某个接口；<strong>匿名类可以在声明的同时实例化一个对象，很像局部类，只不过匿名类没有名字</strong>，所以当你使用局部类而且仅使用一次时，不妨考虑使用匿名类。匿名类最好代码简洁，保证可读性。如果只是想实现匿名函数，推荐使用 lambda 表达式替代匿名类</p><p>下面的例子中使用了局部类实例化的变量 englishGreeting 和 匿名类实例化的变量 frenchGreeting</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAnonymousClasses</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EnglishGreeting</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用局部类对象</span></span><br><span class="line">        HelloWorld englishGreeting = <span class="keyword">new</span> EnglishGreeting();</span><br><span class="line">        <span class="comment">// 使用匿名类对象</span></span><br><span class="line">        HelloWorld frenchGreeting = <span class="keyword">new</span> HelloWorld() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Salut tout le monde."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        englishGreeting.greet();</span><br><span class="line">        frenchGreeting.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名类的语法：</strong></p><p>匿名类表达式的语法类似于调用一个构造器，只不过 <code>there is a class definition contained in a block of code</code>（参见上面示例代码中 frenchGreeting 对象的实例化)，一个匿名类表达式包括：</p><ul><li>new 操作符</li><li>要实现的接口名或者要继承的类名，上面的例子中是实现了 HelloWorld 接口</li><li>括号及要传给构造器的参数，就像一个正常类的实例化表达式一样。注：当实现一个接口时，没有构造器，因此括号中参数为空即可，就像上面例子</li><li>类声明体，里面会包含一些方法声明</li><li>因为匿名类是一个表达式，所以他必须是一个 statement 的一部分，在上面例子中，匿名类表达式是 frenchGreeting 对象实例化 statement 的一部分（所以在花括号 <code>}</code> 后面是一个分号 <code>;</code>）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;嵌套类是指被定义在另一个类内部的类，嵌套类存在的目的应该只是为了他的外围类(enclosing class)提供服务，如果将来还会出现在其他的环境中，他就该是顶层类(top-level class)。嵌套类有四种，静态成员类(static member class)，成员类(member class)，匿名类和局部类，除了第一种，其他三种都是内部类&lt;/p&gt;
&lt;h2 id=&quot;不同嵌套类的使用&quot;&gt;&lt;a href=&quot;#不同嵌套类的使用&quot; class=&quot;headerlink&quot; title=&quot;不同嵌套类的使用&quot;&gt;&lt;/a&gt;不同嵌套类的使用&lt;/h2&gt;&lt;p&gt;下面部分内容和示例来自 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Oracle官方文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java枚举类</title>
    <link href="https://ryan-hou.github.io/2018/08/23/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
    <id>https://ryan-hou.github.io/2018/08/23/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB/</id>
    <published>2018-08-23T12:13:56.000Z</published>
    <updated>2020-04-16T07:13:45.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>enum 全称为 enumeration，是 JDK 1.5 中引入的新特性，通过引入 <code>java.lang.Enum</code> 抽象类结合编译器语法糖实现</p><blockquote><p>In general you can use an enum as if it were another way to create a data type, and then just put the results to work.<br>In many ways you can treat an enum as if it were any other class.  In fact, enums are classes and have their own methods.</p></blockquote><h3 id="enum-语法规则"><a href="#enum-语法规则" class="headerlink" title="enum 语法规则"></a>enum 语法规则</h3><p>创建枚举类需要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类。枚举类中定义的每一个值(实例对象)都会通过 Enum 类的构造函数 <code>protected Enum(String name, int ordinal)</code> 来隐式创建，对象的名称被转为一个字符串 name，并且 ordinal 记录了此值被创建的顺序，从 0 开始(该顺序值也是枚举类可以支持 <code>switch</code> 关键字的原因所在)</p><a id="more"></a><h3 id="为什么要使用枚举类？"><a href="#为什么要使用枚举类？" class="headerlink" title="为什么要使用枚举类？"></a>为什么要使用枚举类？</h3><p>在不少实际场景中，<strong>一个类的对象是有限且固定的</strong>，如季节类对象(一年四季)等，我们可以把这些类的对象一次性创建好放到类中以供调用，且不能在类的外部再创建该类的对象；知道了枚举类的应用场景，我们完全可以自己手动实现一个枚举类：</p><ul><li>枚举类中的对象不能通过 new 关键字创建，所以要私有化构造器</li><li>枚举类中的对象要能通过类名进行访问，且不能进行更改，因此应该用 <code>public static final</code> 修饰</li></ul><p>Java 提供的枚举类很好的支持了上述应用场景。事实上，虽然 enum 的语法结构与 class 不同，但是经过编译器编译后，会生成一个 class 文件，该 class 文件反编译后可以看到实际上是生成了一个类，该类继承了 <code>java.lang.Enum&lt;E&gt;</code>；所以大可以把 enum 看成是一个普通的 class，可以定义想要的属性和方法， 只不过该 class 的对象已经创建好，且不能被修改(<strong>当枚举类中只有一个对象实例时，实际上就是一个单例模式</strong>)，而且由于该类继承了 Enum 类，所以可以调用该抽象类中的方法；从这个角度来看，<strong>enum 关键字实际上是 Java 提供的一个语法糖，让我们更快的定义一个类和该类包含的对象</strong></p><h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><p>既然枚举类是继承了抽象类 Enum，所以要想了解枚举类的使用，需要看一下 Enum 的源码</p><h4 id="Enum-类中重要的方法"><a href="#Enum-类中重要的方法" class="headerlink" title="Enum 类中重要的方法"></a>Enum 类中重要的方法</h4><ul><li><strong>static  T[] values()</strong> :<br>produces an array of values of the enum constants in the order they were declared(implicit method)</li><li><strong>static T valueOf(String name)</strong>:  get corresponding enum constant from a name</li><li><strong>static &lt;T extends Enum<t>&gt; T valueOf(Class<t> enumType,  String name)</t></t></strong>:<br><strong>Returns the enum constant</strong> of the specified enum type with the specified name.</li><li><strong>final int ordinal()</strong>：<br>indicate the declaration order of a particular enum constant</li><li><strong>final String name()</strong>: return the name of this enum constant。toString() method in preference to this one</li></ul><h4 id="Enum-部分源码"><a href="#Enum-部分源码" class="headerlink" title="Enum 部分源码"></a>Enum 部分源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The name of this enum constant, as declared in the enum declaration.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sole constructor. Programmers cannot invoke this constructor. It is for use by code emitted by the compiler in response to enum type declarations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other stuff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码实际上解释了当我们在枚举类中定义一个对象实例时，编译器会自动调用上面的构造函数创建该对象，并且该对象是 <code>public static final</code> 修饰的，对象的 <code>name</code> 属性值就是该对象的名字，对象的<code>ordinal</code> 属性值就是该对象被创建的顺序</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>举个简单例子看下枚举类的使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Season &#123;</span><br><span class="line">        </span><br><span class="line">        SPRING(<span class="number">1</span>, <span class="string">"春天"</span>),</span><br><span class="line">        SUMMER(<span class="number">2</span>, <span class="string">"夏天"</span>),</span><br><span class="line">        FALL(<span class="number">3</span>, <span class="string">"秋天"</span>),</span><br><span class="line">        WINTER(<span class="number">4</span>, <span class="string">"冬天"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line">        Season(<span class="keyword">int</span> idx, String desc) &#123;</span><br><span class="line">            <span class="keyword">this</span>.idx = idx;</span><br><span class="line">            <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> idx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> idx + <span class="string">": "</span> + desc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Season season : Season.values()) &#123;</span><br><span class="line">            System.out.println(season.getDesc());</span><br><span class="line">            System.out.println(season);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类在-switch-中的使用"><a href="#枚举类在-switch-中的使用" class="headerlink" title="枚举类在 switch 中的使用"></a>枚举类在 switch 中的使用</h3><blockquote><p>Since a switch is intended to select from a limited set of possibilities, it’s an ideal match for enum.</p></blockquote><p>switch 还没有支持 String 类型的语法糖前，在 switch 语句中想要通过 String 类型进行选择，就需要通过构造枚举来实现，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Fruit &#123;</span><br><span class="line">    APPLE, ORANGE, MANGO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String value; <span class="comment">// assume input</span></span><br><span class="line">Fruit fruit = Fruit.valueOf(value); <span class="comment">// surround with try/catch</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> APPLE: &#123;</span><br><span class="line">        <span class="comment">// 输入的字符串为 APPLE</span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ORANGE: &#123;</span><br><span class="line">        method2();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MANGO: &#123;</span><br><span class="line">        method3();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end switch</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;p&gt;enum 全称为 enumeration，是 JDK 1.5 中引入的新特性，通过引入 &lt;code&gt;java.lang.Enum&lt;/code&gt; 抽象类结合编译器语法糖实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In general you can use an enum as if it were another way to create a data type, and then just put the results to work.&lt;br&gt;In many ways you can treat an enum as if it were any other class.  In fact, enums are classes and have their own methods.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;enum-语法规则&quot;&gt;&lt;a href=&quot;#enum-语法规则&quot; class=&quot;headerlink&quot; title=&quot;enum 语法规则&quot;&gt;&lt;/a&gt;enum 语法规则&lt;/h3&gt;&lt;p&gt;创建枚举类需要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类。枚举类中定义的每一个值(实例对象)都会通过 Enum 类的构造函数 &lt;code&gt;protected Enum(String name, int ordinal)&lt;/code&gt; 来隐式创建，对象的名称被转为一个字符串 name，并且 ordinal 记录了此值被创建的顺序，从 0 开始(该顺序值也是枚举类可以支持 &lt;code&gt;switch&lt;/code&gt; 关键字的原因所在)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
