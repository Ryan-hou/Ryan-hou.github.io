<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x08 0x17</title>
  
  <subtitle>Build something useful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ryan-hou.github.io/"/>
  <updated>2020-04-08T07:05:56.745Z</updated>
  <id>https://ryan-hou.github.io/</id>
  
  <author>
    <name>0x08 0x17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>null awareness</title>
    <link href="https://ryan-hou.github.io/2019/04/07/null-awareness/"/>
    <id>https://ryan-hou.github.io/2019/04/07/null-awareness/</id>
    <published>2019-04-07T14:30:20.000Z</published>
    <updated>2020-04-08T07:05:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>前面翻译了一篇关于如何合理使用 null 的文章:<a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a>，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的</p><h3 id="null-是什么"><a href="#null-是什么" class="headerlink" title="null 是什么"></a>null 是什么</h3><p>null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:</p><a id="more"></a><ul><li>null 是关键字，大小写敏感</li><li>null 既不是对象也不是一种类型，它仅是一个<strong>特殊值</strong>，你可以将它赋予任何引用类型，你也可以将 null 强制转化为任何引用类型</li><li>可以使用 == 和 = 来操作 null 值，但是不能使用其他逻辑操作，在 Java 中 <code>null == null</code> 返回 true</li><li>使用作为引用类型变量默认值的 null，instanceof 操作符将会返回 false</li></ul><h3 id="null-带来的问题"><a href="#null-带来的问题" class="headerlink" title="null 带来的问题"></a>null 带来的问题</h3><p>null 本身不是一个对象，通过 null 访问对象的成员方法或者成员变量(解引用)会导致空指针异常(NPE)；由于我们很容易忽略判断一个对象是否为 null，所以想当然的进行解引用操作时会带来 NPE 问题</p><h3 id="如何规避-null-的问题"><a href="#如何规避-null-的问题" class="headerlink" title="如何规避 null 的问题"></a>如何规避 null 的问题</h3><p><strong>意识非常重要，意识非常重要，意识非常重要</strong>，重要的事情说三遍！当我们拿到一个引用类型的变量时，条件反射的就要考虑这个变量是不是 null，如果是 null 该怎么处理？我自己写的代码导致了 NPE 时，我总会反思自己: 代码里的 NPE 都解决不了，难怪现实中也没对象……</p><p>有了上面的意识，下面再介绍一些实用的方法来规避 NPE。部分内容在 <a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a> 也有提到，可以互为参考。</p><p>既然 NPE 的源头在于 null，那么避免使用 null 就可以从源头上解决这个问题。比如可以使用 Guava 提供的 <code>ImmutableMap, ImmutableList</code> 等不允许元素为 null 的集合类。尽量不要用 null 来初始化变量，函数尽量不要返回 null。对于必须要用 null 的场景考虑单独定义相应的 null object</p><p>采用防御性编程。作为函数作者，我们要对入参进行必要的校验，不允许参数为空时直接抛出异常而不是继续执行。由函数的调用者对程序异常负责；尽量不返回 null，比如可以返回 Optional 对象，或者 null object</p><p>作为函数调用者，要对返回值是否为 null 保持敏感。明确返回的 null 值含义，进行相应的检查和处理。比如远程调用时，对于返回值通常要进行判空处理</p><p>使用 @NotNull 和 @Nullable 注解配合 IntelliJ 尽量在早期发现和预防 NPE</p><p>对于链式调用要格外注意，很容易在某个调用过程发生 NPE。比如 <code>obj.methodA().methodB().methodC()</code></p><p>警惕包装类型的自动装箱和拆箱。相比基本数据类型，包装类型存在 null 这个默认值，在自动拆箱时很容易 NPE。而且正是由于这个语法糖，我们会下意识的把包装类和基本类型等同，实际上两者是很不一样的。所以对于这个语法糖我个人持弊大于利的观点。总之，在使用包装类型时，要格外留心，他们是包装类型而不是基本类型，不能闭着眼睛混用！</p><p>以上是对于 null 的总结，概括来说，就是<strong>要时刻对于 null 这个 corner case 保持警惕，然后采取合理的处理方式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面翻译了一篇关于如何合理使用 null 的文章:&lt;a href=&quot;https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/&quot;&gt;Using and avoiding null&lt;/a&gt;，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的&lt;/p&gt;
&lt;h3 id=&quot;null-是什么&quot;&gt;&lt;a href=&quot;#null-是什么&quot; class=&quot;headerlink&quot; title=&quot;null 是什么&quot;&gt;&lt;/a&gt;null 是什么&lt;/h3&gt;&lt;p&gt;null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="经验" scheme="https://ryan-hou.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Using and avoiding null</title>
    <link href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/"/>
    <id>https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/</id>
    <published>2019-04-06T15:50:20.000Z</published>
    <updated>2020-04-08T02:58:57.690Z</updated>
    
    <content type="html"><![CDATA[<p>文章翻译自 Google Guava 文档，原文链接: <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Using and avoiding null</a></p><h3 id="Why-avoid-null？"><a href="#Why-avoid-null？" class="headerlink" title="Why avoid null？"></a>Why avoid null？</h3><blockquote><p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p></blockquote><p>随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的</p><a id="more"></a><p>此外，null 非常有歧义性。很难从返回的 null 得到具体的含义－－例如，<code>Map.get(key)</code> 返回 null，既可能是因为该 key 对应的 value 是 null，也可能是因为该 key 不存在。null 可以表示失败，也可以表示成功，可以表示几乎所有东西。使用其他表意更清晰的东西而不是 null 可以增强代码可读性</p><p>上面说了，绝大部分情况下都不要随意使用 null，同时这也说明了 null 在一些场景下的使用是合理的。从内存和速度的角度来看，使用 null 很”廉价”，而且在对象数组中也不可避免。不同于类库，在应用代码中，null 通常会因表义不清，进而带来歧义和奇葩的 bug－－比如，当 <code>Map.get</code> 返回 null，它可以表示值不存在或者值存在但是为 null。更要命的是，null 不会给 null 值本身到底意味着什么提供任何提示</p><p>综上原因，只要存在可以方便使用 null 的 workaround，Guava 中相应的很多工具类都采用 fail fast 策略拒绝 null 值。此外，Guava 提供了很多工具避免你使用 null，或者在你必须要使用 null 时用起来更简单</p><h3 id="Specific-Cases"><a href="#Specific-Cases" class="headerlink" title="Specific Cases"></a>Specific Cases</h3><p>如果你想要在 <code>Set</code> 或者 <code>Map</code> 的 key 中使用 null，不要这么做！在查询操作中单独定义关于 null 值的 <strong>special-case</strong> 会使代码更加清晰</p><p>如果你想在 <code>Map</code> 中使用值为 null 的 value，那么把这个键值对单独定义出来。把 <code>Set</code> 中非空的 key (或者为空的 key)单独定义。因为我们很容易把 Map 中不存在某个 key 和 Map 中存在某个 key，该 key 对应的 value 值为 null 这两种完全不同的情景搞混。把这样的 key 单独定义出来要好得多，同时这样会<strong>强迫你去思考</strong>你的应用中一个 key 对应的 value 值为空，是怎样的一种场景</p><p>如果你在 <code>List</code> 中使用 null，而这个 List 是稀疏的，可能定义一个 <code>Map&lt;Integer, E&gt;</code> (key 为 List 元素的下标值，value 为对应的 List 元素)会让代码更加高效，同时也可能更符合你的需求</p><p>考虑一下是否存在一个 “null object” 可以使用，这种情况不总是存在，但是有些场景，比如一个枚举类可以加一个常量来代表你希望 null 值所表示的含义。例如，在 <code>java.math.RoundingMode</code> 中有一个 <code>UNNECESSARY</code> 值来表示 “do no rounding, and throw an exception if rounding would be necessary.”</p><p>如果你确实需要 null 值，那就不要使用 null-hostile 的集合类（比如 <code>ImmutableList, ImmutableMap</code>），可以使用支持 null 的集合类实现。比如，使用 <code>Collections.unmodifiableList(Collection&lt;? extends T&gt; c)</code> 而不是 <code>ImmutableList</code></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>注: JDK 1.8 中已经引入了类似的 Optional 工具类，基本思想是一致的: null 指针之所以存在问题，是因为你可以在不检查 null 的情况下访问对象的成员方法和成员变量(null 解引用导致 NPE)。使用 Optional 可以强迫你去思考 null 这种情况或者通过类似 <code>ifPresent(Consumer&lt;? super T&gt; consumer)</code> 这样的方法把判断是否为 null 和访问操作合二为一，只有不为 null 时才能进行相应操作</p><p>在很多场景下，我们程序员使用 null 是用来<strong>表示某种缺失</strong>：在某个地方可能会存在一个值，但是现在没有或者找不到。<code>Optional&lt;T&gt;</code> 把可为空的引用T替换为一个非空的 Optional 值。一个 Optional 要么包含一个非空的引用T(在这种场景下我们说这个引用是 <strong>present</strong> 的)，要么什么也不包含（在这种场景下，我们说这个引用是 <strong>absent</strong> 的）。即引用要么 present 要么 absent，不存在 <strong>contain null</strong>，避免产生歧义</p><p>下面列一些常用的操作：（注: 下述方法均为 JDK 中 <code>Optional&lt;T&gt;</code> 类的方法，使用方式和 Guava 基本一致 ）</p><h4 id="Making-an-Optional"><a href="#Making-an-Optional" class="headerlink" title="Making an Optional"></a>Making an Optional</h4><p>Optional 中的静态方法:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>Make an Optional containing the given non-null value, or fail fast on null.</td></tr><tr><td>Optional.ofNullable(T)</td><td>Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.</td></tr></tbody></table><h4 id="Query-methods"><a href="#Query-methods" class="headerlink" title="Query methods"></a>Query methods</h4><p>下面是常用的实例方法</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>boolean isPresent()</td><td>Returns true if this Optional contains a non-null instance.</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</td></tr><tr><td>T get()</td><td>Returns the contained T instance, which must be present; otherwise, throws an NoSuchElementException</td></tr><tr><td>T orElse(T other)</td><td>Return the value if present, otherwise return other.</td></tr><tr><td>Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></td><td>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an Optional describing the result.  Otherwise return an empty Optional.</td></tr></tbody></table><p>Optional 还提供了其它有用的方法，具体信息可以去看 Javadoc</p><h4 id="What’s-the-point"><a href="#What’s-the-point" class="headerlink" title="What’s the point?"></a>What’s the point?</h4><p>除了通过给 null 一个名字(缺失与否)来增强可读性，Optional 带来的最大好处在于它是 idiot-proof-ness 的，它迫使你去思考 absent 的场景到底是怎样的，否则你的程序可能会编译不过去，因为你必须手动 unwrap the Optional 并处理 absent 的情况。直接使用 null 使这些情况很容易被忽略，尽管 FindBugs 也可以提供帮助，但是我们不认为它能像 Optional 一样解决这个问题</p><p><strong>当返回一个可能存在或者可能不存在的值时，使用Optional 更加有用。</strong>对于 <code>other.method(a, b)</code>方法，相比我们在实现这个方法时忘记判断 a,b 可能为 null 这种情况，我们更容易忘记这个方法可能会返回 null。而返回 Optional 则使调用者不可能忘记处理这种情况，因为他们必须 unwrap 这个对象来使他们的代码能编译</p><h3 id="Convenience-methods"><a href="#Convenience-methods" class="headerlink" title="Convenience methods"></a>Convenience methods</h3><p>无论何时你想使用一个默认值来代替 null，可以使用 <code>MoreObjects.firstNonNull(T, T)</code>，正如该方法的名字所示，如果两个输入都是 null，该方法会通过抛出NPE来实现 fail fast。如果你在使用 Optional 对象，那么 <code>first.orElse(second)</code> 是更好的替代方法</p><p>在<code>Strings</code>类中提供了几个处理可能为空的方法，而且我们专门定义了恰当的名字：</p><ul><li>emptyToNull(String)</li><li>isNullOrEmpty(String)</li><li>nullToEmpty(String)</li></ul><p>我们想强调一下，这些方法主要是用来处理那些把 null 字符串和 empty 字符串等同看待的API。每当你写出把 null 和 empty 字符串混用的代码，Guava 团队的小伙伴都”哭了”(null 字符串和 empty 字符串混用通常是令人不安的 code smell)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章翻译自 Google Guava 文档，原文链接: &lt;a href=&quot;https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using and avoiding null&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Why-avoid-null？&quot;&gt;&lt;a href=&quot;#Why-avoid-null？&quot; class=&quot;headerlink&quot; title=&quot;Why avoid null？&quot;&gt;&lt;/a&gt;Why avoid null？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“Null sucks.” -Doug Lea&lt;br&gt;&lt;br&gt;&lt;br&gt;“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的各种姿势</title>
    <link href="https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/</id>
    <published>2018-12-01T02:58:05.000Z</published>
    <updated>2020-04-08T10:22:17.582Z</updated>
    
    <content type="html"><![CDATA[<p>在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other operatons...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 防止通过反射创建多个实例</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"instance already existed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他初始化操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>优点：实现简单，线程安全(依赖 JVM 在加载这个类时创建唯一的实例)</li><li>缺点：不能延迟初始化(类加载时即创建实例对象，至于类加载时机，虚拟机规范并没有强制约束)，如果该类实例化需要的资源很多，会影响内存和性能</li></ul><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>在 jdk5 之后，通过单元素的枚举可以实现单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 其他实例方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举构造单例，写法简单，线程安全，可以防御反射攻击，并且是序列化/反序列化安全的；但是不能延迟初始化</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance == <span class="keyword">null</span> ? <span class="keyword">new</span> Singleton() : instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持延迟初始化，在使用时才去创建单例实例。但是不能保证线程安全，当有多个线程同时执行 <code>instance == null</code> 时，可能会创建多个实例</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>使用同步方法</li></ul><p>在上面代码的基础上，把 <code>getInstance()</code> 方法加上 synchronized 关键字，变为同步方法，保证了不会同时有多个线程进入这个方法</p><p>优点：简单且有效，而且 JVM 会不断优化 synchronized 关键字的实现方式，如果应用程序可以接受同步的开销，推荐使用</p><p>缺点当然是同步方法带来的开销问题，而且在这里实际上只有第一次执行时才真正需要同步，一旦设置好 instance 变量后，就不再需要同步这个方法了，所以我们有必要寻找更优的线程安全实现</p><ul><li>double-checked locking</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 检查实例，如果不存在才进入同步块</span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstace == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//  再次检查是否存在实例，不存在时才创建实例，避免创建多个实例</span></span><br><span class="line"><span class="comment">// volatile 关键字保证了实例化对象的指令不被重排序，避免返回未正确初始化的对象实例</span></span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstace;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：通过同步代码块，缩小了同步范围（实例一旦创建便不再需要同步），通过 double-checked 避免了多线程创建多个实例</p><p>缺点：在 jdk5 之前，这种实现方式是错误的，当时的 JVM 对于 volatile 的实现不能保证返回的是正确初始化的对象(jdk5 及之后的版本，volatile 增强了语义，避免了指令重排带来的问题)</p><ul><li>On demand holder idiom</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This code is guaranteed to be correct because of the initialization guarantees</span></span><br><span class="line"><span class="comment">     * for static fields; if a field is set in a static initializer, it it guaranteed</span></span><br><span class="line"><span class="comment">     * to be made visible, correctly, to any thread that accesses that class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> LazySingletonHolder.singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过静态字段实例化保证了在实例变量被任何线程访问时返回正确初始化的变量，且静态字段只被初始化一次，满足了线程安全和实例唯一性；又因为静态内部类的加载不需要依附外部类，在使用时才加载，满足了延迟初始化</p><p>总结一下，上述各种单例模式的实现方式说明了<strong>在不同场景和需求下会有不同的设计方案，即使是相同场景下也可能会有不同的设计，而每种设计也存在不同的侧重和取舍</strong>。如果延迟初始化不是我们要考量的问题，推荐使用枚举方式实现单例，否则推荐最后一种实现方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下&lt;/p&gt;
&lt;h2 id=&quot;懒汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式&quot;&gt;&lt;/a&gt;懒汉模式&lt;/h2&gt;&lt;p&gt;因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Other operatons...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 防止通过反射创建多个实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;instance already existed!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
