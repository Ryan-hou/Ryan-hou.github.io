<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x08 0x17</title>
  
  <subtitle>Build something useful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ryan-hou.github.io/"/>
  <updated>2020-04-08T07:05:56.745Z</updated>
  <id>https://ryan-hou.github.io/</id>
  
  <author>
    <name>0x08 0x17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>null awareness</title>
    <link href="https://ryan-hou.github.io/2019/04/07/null-awareness/"/>
    <id>https://ryan-hou.github.io/2019/04/07/null-awareness/</id>
    <published>2019-04-07T14:30:20.000Z</published>
    <updated>2020-04-08T07:05:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>前面翻译了一篇关于如何合理使用 null 的文章:<a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a>，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的</p><h3 id="null-是什么"><a href="#null-是什么" class="headerlink" title="null 是什么"></a>null 是什么</h3><p>null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:</p><a id="more"></a><ul><li>null 是关键字，大小写敏感</li><li>null 既不是对象也不是一种类型，它仅是一个<strong>特殊值</strong>，你可以将它赋予任何引用类型，你也可以将 null 强制转化为任何引用类型</li><li>可以使用 == 和 = 来操作 null 值，但是不能使用其他逻辑操作，在 Java 中 <code>null == null</code> 返回 true</li><li>使用作为引用类型变量默认值的 null，instanceof 操作符将会返回 false</li></ul><h3 id="null-带来的问题"><a href="#null-带来的问题" class="headerlink" title="null 带来的问题"></a>null 带来的问题</h3><p>null 本身不是一个对象，通过 null 访问对象的成员方法或者成员变量(解引用)会导致空指针异常(NPE)；由于我们很容易忽略判断一个对象是否为 null，所以想当然的进行解引用操作时会带来 NPE 问题</p><h3 id="如何规避-null-的问题"><a href="#如何规避-null-的问题" class="headerlink" title="如何规避 null 的问题"></a>如何规避 null 的问题</h3><p><strong>意识非常重要，意识非常重要，意识非常重要</strong>，重要的事情说三遍！当我们拿到一个引用类型的变量时，条件反射的就要考虑这个变量是不是 null，如果是 null 该怎么处理？我自己写的代码导致了 NPE 时，我总会反思自己: 代码里的 NPE 都解决不了，难怪现实中也没对象……</p><p>有了上面的意识，下面再介绍一些实用的方法来规避 NPE。部分内容在 <a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a> 也有提到，可以互为参考。</p><p>既然 NPE 的源头在于 null，那么避免使用 null 就可以从源头上解决这个问题。比如可以使用 Guava 提供的 <code>ImmutableMap, ImmutableList</code> 等不允许元素为 null 的集合类。尽量不要用 null 来初始化变量，函数尽量不要返回 null。对于必须要用 null 的场景考虑单独定义相应的 null object</p><p>采用防御性编程。作为函数作者，我们要对入参进行必要的校验，不允许参数为空时直接抛出异常而不是继续执行。由函数的调用者对程序异常负责；尽量不返回 null，比如可以返回 Optional 对象，或者 null object</p><p>作为函数调用者，要对返回值是否为 null 保持敏感。明确返回的 null 值含义，进行相应的检查和处理。比如远程调用时，对于返回值通常要进行判空处理</p><p>使用 @NotNull 和 @Nullable 注解配合 IntelliJ 尽量在早期发现和预防 NPE</p><p>对于链式调用要格外注意，很容易在某个调用过程发生 NPE。比如 <code>obj.methodA().methodB().methodC()</code></p><p>警惕包装类型的自动装箱和拆箱。相比基本数据类型，包装类型存在 null 这个默认值，在自动拆箱时很容易 NPE。而且正是由于这个语法糖，我们会下意识的把包装类和基本类型等同，实际上两者是很不一样的。所以对于这个语法糖我个人持弊大于利的观点。总之，在使用包装类型时，要格外留心，他们是包装类型而不是基本类型，不能闭着眼睛混用！</p><p>以上是对于 null 的总结，概括来说，就是<strong>要时刻对于 null 这个 corner case 保持警惕，然后采取合理的处理方式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面翻译了一篇关于如何合理使用 null 的文章:&lt;a href=&quot;https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/&quot;&gt;Using and avoiding null&lt;/a&gt;，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的&lt;/p&gt;
&lt;h3 id=&quot;null-是什么&quot;&gt;&lt;a href=&quot;#null-是什么&quot; class=&quot;headerlink&quot; title=&quot;null 是什么&quot;&gt;&lt;/a&gt;null 是什么&lt;/h3&gt;&lt;p&gt;null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="经验" scheme="https://ryan-hou.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Using and avoiding null</title>
    <link href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/"/>
    <id>https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/</id>
    <published>2019-04-06T15:50:20.000Z</published>
    <updated>2020-04-08T02:58:57.690Z</updated>
    
    <content type="html"><![CDATA[<p>文章翻译自 Google Guava 文档，原文链接: <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Using and avoiding null</a></p><h3 id="Why-avoid-null？"><a href="#Why-avoid-null？" class="headerlink" title="Why avoid null？"></a>Why avoid null？</h3><blockquote><p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p></blockquote><p>随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的</p><a id="more"></a><p>此外，null 非常有歧义性。很难从返回的 null 得到具体的含义－－例如，<code>Map.get(key)</code> 返回 null，既可能是因为该 key 对应的 value 是 null，也可能是因为该 key 不存在。null 可以表示失败，也可以表示成功，可以表示几乎所有东西。使用其他表意更清晰的东西而不是 null 可以增强代码可读性</p><p>上面说了，绝大部分情况下都不要随意使用 null，同时这也说明了 null 在一些场景下的使用是合理的。从内存和速度的角度来看，使用 null 很”廉价”，而且在对象数组中也不可避免。不同于类库，在应用代码中，null 通常会因表义不清，进而带来歧义和奇葩的 bug－－比如，当 <code>Map.get</code> 返回 null，它可以表示值不存在或者值存在但是为 null。更要命的是，null 不会给 null 值本身到底意味着什么提供任何提示</p><p>综上原因，只要存在可以方便使用 null 的 workaround，Guava 中相应的很多工具类都采用 fail fast 策略拒绝 null 值。此外，Guava 提供了很多工具避免你使用 null，或者在你必须要使用 null 时用起来更简单</p><h3 id="Specific-Cases"><a href="#Specific-Cases" class="headerlink" title="Specific Cases"></a>Specific Cases</h3><p>如果你想要在 <code>Set</code> 或者 <code>Map</code> 的 key 中使用 null，不要这么做！在查询操作中单独定义关于 null 值的 <strong>special-case</strong> 会使代码更加清晰</p><p>如果你想在 <code>Map</code> 中使用值为 null 的 value，那么把这个键值对单独定义出来。把 <code>Set</code> 中非空的 key (或者为空的 key)单独定义。因为我们很容易把 Map 中不存在某个 key 和 Map 中存在某个 key，该 key 对应的 value 值为 null 这两种完全不同的情景搞混。把这样的 key 单独定义出来要好得多，同时这样会<strong>强迫你去思考</strong>你的应用中一个 key 对应的 value 值为空，是怎样的一种场景</p><p>如果你在 <code>List</code> 中使用 null，而这个 List 是稀疏的，可能定义一个 <code>Map&lt;Integer, E&gt;</code> (key 为 List 元素的下标值，value 为对应的 List 元素)会让代码更加高效，同时也可能更符合你的需求</p><p>考虑一下是否存在一个 “null object” 可以使用，这种情况不总是存在，但是有些场景，比如一个枚举类可以加一个常量来代表你希望 null 值所表示的含义。例如，在 <code>java.math.RoundingMode</code> 中有一个 <code>UNNECESSARY</code> 值来表示 “do no rounding, and throw an exception if rounding would be necessary.”</p><p>如果你确实需要 null 值，那就不要使用 null-hostile 的集合类（比如 <code>ImmutableList, ImmutableMap</code>），可以使用支持 null 的集合类实现。比如，使用 <code>Collections.unmodifiableList(Collection&lt;? extends T&gt; c)</code> 而不是 <code>ImmutableList</code></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>注: JDK 1.8 中已经引入了类似的 Optional 工具类，基本思想是一致的: null 指针之所以存在问题，是因为你可以在不检查 null 的情况下访问对象的成员方法和成员变量(null 解引用导致 NPE)。使用 Optional 可以强迫你去思考 null 这种情况或者通过类似 <code>ifPresent(Consumer&lt;? super T&gt; consumer)</code> 这样的方法把判断是否为 null 和访问操作合二为一，只有不为 null 时才能进行相应操作</p><p>在很多场景下，我们程序员使用 null 是用来<strong>表示某种缺失</strong>：在某个地方可能会存在一个值，但是现在没有或者找不到。<code>Optional&lt;T&gt;</code> 把可为空的引用T替换为一个非空的 Optional 值。一个 Optional 要么包含一个非空的引用T(在这种场景下我们说这个引用是 <strong>present</strong> 的)，要么什么也不包含（在这种场景下，我们说这个引用是 <strong>absent</strong> 的）。即引用要么 present 要么 absent，不存在 <strong>contain null</strong>，避免产生歧义</p><p>下面列一些常用的操作：（注: 下述方法均为 JDK 中 <code>Optional&lt;T&gt;</code> 类的方法，使用方式和 Guava 基本一致 ）</p><h4 id="Making-an-Optional"><a href="#Making-an-Optional" class="headerlink" title="Making an Optional"></a>Making an Optional</h4><p>Optional 中的静态方法:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>Make an Optional containing the given non-null value, or fail fast on null.</td></tr><tr><td>Optional.ofNullable(T)</td><td>Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.</td></tr></tbody></table><h4 id="Query-methods"><a href="#Query-methods" class="headerlink" title="Query methods"></a>Query methods</h4><p>下面是常用的实例方法</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>boolean isPresent()</td><td>Returns true if this Optional contains a non-null instance.</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</td></tr><tr><td>T get()</td><td>Returns the contained T instance, which must be present; otherwise, throws an NoSuchElementException</td></tr><tr><td>T orElse(T other)</td><td>Return the value if present, otherwise return other.</td></tr><tr><td>Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></td><td>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an Optional describing the result.  Otherwise return an empty Optional.</td></tr></tbody></table><p>Optional 还提供了其它有用的方法，具体信息可以去看 Javadoc</p><h4 id="What’s-the-point"><a href="#What’s-the-point" class="headerlink" title="What’s the point?"></a>What’s the point?</h4><p>除了通过给 null 一个名字(缺失与否)来增强可读性，Optional 带来的最大好处在于它是 idiot-proof-ness 的，它迫使你去思考 absent 的场景到底是怎样的，否则你的程序可能会编译不过去，因为你必须手动 unwrap the Optional 并处理 absent 的情况。直接使用 null 使这些情况很容易被忽略，尽管 FindBugs 也可以提供帮助，但是我们不认为它能像 Optional 一样解决这个问题</p><p><strong>当返回一个可能存在或者可能不存在的值时，使用Optional 更加有用。</strong>对于 <code>other.method(a, b)</code>方法，相比我们在实现这个方法时忘记判断 a,b 可能为 null 这种情况，我们更容易忘记这个方法可能会返回 null。而返回 Optional 则使调用者不可能忘记处理这种情况，因为他们必须 unwrap 这个对象来使他们的代码能编译</p><h3 id="Convenience-methods"><a href="#Convenience-methods" class="headerlink" title="Convenience methods"></a>Convenience methods</h3><p>无论何时你想使用一个默认值来代替 null，可以使用 <code>MoreObjects.firstNonNull(T, T)</code>，正如该方法的名字所示，如果两个输入都是 null，该方法会通过抛出NPE来实现 fail fast。如果你在使用 Optional 对象，那么 <code>first.orElse(second)</code> 是更好的替代方法</p><p>在<code>Strings</code>类中提供了几个处理可能为空的方法，而且我们专门定义了恰当的名字：</p><ul><li>emptyToNull(String)</li><li>isNullOrEmpty(String)</li><li>nullToEmpty(String)</li></ul><p>我们想强调一下，这些方法主要是用来处理那些把 null 字符串和 empty 字符串等同看待的API。每当你写出把 null 和 empty 字符串混用的代码，Guava 团队的小伙伴都”哭了”(null 字符串和 empty 字符串混用通常是令人不安的 code smell)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章翻译自 Google Guava 文档，原文链接: &lt;a href=&quot;https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using and avoiding null&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Why-avoid-null？&quot;&gt;&lt;a href=&quot;#Why-avoid-null？&quot; class=&quot;headerlink&quot; title=&quot;Why avoid null？&quot;&gt;&lt;/a&gt;Why avoid null？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“Null sucks.” -Doug Lea&lt;br&gt;&lt;br&gt;&lt;br&gt;“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>作用域与闭包</title>
    <link href="https://ryan-hou.github.io/2019/03/08/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>https://ryan-hou.github.io/2019/03/08/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</id>
    <published>2019-03-08T15:16:52.000Z</published>
    <updated>2020-04-13T08:46:12.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>简单来说一句话：<strong>带上下文的函数</strong>，下面展开说明一下</p><p>声明：接下来的部分内容来自对 StackOverflow 回答的翻译，原答案链接 <a href="http://stackoverflow.com/questions/36636/what-is-a-closure" target="_blank" rel="noopener">What is a ‘Closure’?</a></p><p>要想理解好闭包，首先要弄清楚 <code>Scope</code>，当我们声明一个局部变量时，这个变量会有一个 Scope，通常局部变量仅在声明它的 block 或 function 中有效，比如下面 JS 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// fails</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>当我们访问一个局部变量时，大部分语言会先在当前 Scope 中寻找这个变量，找不到再去该 Scope 的父 Scope 中去寻找，直到找到根 Scope 为止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br></pre></td></tr></table></figure><p>当一个 block 或者 function 结束时，他的局部变量会被清理掉，这符合我们的预期</p><h3 id="闭包是持有局部变量的持续存在的-Scope"><a href="#闭包是持有局部变量的持续存在的-Scope" class="headerlink" title="闭包是持有局部变量的持续存在的 Scope"></a>闭包是持有局部变量的持续存在的 Scope</h3><p>闭包是一个持续存在的 Scope，该 Scope 会持有局部变量，即使在代码执行结束并跳出局部变量所在的 block 仍然有效。支持闭包的语言(如 JS，Swift 和 Ruby)允许你持有一个指向 Scope 对象(包括他的 parent scopes)的引用，即使在这些变量被声明的 block 执行完，你仍然可以在其他的地方持有指向这个 block 或者 function 的引用</p><p><strong>这些 Scope 对象和在该 Scope 下的局部变量被绑定到 function，并且只要该 function 存在，那么这些局部变量就存在 (函数和函数声明时的 scope 共存亡)</strong></p><p>这给我们使用函数提供了便利性，<strong>在函数第一次被声明的 Scope 中的局部变量会始终保持在该 Scope 中，即使我们下次从不同的 context 调用该 function 依然可以得到该局部变量</strong></p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this returns a function</span></span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute outer to get inner</span></span><br><span class="line"><span class="keyword">var</span> fuc = outer(); </span><br><span class="line"><span class="comment">// prints the value of a, which is 1</span></span><br><span class="line">fuc(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面在一个函数中定义了一个函数，内部的函数可以访问外部函数所有的局部变量，包括 <code>a</code>，变量 a 在内部函数的父 Scope 中</p><p>通常当一个函数退出，他所声明的所有的局部变量都会被回收，然而在这里，当我们返回内部函数并把它指向变量 fnc 时，外部函数(outer)退出后，<strong>在内部函数(inner)被定义的 Scope 中的所有的局部变量会持续存在。</strong><code>变量a within a closure.</code></p><p><strong>在上面的例子中，变量 a 完全是 fnc 函数私有的(函数加数据)，这为我们在函数式语言中创建私有变量提供了一种方式。(函数加上私有变量, 是不是看起来很像 OOP 中的对象(方法加上数据), 确实可以基于 Closure 构建对象系统 )</strong></p><p>上面的示例代码中，a 属于 <code>outer</code> scope，<code>inner</code> scope 存在一个指向父scope<code>outer</code>的指针。<code>fnc</code> 是一个指向 <code>inner</code> 的变量，a 会和 <code>fnc</code> 共存亡，a 在闭包中</p><p>以上，翻译结束，下面再对照下 OO 下的闭包</p><h2 id="OO-化的闭包"><a href="#OO-化的闭包" class="headerlink" title="OO 化的闭包"></a>OO 化的闭包</h2><p>在 JS 中，函数是一等公民，可以作为参数或者返回值传递，可以用于高阶函数，但是在 Java 中，函数不能独立存在，需要依附于类或者对象(函数在类中被称为方法，其实函数应该是可以单独存在的一种抽象)，正因此才有了类似函数对象，命令模式等一些东西，看似高大上，实际上是编程语言的限制带来的无奈之举</p><p>有人曾说过，<strong>类是带函数的数据，闭包是带数据的函数</strong>，上面我们看到了在 JS 中是如何使用闭包的，下面我们看一下在 OO 中如何使用闭包</p><p>在 <code>Thinking in Java</code> 中对于闭包与回调一节曾提到过：</p><blockquote><p>闭包(closure)是一个可调用的对象，它记录了一些信息，这些信息来自于创建他的作用域。通过这个定义，可以看出<strong>内部类是面向对象的闭包</strong>，因为他不仅包含外围类对象(创建内部类对象的作用域)的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类对象有权操作外部类对象所有的成员，包括 private 成员</p></blockquote><p>举个例子(代码修改自 <code>Thinking in Java</code>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callee</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other methods...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise you'd</span></span><br><span class="line">            <span class="comment">// get an infinite recursion:</span></span><br><span class="line">            Callee.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementable callbackReference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackReference = callbackReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Other operations...</span></span><br><span class="line">        <span class="comment">// 调用回调接口</span></span><br><span class="line">        callbackReference.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee c = <span class="keyword">new</span> Callee();</span><br><span class="line">        Caller caller = <span class="keyword">new</span> Caller(c.getCallbackReference());</span><br><span class="line">        caller.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中，内部类 Closure 实现了 Incrementable，以提供一个返回 Callee 的“钩子”，而且是一个安全的钩子，无论谁获得此 Incrementable 的引用，都只能调用 increment() (如果直接使用 Callee 类的实例作为钩子，该钩子还可以调用 Callee 类的其它方法，控制的力度不够细)，除此之外没有其他的功能。Caller 的构造器需要一个 Incrementable 的引用作为参数 (也可以通过 set 方法注入的方式在运行时动态设置回调引用)，然后在以后某个时刻，Caller 对象可以使用此引用回调 Callee 类。<strong>回调的价值在于它的灵活性，可以在运行时动态的决定需要调用什么方法</strong> (更多关于回调的内容可以参考之前整理的文章: <a href="https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">回调及在Java中的使用</a>)</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最近看了R大关于闭包的一篇博客，又有了一些新的思考，原文地址: <a href="https://rednaxelafx.iteye.com/blog/245022" target="_blank" rel="noopener">关于对象与闭包的关系的一个有趣小故事</a>，总结一些要点:</p><blockquote><p>闭包的要点有两个:<br>1、一个含有自由变量的函数；<br>2、这些自由变量所在的环境。<br><strong>外部环境持有内部函数所使用的自由变量，对内部函数形成“闭包”，就这样。</strong><br>简单但不严格的说，一个函数的“自由变量”就是既不是参数也不是局部变量的变量。基于类的面向对象程序语言中有一种情况，就是方法使用的自由变量来自其所在的类的实例</p></blockquote><blockquote><p>OO 里一般不提闭包<br>面向对象的语言里一般不把类称为闭包，没为什么，就是种习惯。<br><strong>当然严格来说方法(类的成员方法)所捕获的自由变量不是类的字段 x，而是this；x 是通过 this 来访问到的，完整写出应该是 <code>this.x</code></strong></p></blockquote><p>综上，通过对象或者闭包都可以获取函数的自由变量，没有高低之分</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h2&gt;&lt;p&gt;简单来说一句话：&lt;strong&gt;带上下文的函数&lt;/strong&gt;，下面展开说明一下&lt;/p&gt;
&lt;p&gt;声明：接下来的部分内容来自对 StackOverflow 回答的翻译，原答案链接 &lt;a href=&quot;http://stackoverflow.com/questions/36636/what-is-a-closure&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is a ‘Closure’?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要想理解好闭包，首先要弄清楚 &lt;code&gt;Scope&lt;/code&gt;，当我们声明一个局部变量时，这个变量会有一个 Scope，通常局部变量仅在声明它的 block 或 function 中有效，比如下面 JS 代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;// works&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;// fails&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>重新认识信息隐藏</title>
    <link href="https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    <id>https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/</id>
    <published>2019-02-22T12:25:51.000Z</published>
    <updated>2020-04-10T07:28:04.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个重要却容易忽略的问题"><a href="#一个重要却容易忽略的问题" class="headerlink" title="一个重要却容易忽略的问题"></a>一个重要却容易忽略的问题</h2><p>在谈到 OOP 时，大家一般会想到<strong>封装，继承和多态</strong>，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，<strong>信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。</strong>那信息隐藏为什么如此重要？</p><p>引用一段<code>Effective Java</code>中的话：</p><blockquote><p>要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信</p></blockquote><a id="more"></a><p>除了设计好的需要对外公开的 API 外，其他的成员原则上都要隐藏，如果不能很好的实现信息隐藏，意外暴露的成员被客户端操作会导致对象状态的不可控，<strong>这也要求我们在写代码时要保持有意识的状态，每一行代码都是一种“承诺”</strong></p><h2 id="封装与访问控制"><a href="#封装与访问控制" class="headerlink" title="封装与访问控制"></a>封装与访问控制</h2><p>谈信息隐藏，自然避不开封装。广义上的封装仅仅只是打包，把一些数据和行为封闭到一个盒子，这个盒子可能是黑盒子也可能是白盒子。相比 C 语言，Java 的封装引入了一种<strong>新的模块机制: 把相关的数据和作用在其上的运算打包为称为类的模块，从而为域和函数(准确的说应该是成员方法)提供了一个上下文。</strong></p><p>我们通常所说的狭义的封装是指<strong>在打包的基础上加上访问控制，以实现信息隐藏；访问控制不仅仅是语法上的限制，也是语义上的规范</strong>，标有 public 的是接口，标有 private 的是实现；这种语义显然比文档注释更加直观。</p><p>访问控制是对静态代码的控制，并非牢不可破，通过反射机制一样可以访问到 private 成员，这里也引出一个常见的误区，认为信息隐藏是为了安全性，不能说错，但信息隐藏的本意并不在此，<strong>信息隐藏通过屏蔽一个模块中非本质，容易变化的部分，从而保证了内部的修改不会波及客户，它的目的是为了提高稳定性和灵活性</strong>，通过信息隐藏，一个类相当于被划分为阴阳两面，阴面的实现对于客户是透明的</p><h2 id="如何更好的隐藏信息"><a href="#如何更好的隐藏信息" class="headerlink" title="如何更好的隐藏信息"></a>如何更好的隐藏信息</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><p>这个很好理解，举个简单例子，把一个类的 <code>private</code> 成员改为 <code>public</code> 不会产生问题，反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广，具体可以采用如下操作</p><h4 id="顶层类如果可以包级私有，那就包级私有"><a href="#顶层类如果可以包级私有，那就包级私有" class="headerlink" title="顶层类如果可以包级私有，那就包级私有"></a>顶层类如果可以包级私有，那就包级私有</h4><p>我们通过 IDE 生成类时，一般会默认用 public 修饰类，这里值得商榷，一个包中的类大部分都是为本包提供服务的，没有必要作为包的 API 导出，因为一旦导出，你就要负责一直维护他</p><h4 id="在公有类中使用访问方法而非公有域"><a href="#在公有类中使用访问方法而非公有域" class="headerlink" title="在公有类中使用访问方法而非公有域"></a>在公有类中使用访问方法而非公有域</h4><p><strong>公有类永远都不应该暴露可变的域。在特殊情况下，暴露公有的静态的 final域是可以接受的，但是这里的域要么是基本类型，要么是不可变的。</strong>比如一个很常见的错误就是：<code>public Date getBirthday() { return birthday }</code> 这里即使 birthday 使用了 <code>private</code> 的访问修饰符，但仍然没用，因为 Date 类不是不可变的（当然了 Date 类是可变的属于类库设计的缺陷），这里应该提供防御性复制</p><h4 id="private-frist"><a href="#private-frist" class="headerlink" title="private frist"></a>private frist</h4><p>使用 private 不需要理由，不使用才需要理由，这也是为什么如 C# 之类的语言默认的访问修饰符是 private（Java默认是包级私有）</p><h4 id="警惕长度不为0的数组"><a href="#警惕长度不为0的数组" class="headerlink" title="警惕长度不为0的数组"></a>警惕长度不为0的数组</h4><p><strong>长度不为0的数组总是可变的，类具有公有的静态的 final 数组域或者返回这种域的访问方法，几乎总是错误的。</strong>可以通过把数组域私有，并添加一个公有方法，返回私有数组域的一个备份:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="comment">// shallow copy, Thing need to be Immutable</span></span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者很多时候，并不需要一次性返回一整个数组，而是返回数组中的某一个元素，提供这样细粒度的 API 可能会更方便，而且效率更好更安全</p><h4 id="隐藏实现方式"><a href="#隐藏实现方式" class="headerlink" title="隐藏实现方式"></a>隐藏实现方式</h4><p>信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如<code>public int computeAge()</code> 这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏</p><h3 id="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"><a href="#如果内部数据必须要暴露出来，那么要尽量使可变性最小化" class="headerlink" title="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"></a>如果内部数据必须要暴露出来，那么要尽量使可变性最小化</h3><h4 id="能设计为不可变类就不要设计为可变类"><a href="#能设计为不可变类就不要设计为可变类" class="headerlink" title="能设计为不可变类就不要设计为可变类"></a>能设计为不可变类就不要设计为可变类</h4><p>除非有很好的理由使类成为可变的，不然就应该是不可变的类。构造一个不可变的类遵循相应的规则即可(参考<code>Effective Java</code>)。不可变的类只有一种状态，那就是被创建时的状态；而且不可变的类本质上是线程安全的，不需要同步，可以被自由的共享而不用进行保护性拷贝。对于频繁用到的值，可以使用公有静态 final 常量，或者使用静态工厂替换构造器提供缓存功能。但是不可变类也有缺点，那就是每一个值都是一个对象，有时为了性能和内存考量需要提供可变的配套类，如<code>StringBuilder</code></p><h4 id="能用-final-域就不要不用"><a href="#能用-final-域就不要不用" class="headerlink" title="能用 final 域就不要不用"></a>能用 final 域就不要不用</h4><p>如果类不能做成不可变的，那也要尽可能的降低它的可变性，减少对象可存在的状态，可以更容易的分析它的行为，减少出错的几率。<strong>除非有令人信服的理由，不然所有的域都应该是  final的</strong></p><h4 id="数据修改接口慎重提供"><a href="#数据修改接口慎重提供" class="headerlink" title="数据修改接口慎重提供"></a>数据修改接口慎重提供</h4><p>不要追求 get/set 方法对称的教条，set 方法能不提供就不提供</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于信息隐藏的一些重要知识，很基础但也很重要，通过合理的信息隐藏，我们才能构建出稳健的类和包，<strong>使他们提供尽可能少的开口，以更好的面对变化，不至于失控</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;a href=&quot;#一个重要却容易忽略的问题&quot; class=&quot;headerlink&quot; title=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;/a&gt;一个重要却容易忽略的问题&lt;/h2&gt;&lt;p&gt;在谈到 OOP 时，大家一般会想到&lt;strong&gt;封装，继承和多态&lt;/strong&gt;，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，&lt;strong&gt;信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。&lt;/strong&gt;那信息隐藏为什么如此重要？&lt;/p&gt;
&lt;p&gt;引用一段&lt;code&gt;Effective Java&lt;/code&gt;中的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>回调及在Java中的使用</title>
    <link href="https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-02-10T15:39:14.000Z</published>
    <updated>2020-04-13T04:16:01.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回调是什么"><a href="#回调是什么" class="headerlink" title="回调是什么"></a>回调是什么</h2><p>维基百科的定义如下:</p><blockquote><p>In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.</p></blockquote><p>可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)</p><a id="more"></a><h2 id="回调的过程"><a href="#回调的过程" class="headerlink" title="回调的过程"></a>回调的过程</h2><p>通过上面的定义我们不难得出，使用回调有这么几个步骤：<code>1)定义回调接口/方法；2)注册回调；3)当事件发生时，调用回调方法</code></p><p>本质上来说就是我们利用某种方式(函数指针，lambda 表达式等)，把回调函数像参数一样传入中间函数(Model code as data)，在适当的时机中间函数会调用传入的回调函数。在传入一个回调函数之前，中间函数是不完整的。也就是说程序可以在运行时，通过注册不同的回调函数，来决定、改变中间函数的行为，比简单的函数调用灵活多了，使代码在空间上解耦，如果使用异步回调的话，相当于在时间上也做了解耦。像 Java 中的模版方法模式，观察者模式，策略模式等都使用了回调</p><h2 id="Java中回调的使用"><a href="#Java中回调的使用" class="headerlink" title="Java中回调的使用"></a>Java中回调的使用</h2><p>在 Java 中，因为函数不能作为参数直接传递，我们一般通过定义接口(或者抽象类也可以)的方式来封装方法以实现回调，并且经常结合匿名类表达式(Anonymous class expression)和匿名方法(lambda 表达式)一起使用</p><p>通常先定义一个回调接口，接口中定义需要被回调的方法，然后把该接口作为参数传入需要调用回调方法的中间函数，最后在需要的时候，通过传入实现了该接口的类实例或者直接使用匿名内部类或 lambda 表达式的方式来作为参数传入中间函数，回调接口中定义的回调方法，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallbackInterface</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 定义回调方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testCallback</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间函数，通过 CallbackInterface 接口封装回调方法，作为中间函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCall</span><span class="params">(<span class="keyword">int</span> a, String param, CallbackInterface callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// concrete opearaions...</span></span><br><span class="line">        <span class="comment">// 调用回调方法</span></span><br><span class="line">        callback.testCallback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Caller caller = <span class="keyword">new</span> Caller();</span><br><span class="line">        CallbackInterface callback = <span class="keyword">new</span> CallbackInterfaceImpl();</span><br><span class="line">        <span class="comment">// 1.实现回调接口的类实例注册到中间函数</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, callback);</span><br><span class="line">        <span class="comment">// 2.直接使用匿名类表达式</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, <span class="keyword">new</span> CallbackInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Test Anonymous class and callback."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 3. 使用 lambda 表达式</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, () -&gt; &#123; System.out.println(<span class="string">"Test lambda expression and callback."</span>); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调在设计模式中的应用"><a href="#回调在设计模式中的应用" class="headerlink" title="回调在设计模式中的应用"></a>回调在设计模式中的应用</h2><p>以模版方法模式为例简单说一下，我们都知道模版方法模式的主要思想是<strong>定义出算法的骨架，然后留出扩展点供子类实现</strong>，在抽象父类中，我们通常会设计一些钩子方法，并提供默认实现，并由子类决定是否要进行覆盖，这里的<strong>钩子方法其实就是一种回调方法</strong>，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件（高层组件决定如何使用回调方法）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回调是什么&quot;&gt;&lt;a href=&quot;#回调是什么&quot; class=&quot;headerlink&quot; title=&quot;回调是什么&quot;&gt;&lt;/a&gt;回调是什么&lt;/h2&gt;&lt;p&gt;维基百科的定义如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>反转单链表三种经典的思路</title>
    <link href="https://ryan-hou.github.io/2019/01/20/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>https://ryan-hou.github.io/2019/01/20/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E6%80%9D%E8%B7%AF/</id>
    <published>2019-01-20T13:20:02.000Z</published>
    <updated>2020-04-11T10:17:12.819Z</updated>
    
    <content type="html"><![CDATA[<p>基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路</p><h2 id="头插法构建单链表"><a href="#头插法构建单链表" class="headerlink" title="头插法构建单链表"></a>头插法构建单链表</h2><p>头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 <code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    LinkNode dummy = <span class="keyword">new</span> LinkNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LinkNode cur = <span class="keyword">new</span> LinkNode(head.val);</span><br><span class="line">        cur.next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="指针移动实现反转"><a href="#指针移动实现反转" class="headerlink" title="指针移动实现反转"></a>指针移动实现反转</h2><p>反转一个单链表还有一种很直观的解决方法就是遍历这个单链表，然后依次反转每个需要反转的节点。但是这里存在一个问题，在反转当前节点的时候，当前节点的下一个节点需要先提前保存一下，不然会丢失下一个节点。对于算法的边界，需要考虑链表为空，链表只有一个节点，有两个节点和多于两个节点这几种情况。时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode pre = head;</span><br><span class="line">    LinkNode cur = head.next;</span><br><span class="line">    LinkNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// next 保存指针指向将要反转的节点原本的下一个节点</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// pre, cur 同时后移</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>链表的定义和二叉树类似，也是一个递归的定义，因此使用递归的思路来处理链表也是可行的。反转一个单链表，可以分解为，先反转单链表除了头节点之后的单链表，然后处理反转后的单链表与头节点的关系即可。递归出口是头节点为空或者头节点的下一个节点为空。使用递归这种声明式的实现方式使代码更加简洁，重在描述代码做什么而不是怎么做。空间复杂度为<code>O(n)</code>，时间复杂度为<code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode headOfLeft = reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> headOfLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路&lt;/p&gt;
&lt;h2 id=&quot;头插法构建单链表&quot;&gt;&lt;a href=&quot;#头插法构建单链表&quot; class=&quot;headerlink&quot; title=&quot;头插法构建单链表&quot;&gt;&lt;/a&gt;头插法构建单链表&lt;/h2&gt;&lt;p&gt;头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 &lt;code&gt;O(n)&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; LinkNode &lt;span class=&quot;title&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LinkNode head)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LinkNode dummy = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (head != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LinkNode cur = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(head.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur.next = dummy.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dummy.next = cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head = head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dummy.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="https://ryan-hou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>创建一个对象的思考</title>
    <link href="https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2019-01-01T05:59:25.000Z</published>
    <updated>2020-04-09T09:01:03.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事情可能没有看起来那么简单"><a href="#事情可能没有看起来那么简单" class="headerlink" title="事情可能没有看起来那么简单"></a>事情可能没有看起来那么简单</h2><p>Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？</p><ul><li>创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？</li><li>数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？</li><li>时间: 是立即构建，还是延迟构建呢？</li><li>形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？</li></ul><a id="more"></a><p>以上这些，在不同的场景下，我们需要做不同的考量，本文仅从构造器的弊端来谈一下静态工厂方法，工厂方法模式，抽象工厂模式和 Builder 模式</p><h2 id="构造器有什么问题"><a href="#构造器有什么问题" class="headerlink" title="构造器有什么问题"></a>构造器有什么问题</h2><p>用构造器来创建对象，是很自然也很简单的，大部分场景下直接通过构造器构建对象就足够了。但构造器也存在一些问题，下面具体谈一下</p><h3 id="构造器缺乏表现力"><a href="#构造器缺乏表现力" class="headerlink" title="构造器缺乏表现力"></a>构造器缺乏表现力</h3><p><strong>构造器的名字必须和类名保持一致，缺乏表现力。</strong>而且在构造器参数除了名字不同外(参数类型，个数和顺序完全相同)，会导致构造器的方法签名重复，比如很经典的一个例子就是用 Point 类代表平面坐标系的点，通过构造器提供直角坐标和极坐标的创建方式，代码会出现：<code>Point(double x, double y) 和 Point(double r, double theta)</code> 不仅表现力不足，而且方法签名冲突，我们可以使用<strong>静态工厂方法</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">cartesian</span><span class="params">(<span class="keyword">double</span> x, doubly y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">polar</span><span class="params">(doule r, <span class="keyword">double</span> theta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(r * Math.cos(theta), r * Math.sin(theta));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码可读性要好很多，而且不存在方法签名冲突的问题</p><h3 id="构造器的每次调用都会创建新对象"><a href="#构造器的每次调用都会创建新对象" class="headerlink" title="构造器的每次调用都会创建新对象"></a>构造器的每次调用都会创建新对象</h3><p>通常情况下每次调用构造器都会创建对象（构造器方法里做了自定义的特殊处理不考虑在内），而这并非总是合适的。不公开构造器而是借助静态方法创建对象，可以控制对象的个数。不管是出于管理的原因，如单例模式，还是出于性能的考虑，如对象池技术，这些都是单纯使用构造器做不到的。</p><p>典型的代表就是 JDK 中 Boolean 类提供的 <code>static valueOf(boolean b)</code> 方法，但是该方法提出的比较晚，Boolean 类还是可以用构造器创建多余的对象，因此 <code>valueOf</code> 方法的文档中说明了在大部分场景下应该用该方法替代构造器（除非就是需要创建一个全新的 Boolean 对象）</p><h3 id="构造器无法被继承，也就无法提供多态"><a href="#构造器无法被继承，也就无法提供多态" class="headerlink" title="构造器无法被继承，也就无法提供多态"></a>构造器无法被继承，也就无法提供多态</h3><p><strong>要使用构造器，就要知道具体的类型，这违背了针对接口编程的原则，同时也违背了依赖倒置原则(依赖尽量通过抽象来完成)，当然了这里不能一概而论，如果是依赖像 String 这样稳定的类，也是无可厚非的，但是在实际编程中，考虑减少对具体类的依赖是好的习惯</strong>，这里就可以引出工厂方法模式了</p><p>我们把创建对象的过程封装到工厂中，这实际上就是<strong>保变原则</strong>的使用，提供了一个<strong>中间层</strong>，我们的客户端代码不需要知道对象如何创建，只需要知道我去工厂里拿就可以了，这样将来创建对象的代码发生变化也不会波及客户端代码。同时<strong>工厂方法一般是一个抽象的方法，由工厂的实现类来决定要实例化的具体类是哪个，而且经常结合模版方法模式一起使用</strong>，下面是一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里经常结合模版方法模式提供一个骨架，把可扩展的部分也就是创建对象的代码交由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        pizza  = createPizza(type);</span><br><span class="line">        </span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法,由子类来具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式-抽象工厂模式与-Builder-模式"><a href="#工厂方法模式-抽象工厂模式与-Builder-模式" class="headerlink" title="工厂方法模式/抽象工厂模式与 Builder 模式"></a>工厂方法模式/抽象工厂模式与 Builder 模式</h2><p>有时候我们要创建的对象需要各种组件来构成，这些组件构成一个系列，这里我们可以使用抽象工厂模式来定义一套接口（工厂方法模式只能生产一种产品，抽象工厂模式可以生产一系列产品）。<strong>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族,而不需要明确指定具体类</strong></p><p>与工厂方法模式相比，两种模式都能将对象的创建封装起来，使应用程序解耦，并降低其对特定实现的依赖；但是，<strong>工厂方法使用继承</strong>: 把对象的创建委托给子类，子类实现工厂方法来创建对象；<strong>抽象工厂使用对象组合</strong>: 对象的创建被实现在工厂接口所暴露出的方法中；抽象工厂提供创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法，要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中，部分示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    Veggies[] createVeggies();</span><br><span class="line">    <span class="function">Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体对象的创建通过组合方式传入的具体工厂类来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory pizzaIngredientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = pizzaIngredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原料工厂生产pizza原料,代码中使用抽象类型的接口,把客户从使用的实际具体产品中解耦</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Preparing "</span> + name);</span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式是把一个对象的创建分成不同的组件，而 Builder 模式则是把创建对象分为一系列步骤，两者经常结合使用；Builder 模式不关心中间的过程，只关心最后得到的对象，符合<strong>最少知识原则</strong>，而且可以结合链式调用构造复杂的对象，Builder 模式的基本思路如下：</p><p>定义一个静态内部类，并且静态内部类的内部属性就是我们要赋值的属性。通过各个方法把我们要赋的值封装到静态内部类对象中，返回 <strong>this</strong>，目的是要使用链式的结构；定义一个方法，创建目标对象，并且传入已经封装了各个参数的静态内部类对象。目标类定义一个参数为静态内部类的构造函数；完成创建目标对象，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexObj</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String s1;</span><br><span class="line">    <span class="keyword">private</span> String s2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="comment">// getter methods and other methods...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComplexObj</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s1 = builder.s1;</span><br><span class="line">        <span class="keyword">this</span>.s2 = builder.s2;</span><br><span class="line">        <span class="keyword">this</span>.n1 = builder.n1;</span><br><span class="line">        <span class="keyword">this</span>.n2 = builder.n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String s1;</span><br><span class="line">        <span class="keyword">private</span> String s2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s1</span><span class="params">(String s1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s1 = s1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s2</span><span class="params">(String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s2 = s2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n1</span><span class="params">(<span class="keyword">int</span> n1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n1 = n1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n2</span><span class="params">(<span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n2 = n2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComplexObj <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComplexObj(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of class Builder</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实际调用时就可以通过链式调用，使代码更清晰</span></span><br><span class="line">ComplexObj test = <span class="keyword">new</span> ComplexObj.Builder()</span><br><span class="line">                    .s1(<span class="string">"test"</span>).s2(<span class="string">"ff"</span>).n2(<span class="number">2</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于使用构造器创建对象可能需要思考的各种问题，以及引出的几种设计模式，这里只是做一个介绍，并不是教条；面对不同的使用场景，需要有不同的考量，要做不同的取舍，程序设计也是设计，<strong>做设计就要懂得取舍</strong>，这需要经验，思考和功夫，共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;a href=&quot;#事情可能没有看起来那么简单&quot; class=&quot;headerlink&quot; title=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;/a&gt;事情可能没有看起来那么简单&lt;/h2&gt;&lt;p&gt;Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？&lt;/li&gt;
&lt;li&gt;数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？&lt;/li&gt;
&lt;li&gt;时间: 是立即构建，还是延迟构建呢？&lt;/li&gt;
&lt;li&gt;形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>模版方法模式VS策略模式</title>
    <link href="https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-12-22T14:58:32.000Z</published>
    <updated>2020-04-09T03:25:54.808Z</updated>
    
    <content type="html"><![CDATA[<p>模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述</p><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote><p>在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤</p></blockquote><a id="more"></a><p>模版方法模式符合<strong>好莱坞原则(Don’t call us, we’ll call u.)</strong>，好莱坞原则给我们提供了一种防止”依赖腐败”的方法(代码中的依赖关系尽量要保持单向且不循环)，在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件。换句话说，<strong>高层组件对待低层组件的方式是”别调用我们,我们会调用你”</strong></p><p>模版方法模式也符合<strong>开闭原则(OCP)</strong>，算法骨架保持稳定，对修改封闭；通过子类对扩展保持开放</p><p>下面是<code>Head First 设计模式</code>中的一段代码，代码中有关于如何在抽象基类中定义算法骨架并定义子类扩展点的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverageWithHook</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模版方法,定义算法骨架和子类扩展点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 提供钩子方法,控制部分算法的执行,由子类决定是否覆盖该钩子方法</span></span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 交由不同子类具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Boiling water"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pouring into cup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个钩子方法,通常是空的缺省实现,由子类决定是否覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版方法模式在实际使用中是很广泛的，比如 Spring 框架中 <code>BeanFactory</code> 就使用了该模式，并把 getBean() 方法交给不同的子类具体实现；JDK 中 <code>ThreadPoolExecutor</code> 类的 runWorker() 方法就定义了 <code>beforeExecute</code> 和 <code>afterExecute</code> 钩子方法。在实际工作中，我个人也比较喜欢用这个模式，当存在两个行为类似但又不完全相同的类时，可以考虑提取公共流程和可复用的代码到父类，保留不同的地方作为 abstract 方法，交由不同的子类去实现</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</p></blockquote><p>策略模式重在定义不同的算法(行为)接口，然后为每个接口提供不同的实现类，在客户端代码中，通过组合的方式使用抽象的接口，甚至可以提供动态改变算法策略的 API，利用多态和依赖注射的方式灵活的组合和替换具体的算法</p><h3 id="涉及到的设计原则"><a href="#涉及到的设计原则" class="headerlink" title="涉及到的设计原则"></a>涉及到的设计原则</h3><p><strong>封装变化</strong>: 找出应用中可能会变化的部分，把它们抽象出来，这样系统中该部分改变不会影响其他部分</p><p><strong>针对接口编程而不是针对实现编程</strong>: 这里针对接口编程的真正意思是<strong>针对超类型(supertype)编程。</strong>针对接口编程的精髓在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上（为程序提供了动态性）</p><p><strong>多用组合，少用继承(实现继承)</strong>: “有一个”可能比”是一个”更好。当将两个类组合起来使用时,就是组合(composition)，使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以在”运行时动态的改变行为”</p><p>具体的示例代码建议去看<code>Head First 设计模式</code>一书，清晰易懂</p><p>策略模式在实际应用中也比较广泛，比如在 Netty 中，<code>EventExecutorChooser</code> 作为事件执行器选择策略接口，存在<code>PowerOfTwoEventExecutorChooser</code> 和 <code>GenericEventExecutorChooser</code> 两个具体实现类，<code>DefaultEventExecutorChooserFactory</code> 的 newChooser 方法作为策略选择者，会根据执行器数量是否能被2整数选择具体的策略实现。我自己在实际工作中也用过多次，比如在重构系统中一个关于车辆出库的方法时，该方法会判断不同的出库类型，根据类型不同，执行不同的出库逻辑，整个代码通过 if-else 组合，足足有近千行，而且不同的出库逻辑会根据需求存在变动，每次变动都要修改这里的 if-else 逻辑，维护和测试很不方便。通过抽象出一个出库策略接口，然后为不同的出库方式提供不同的实现，并提供一个根据出库方式选择具体策略实现类的策略者，该方法被简化为只有几十行代码，当出库需求变动时，只需要修改需求变动的出库方式对应的出库策略实现类即可，其他的代码均保持不变，符合开闭原则</p><h2 id="比较两种模式"><a href="#比较两种模式" class="headerlink" title="比较两种模式"></a>比较两种模式</h2><ul><li>策略模式侧重于定义一个<strong>算法家族</strong>，并且让算法可以互换，强调灵活性</li><li>而模版方法模式侧重于定义出<strong>算法骨架</strong>，子类可以通过钩子方法指定部分行为。方便代码复用和框架定义，强调的是算法骨架的稳定性</li><li>策略模式采用组合的方式实现，更加有弹性; 模版方法模式采用继承的方式实现</li></ul><p>最后再举个例子，在 <code>Head Fist 设计模式</code> 中提到，Java <code>Arrays</code>类的排序方法也提供了一种模版方法模式的变式: 在 <code>mergeSort</code> 模版方法中, 依赖于 <code>comparable</code> 接口的 <code>compareTo</code> 方法来完成算法；我认为这里理解为策略模式也是合理的，<code>comparable</code> 可以理解为一个算法家族的接口，可以有不同的实现方法，当 <code>mergeSort</code> 方法接收到此类型的具体参数，实质上就是采用了某个具体的策略。从不同的角度来看，我认为这两种观点都有道理，所以说这两种模式确实存在相似性。还是一贯的观点，编程是一门实践性很强的学科，很多时候死抠概念是没意思的，况且有的概念本身就没有定论，而有自己的思考和想法非常重要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述&lt;/p&gt;
&lt;h2 id=&quot;模版方法模式&quot;&gt;&lt;a href=&quot;#模版方法模式&quot; class=&quot;headerlink&quot; title=&quot;模版方法模式&quot;&gt;&lt;/a&gt;模版方法模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的各种姿势</title>
    <link href="https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/</id>
    <published>2018-12-01T02:58:05.000Z</published>
    <updated>2020-04-08T12:49:13.491Z</updated>
    
    <content type="html"><![CDATA[<p>在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other operatons...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 防止通过反射创建多个实例</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"instance already existed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他初始化操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>优点：实现简单，线程安全(依赖 JVM 在加载这个类时创建唯一的实例)</li><li>缺点：不能延迟初始化(类加载时即创建实例对象，至于类加载时机，虚拟机规范并没有强制约束)，如果该类实例化需要的资源很多，会影响内存和性能</li></ul><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>在 jdk5 之后，通过单元素的枚举可以实现单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 其他实例方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举构造单例，写法简单，线程安全，可以防御反射攻击，并且是序列化/反序列化安全的；但是不能延迟初始化</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span> ? <span class="keyword">new</span> Singleton() : instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持延迟初始化，在使用时才去创建单例实例。但是不能保证线程安全，当有多个线程同时执行 <code>instance == null</code> 时，可能会创建多个实例</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>使用同步方法</li></ul><p>在上面代码的基础上，把 <code>getInstance()</code> 方法加上 synchronized 关键字，变为同步方法，保证了不会同时有多个线程进入这个方法</p><p>优点：简单且有效，而且 JVM 会不断优化 synchronized 关键字的实现方式，如果应用程序可以接受同步的开销，推荐使用</p><p>缺点当然是同步方法带来的开销问题，而且在这里实际上只有第一次执行时才真正需要同步，一旦设置好 instance 变量后，就不再需要同步这个方法了，所以我们有必要寻找更优的线程安全实现</p><ul><li>double-checked locking</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查实例，如果不存在才进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//  再次检查是否存在实例，不存在时才创建实例，避免创建多个实例</span></span><br><span class="line">                    <span class="comment">// volatile 关键字保证了实例化对象的指令不被重排序，避免返回未正确初始化的对象实例</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uniqueInstace;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：通过同步代码块，缩小了同步范围（实例一旦创建便不再需要同步），通过 double-checked 避免了多线程创建多个实例</p><p>缺点：在 jdk5 之前，这种实现方式是错误的，当时的 JVM 对于 volatile 的实现不能保证返回的是正确初始化的对象(jdk5 及之后的版本，volatile 增强了语义，避免了指令重排带来的问题)</p><ul><li>On demand holder idiom</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This code is guaranteed to be correct because of the initialization guarantees</span></span><br><span class="line"><span class="comment">     * for static fields; if a field is set in a static initializer, it it guaranteed</span></span><br><span class="line"><span class="comment">     * to be made visible, correctly, to any thread that accesses that class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过静态字段实例化保证了在实例变量被任何线程访问时返回正确初始化的变量，且静态字段只被初始化一次，满足了线程安全和实例唯一性；又因为静态内部类的加载不需要依附外部类，在使用时才加载，满足了延迟初始化</p><p>总结一下，上述各种单例模式的实现方式说明了<strong>在不同场景和需求下会有不同的设计方案，即使是相同场景下也可能会有不同的设计，而每种设计也存在不同的侧重和取舍</strong>。如果延迟初始化不是我们要考量的问题，推荐使用枚举方式实现单例，否则推荐最后一种实现方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下&lt;/p&gt;
&lt;h2 id=&quot;懒汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式&quot;&gt;&lt;/a&gt;懒汉模式&lt;/h2&gt;&lt;p&gt;因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Other operatons...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 防止通过反射创建多个实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;instance already existed!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://ryan-hou.github.io/2018/11/26/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ryan-hou.github.io/2018/11/26/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-11-26T13:01:39.000Z</published>
    <updated>2020-04-13T10:30:28.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间</p></blockquote><p>举个简单例子，插头与插座，通过电源适配器，可以把插头与本来不相匹配的插座进行适配，这样做的好处显然易见，<strong>既不用重新更换插头，也不用更换插座，只需要使用一个适配器就可以使插头与插座适配工作</strong>，而这也就是适配器模式的设计初衷，通过引入一个中间层，屏蔽底层变动对于上层的影响</p><a id="more"></a><h2 id="为什么需要适配器"><a href="#为什么需要适配器" class="headerlink" title="为什么需要适配器"></a>为什么需要适配器</h2><p>考虑这样的场景，在已有的系统中，希望可以使用不同厂商提供的接口，但是很不幸，这些厂商提供的接口并不完全一致，应该如何处理？</p><p>当然最笨的办法就是，每增加一个厂商，就根据该厂商提供的接口来修改我们的客户端代码，缺点显然易见，客户端代码是面向具体的实现的，耦合性强，违背开闭原则。<strong>通过适配器模式，创建适配器来进行接口转换，让不兼容的接口变的兼容，这样可以让客户端代码从实现中解耦</strong></p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>实际上有两种适配器，类适配器与对象适配器，其中类适配器需要使用多继承实现，在 Java 中没有提供多继承，所以下面主要讲述对象适配器的实现</p><p>对象适配器<strong>使用对象组合</strong>。现在的场景是，厂商提供了接口 A，而我们的客户端代码需要使用接口 B，那么适配器需要做的工作就是把接口 A 转为接口 B，整个实现过程有几个点需要关注：</p><ul><li>适配器要实现接口 B (接口B的所有方法，如果实现不了可以抛出异常)</li><li>把 A 接口的实例对象传入适配器(比如通过构造器的方式)，实现对象的组合</li><li>在适配器中实现 B 接口的方法，实际上是调用 A 接口相应的方法</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>最初 JDK 中提供了枚举器来遍历集合中的元素，如 <code>Vector</code> <code>Hashtable</code> 等都有返回实现 <code>Enumeration</code> 接口的方法，该接口中有 <code>hasMoreElements()</code> 和 <code>nextElement()</code> 方法，而在后期的集合类中使用 <code>Iterator</code> 接口来实现遍历</p><p>面对返回 Enumeration 的遗留代码，我们可以构造一个适配器来完成从 Enumeration 到 Iterator 的转换，从而在客户端代码中统一使用 Iterator 接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationAdapter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Enumeration&lt;E&gt; enumeration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumerationAdapter</span><span class="params">(Enumeration&lt;E&gt; enumeration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enumeration = enumeration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个例子，在 Java 集合类中，Set 接口实现类的内部一般都是直接调用 Map 接口实现类的方法（忽略 Map 接口实现类中的 value 域）。我们可以看到 HashSet 的源码实际上都是在调用 HashMap 的方法，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet 内部通过定义私有成员域 HashMap 来进行适配，把对于 HashSet 的方法调用适配为对 HashMap 方法的调用 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing HashMap instance has default initial</span></span><br><span class="line"><span class="comment"> * capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other operations...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个简单例子，插头与插座，通过电源适配器，可以把插头与本来不相匹配的插座进行适配，这样做的好处显然易见，&lt;strong&gt;既不用重新更换插头，也不用更换插座，只需要使用一个适配器就可以使插头与插座适配工作&lt;/strong&gt;，而这也就是适配器模式的设计初衷，通过引入一个中间层，屏蔽底层变动对于上层的影响&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型与通配符</title>
    <link href="https://ryan-hou.github.io/2018/10/04/Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>https://ryan-hou.github.io/2018/10/04/Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/</id>
    <published>2018-10-04T13:34:50.000Z</published>
    <updated>2020-04-14T07:56:32.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从一个问题说起"><a href="#从一个问题说起" class="headerlink" title="从一个问题说起"></a>从一个问题说起</h2><p>String 类是 Object 类的 subtype，但是 <code>List&lt;String&gt;</code> 却不是  <code>List&lt;Object&gt;</code>的 subtype，为什么？</p><p>最核心的原因在于<strong>不满足里氏替换原则(LSP)</strong>，这就引出了里氏替换原则的定义，简单来说，A 是 B 的子类型当且仅当一个有效的使用了 B 类型的程序，把其中所有的 B 类型换成 A 类型，程序的有效性依然存在，那么类型 A 就是类型 B 的子类型 (<strong>里式替换原则要求所有使用 supertype 的地方都可以透明的使用其 subtype</strong>)</p><a id="more"></a><p>根据里氏替换原则，下面这个有效(可以正确编译)的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doThing</span><span class="params">(List&lt;Object&gt; x)</span> </span>&#123;</span><br><span class="line">    x.add(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>List&lt;Object&gt;</code> 可以正确的被替换为 <code>List&lt;String&gt;</code>,那么 <code>List&lt;String&gt;</code> 就是 <code>List&lt;Object&gt;</code> 的子类型，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doThing</span><span class="params">(List&lt;String&gt; y)</span> </span>&#123;</span><br><span class="line">    y.add(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然上面的代码不能编译通过，也就是说 <code>List&lt;String&gt;</code> 不是 <code>List&lt;Object&gt;</code> 的子类型，那么问题来了，各种参数化类型集合的超类是谁呢？答案是 <code>Collection&lt;?&gt;</code> 念做 <strong>collection of unknow</strong> 其中 <code>?</code> 是一个泛型通配符，可以匹配任何类型，下面展开介绍</p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p><strong>注：任何关于Java语言的概念，最权威的参考一定是 JLS，这里给出链接 <a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html" target="_blank" rel="noopener">Wildcards</a>，下面的内容会参考 JLS 来做说明。</strong></p><p>由上面我们知道了，各种参数化类型集合的超类是 <code>Collection&lt;?&gt;</code>，<strong>?</strong> 就是我们说的通配符，有了这个超类，我们就可以构造一个方法来接收任何参数实例化的 Collection 了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中我们读取集合中的每一个元素时都转为 Object，这样做总是安全的，因为 Object 是任何一个元素类型的超类。但是像下面这样就是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">c.add(<span class="string">"test"</span>); <span class="comment">// Compiler error</span></span><br></pre></td></tr></table></figure><p>因为当类型参数是 <strong>?</strong> 时，代表这是一个未知的类型，所以我们不能向其传入任何类型的参数，只有一个例外，那就是 <code>null</code> (所用引用类型变量的默认值)，后面在说 <strong>&lt;? extends T&gt; vs &lt;? super T&gt;</strong> 时会再谈到</p><h2 id="受限的类型参数"><a href="#受限的类型参数" class="headerlink" title="受限的类型参数"></a>受限的类型参数</h2><p>在实际使用中，我们可能需要限制泛型的类型参数，比如，一个方法接收数字类型的参数，那么就可以把泛型的类型参数限定为 Number 类型或者他的子类型，使用的语法是：<strong>列出该参数的名字，然后跟上 extends 关键字，再跟上 upper bound</strong>，比如： <code>List&lt;T extends Number&gt;</code></p><p><strong>注意，在上面的上下文语境中，extends 既代表类中的 extends，也代表接口中的 implements</strong></p><p>一个类型参数可以同时存在有多个上界，比如：<code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code>, 该类型参数就是 B1，B2 和 B3 的子类型，B1，B2，B3 中只能存在一个 class，且该 class 必须放在第一个位置上</p><p>这里 <code>&amp;</code> 还可以用于返回值中，也只能存在一个 class，比如：<br><code>return (Comparator&lt;T&gt; &amp; Serializable) a</code> 表示 a 被转型为 Comparator <strong>and</strong> Serializable (也就是一个可序列化的比较器)</p><h2 id="lt-T-extends-Comparable-lt-super-T-gt-gt-怎么理解"><a href="#lt-T-extends-Comparable-lt-super-T-gt-gt-怎么理解" class="headerlink" title="&lt;T extends Comparable&lt;? super T&gt;&gt;怎么理解"></a><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code>怎么理解</h2><p>在 <code>Collections.sort</code> 的 javadoc 中我们可以看到这样的签名：<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>，我们可能会有这样的疑问，为什么不写成<code>&lt;T implements Comparable&lt;T&gt;&gt;</code>?</p><p>首先在上面受限的泛型参数中说到 extends 既可以表示 extends 也可以表示 implements；其次，javadoc 中的方法签名表示 T 能够实现 <code>Comparable&lt;? super T&gt;</code> 而不仅仅是 <code>Comparable&lt;T&gt;</code>。举个例子，一个 Student 类可以实现 <code>Comparable&lt;Person&gt;</code>，其中 Student 是 Person 的子类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Other operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person that)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，一个 <code>List&lt;Student&gt;</code> 可以被 Collections.sort() 方法进行排序，但是<strong>只能根据 Person 类的属性</strong>，因为把 Student 实例传入 compareTo 方法中是按照超类型 Person 来处理的(除非你自己 downcast)</p><p>在实际使用中，我们不会用 Student 类来实现 <code>Comparable&lt;Person&gt;</code>，因为 Person 类很可能已经实现了 <code>Comparable&lt;Person&gt;</code> 接口，Student 类会继承该实现，但结果是一样的，你可以把 <code>List&lt;Student&gt;</code> 传给 Collections.sort() 调用，但还是根据 Person 的属性来排序</p><h2 id="lt-extends-T-gt-VS-lt-super-T-gt"><a href="#lt-extends-T-gt-VS-lt-super-T-gt" class="headerlink" title="&lt;? extends T&gt; VS &lt;? super T&gt;"></a>&lt;? extends T&gt; VS &lt;? super T&gt;</h2><p>解释这种用法的最佳例子就是 <code>Collections.copy()</code> 方法:<br><code>public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></p><p>注意到在这个方法签名中，src list 声明为 extends，允许我传入相关的 List 类型的 family，保证会产生类型 T 或者他的子类型，但是不能向 src list 中添加新的元素，因为我们无法确定元素的类型</p><p>dest list 声明为 super, 允许我们传入相关的 List 类型的  family(类型 T 或者其超类)，保证我可以写入一个 T 类型元素到该 list 中。但是不能保证从该 list 中读出的元素是 T 类型的元素</p><p>使用上面的泛型通配符，我们可以用一个方法签名，满足下面不同方法的调用，大大增强了算法的普适性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy(dest, src)</span></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Number&gt;(), <span class="keyword">new</span> ArrayList&lt;Number&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Number&gt;(), <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Object&gt;(), <span class="keyword">new</span> ArrayList&lt;Number&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Object&gt;(), <span class="keyword">new</span> ArrayList&lt;Double&gt;());</span><br></pre></td></tr></table></figure><p>总结来说就是：<strong>PECS（Producer Extends, Consumer Super）</strong>。其中 Producer 和 Consumer 都是相对集合对象自身来说的</p><ul><li>Producer Extends: 如果你需要一个 List 来产生 T 类型的值(也就是说你想从 List 中读取 T 类型的值)，你需要使用 <code>? extends T</code>，即<code>List&lt;? extends T&gt;</code>。但是你不能往该 list 中添加元素</li><li>Consumer Super: 如果你需要一个 List 来消费 T 类型的值(也就是说你想把 T 类型的值写入到 list 中)，你需要使用 <code>？ super T</code>，即 <code>List&lt;? super T&gt;</code>。但是不能保证你从 list 中读取的值的类型是 T</li><li>如果你需要同时从 list 中进行读和写，那么就不要使用通配符，即 <code>List&lt;T&gt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从一个问题说起&quot;&gt;&lt;a href=&quot;#从一个问题说起&quot; class=&quot;headerlink&quot; title=&quot;从一个问题说起&quot;&gt;&lt;/a&gt;从一个问题说起&lt;/h2&gt;&lt;p&gt;String 类是 Object 类的 subtype，但是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 却不是  &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;的 subtype，为什么？&lt;/p&gt;
&lt;p&gt;最核心的原因在于&lt;strong&gt;不满足里氏替换原则(LSP)&lt;/strong&gt;，这就引出了里氏替换原则的定义，简单来说，A 是 B 的子类型当且仅当一个有效的使用了 B 类型的程序，把其中所有的 B 类型换成 A 类型，程序的有效性依然存在，那么类型 A 就是类型 B 的子类型 (&lt;strong&gt;里式替换原则要求所有使用 supertype 的地方都可以透明的使用其 subtype&lt;/strong&gt;)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简谈Java泛型</title>
    <link href="https://ryan-hou.github.io/2018/10/01/%E7%AE%80%E8%B0%88Java%E6%B3%9B%E5%9E%8B/"/>
    <id>https://ryan-hou.github.io/2018/10/01/%E7%AE%80%E8%B0%88Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2018-10-01T13:09:25.000Z</published>
    <updated>2020-04-14T06:28:35.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关术语和入门使用"><a href="#相关术语和入门使用" class="headerlink" title="相关术语和入门使用"></a>相关术语和入门使用</h2><p><strong>关于泛型的几个术语</strong></p><ul><li>ArrayList<e> 中的 <code>&lt;&gt;</code> 念作 <code>typeof</code>，E 称为类型参数变量</e></li><li><code>ArrayList&lt;Integer&gt;</code> 中的 Integer 称为实际类型参数</li><li>整个 <code>ArrayList&lt;E&gt;</code> 称为泛型类型；整个 <code>ArrayList&lt;Integer&gt;</code> 称为参数化的类型</li></ul><p>关于泛型几个需要注意的点: (由于 Java 的泛型采用类型擦除来现实，存在相关问题，后面会继续讨论)</p><a id="more"></a><ul><li>泛型的类型参数必须是引用数据类型</li><li>泛型类型实例化时，两边的实际类型参数必须完全一致，或者一边带实际类型参数，一边不带(&lt;&gt;: the diamond)</li><li>Java 泛型是编译器提供的语法糖，可用于<strong>限定集合的输入类型；让编译器在源码级别上即可防止非法数据的插入</strong>，但是编译生成 class 文件后，将不再存在泛型信息，这个过程叫做<strong>擦除</strong>(在类的元数据中通过反射还可以取到泛型信息，所以我们可以通过反射来绕过泛型)　</li><li>泛型在编译阶段保证了类型安全，在后续使用中也避免了强制类型转换，但牺牲了一定的代码简洁性</li></ul><p><strong>定义泛型方法和泛型类</strong></p><p>使用场景：需要传入或返回一个<strong>暂时未知</strong>的类型，而 Java 中遵循<strong>先定义再使用</strong>，可以通过泛型来解决这个问题</p><p>使用泛型方法可以接收不同类型的参数，返回值不需要强转</p><ul><li>泛型方法</li></ul><p>Java 程序中，普通方法，构造方法和静态方法都可以使用泛型。方法使用泛型前，必须对泛型进行声明，语法为：<code>&lt;T&gt;</code>，T 可以是任意字母，但通常大写，<code>&lt;T&gt;</code> 通常需要放在方法的返回类型之前，如：<code>public &lt;T&gt; T test(T t) { return t; }</code>，这样在调用该方法时，比如 <code>test(&quot;aaa&quot;)</code>，返回值的类型就是 <code>String</code>，不需要强转</p><ul><li>泛型类</li></ul><p>如果在一个类中多次用到同一个泛型参数，就可以把该参数提取到类的定义上来，使用泛型类，比如 JDK 中的 Map 接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A map entry(key-value pair).</span></span><br><span class="line"><span class="comment">     * The Map.entrySet method returns a collection-view</span></span><br><span class="line"><span class="comment">     * of the map, whose elements are of this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举个实际使用的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"first"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"second"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// Use Integer instead of int to avoid NPE</span></span><br><span class="line">    Integer key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要引入泛型"><a href="#为什么要引入泛型" class="headerlink" title="为什么要引入泛型"></a>为什么要引入泛型</h2><p>主要有两方面原因：</p><ul><li>在编译期进行类型检查，比如 <code>ArrayList&lt;Integer&gt;</code> 只能插入 Integer 类型的数据，同时在使用时可以省去强制类型的转换的麻烦（<strong>Stronger type checks at compile time.</strong>）</li><li>更重要的是提供了对于泛型范式的支持，对于一个方法，我们可以抽象出方法的算法骨架，通过泛型的支持，使同一个算法应用到不同的数据类型，增强了方法的普适性，举个例子：</li></ul><p>reverse 数组中的元素(数组的元素可以是字符串类型，Integer 类型等，算法思路：定义首尾两个指针，然后同时移动)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个泛型方法，接收任意类型数组，并颠倒数组中的所有元素</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"arr is null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        T tmp = arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-泛型的问题"><a href="#Java-泛型的问题" class="headerlink" title="Java 泛型的问题"></a>Java 泛型的问题</h2><p>Java 泛型是在 JDK5 中新增的语言特性，为了兼容之前的类库，采用了类型擦除的实现方式(个人觉得这样实现改动最小也是很重要的一个原因，在泛型之前，通过使用共同父类 Object 来实现的容器类运行良好，采用泛型擦除只需要编译器提供自动转换和类型检查的语法糖即可，runtime 不用改动)，这也导致外界对 Java 的泛型实现一直存在批判</p><p>因为采用类型擦除的实现方式，那么一个类的类型参数 E 的实际类型在运行期是被擦除的(全部为 Object 类型，这也是为什么泛型类型参数必须是引用数据类型)，这对于Java 泛型的使用带来了一定的制约，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123;</span><br><span class="line">            <span class="comment">// Compiler error</span></span><br><span class="line">            <span class="comment">// The type used with instanceof has to be reifiable, </span></span><br><span class="line">            <span class="comment">// which means that all information about the type has to be available at runtime</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compiler error</span></span><br><span class="line">        <span class="comment">// You can't create an instance of a type parameter</span></span><br><span class="line">        E item2 = <span class="keyword">new</span> E(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类也不能继承 Throwable 类，因为 catch 语句在运行时无法确定该执行哪个，例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compiler error ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GenericException&lt;Integer&gt;();</span><br><span class="line">&#125; <span class="keyword">catch</span> (GenericException&lt;Integer&gt; e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (GenericException&lt;String&gt; e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型参数也不能用于类中的静态变量，因为泛型类的类型参数可能会对应不同的实际类型参数，而静态变量是一个类的所有实例共享的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Compiler error</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建参数化类型的数组也是非法的：<code>List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</code></p><p>类型擦除会影响方法重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// Compiler error</span></span><br><span class="line">    <span class="comment">// The overloads would all share the same classfile representation and will generate a compile-time error.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多具体内容参见 Oracle 官方文档: <a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html" target="_blank" rel="noopener">Restrictions on Generics</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;相关术语和入门使用&quot;&gt;&lt;a href=&quot;#相关术语和入门使用&quot; class=&quot;headerlink&quot; title=&quot;相关术语和入门使用&quot;&gt;&lt;/a&gt;相关术语和入门使用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关于泛型的几个术语&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList&lt;e&gt; 中的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 念作 &lt;code&gt;typeof&lt;/code&gt;，E 称为类型参数变量&lt;/e&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt; 中的 Integer 称为实际类型参数&lt;/li&gt;
&lt;li&gt;整个 &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 称为泛型类型；整个 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt; 称为参数化的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于泛型几个需要注意的点: (由于 Java 的泛型采用类型擦除来现实，存在相关问题，后面会继续讨论)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
