<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x08 0x17</title>
  
  <subtitle>Build something useful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ryan-hou.github.io/"/>
  <updated>2018-06-20T06:48:00.000Z</updated>
  <id>https://ryan-hou.github.io/</id>
  
  <author>
    <name>0x08 0x17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS解析(2)</title>
    <link href="https://ryan-hou.github.io/2018/06/13/AQS%E8%A7%A3%E6%9E%90-2/"/>
    <id>https://ryan-hou.github.io/2018/06/13/AQS%E8%A7%A3%E6%9E%90-2/</id>
    <published>2018-06-13T06:29:36.000Z</published>
    <updated>2018-06-20T06:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇关于AQS的文章 <a href="https://ryan-hou.github.io/2018/06/12/AQS解析-1/">AQS解析(1)</a> 继续分析，接下来是AQS框架的第二个重要组成部分</p><h3 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h3><p>在 JSR166 之前，除了基于内置的 monitor 的方法外(wait/notify)，Java 没有可用的API用于线程阻塞和唤醒操作来实现同步器。唯一可用的备选方案是 <code>Thread.suspend</code> 和 <code>Thread.resume</code>，但是这两个方法在遇到竞态问题时会出现无法解决的问题，比如：当一个当前未被阻塞的线程在一个线程执行 <code>suspend</code> 方法之前调用 <code>resume</code>  方法，那么这个 <code>resume</code> 方法将没有任何效果(后面提到的 LockSupport 通过给每个线程引入一个permit解决了这个问题)</p><p>j.u.c 包中新增了一个  <code>LockSupport</code> 类提供了线程的 blocking/unblocking 操作(LockSupport: <strong>Basic thread blocking primitives for creating locks and other synchronization classes.</strong>)，推荐去看该类的jdk文档，介绍的很清楚。</p><a id="more"></a><p>该类提供了两个最核心的方法：</p><ul><li>park: 如果当前线程的permit是可用的(available)，那么用掉该permit，并直接返回 ( A thread invoking park on a new synchronizer might return immediately because of a “leftover” unpark from a previous usage. However, in the absence of an unpark, its next invocation will block. )。否则当前线程休眠，直到下面三件事之一发生：1）其它线程对该线程调用了<code>unpark</code>方法;  2)其它线程调用了该线程的 <code>interrupt</code>方法; 3)该调用因为别的未知原因返回(spuriously return)。该方法调用不能表明是因为哪种原因返回的，所以调用者需要自己重新检查 park 返回的原因(通常是通过一个 while 循环)，比如可以检查线程的 <code>interrupt status</code></li><li>unpark: 如果被unpark的线程本身的permit不是available的，那么把该线程的permit置为available。如果该线程处于阻塞状态，则唤醒该线程。不同于 Semaphore，permit 值不会累加，因此在调用park方法之前调用多次unpark方法也只能<code>unblock a single park</code></li></ul><h3 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h3><p>AQS 框架最核心的部分在于维护一个阻塞线程的队列，在AQS中该队列限制为FIFO队列，通过带头节点的基于状态的双链表实现</p><p>对于构建同步队列，大家比较一致的是需要构建非阻塞的数据结构(能提供更好的伸缩性和性能，但同时也带来了实现上的复杂度)，主要有两种方案：MCS锁和CLH锁，CLH锁之前主要用来实现自旋锁，通过改进后，CLH锁可以更好的支持线程取消和超时操作，因而AQS选择了基于CLH锁进行改进</p><p>AQS对于CLH锁的改进主要有两个方面：</p><ul><li>AQS中每个节点需要有个指针指向后继节点(单链表变为双链表)，在自旋锁中，每个节点只需要改变自己的状态，后续的节点在下一次自旋时就会感知到，所以不需要链接后继节点。但是在阻塞同步器中，一个节点需要唤醒(wake up/unpark)她的后继节点。这里有一个地方需要注意，因为我们目前没有相关技术实现原子的无锁的插入双链表节点，所以后继节点的操作不是原子的，只是简单的<code>pred.next = node;</code>，next 链接只是作为优化路径，当我们通过一个节点的next拿不到后继节点时，我们可以在双链表的链尾通过prev指针向前循环来确定是不是该节点的确不存在后继节点</li><li>第二个主要的改进在于，在AQS队列的node中保存的状态status是为了控制blocking而不是spinning。在队列中，只有处于队首的active状态的线程才允许调用 tryAcquire 方法，但是这不需要额外的状态来判断，只需要判断当前节点的前驱节点是不是head即可。取消状态则必须依赖该status。同时节点的status状态可以用来避免不必要的park和unpark操作，在调用park操作前，线程会设置(prodecessor)“signal me”bit，然后在真正调用park操作前，重新检查同步状态和节点status状态；在线程释放锁时，可以根据successor是否设置了 signal bit 来确定对哪个Node节点进行unpark操作；推荐去阅读 AQS 源码中Node的定义和文档，部分重要的数据结构如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h3><p>上面分析了关于AQS最核心的三个组成部分，内容大部分来自 Doug Lea 的论文和部分文档，比较抽象，接下来通过依据AQS框架实现的具体同步器－－<strong>可重入互斥锁ReentrantLock</strong>的代码来具体说明下</p><p>在开始走读代码前，先交代两件事，AQS框架存在<code>exclusive</code>和<code>shared</code> 模式，故名思义，一种模式是互斥模式，一次只能有一个线程可以执行操作；一种是共享模式，可以存在多个线程进行操作，比如读写锁中的读锁；在AQS的队列实现中存在公平和非公平两种策略，非公平策略可以支持更大的吞吐但是对于资源的使用存在不公平，可能导致线程饥饿，下面代码以互斥模式和非公平策略为例，其他实现可以参见相关代码</p><p>先看ReentrantLock 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易看到，类中存在一个sync属性，存在两种不同的实现类，默认是 NonfairSync 类，也就是采用非公平策略实现的排他锁。接下来重点关注lock()方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br></pre></td></tr></table></figure><p>在lock方法中，先进行CAS操作，如果当前同步状态为0，也就是还没有线程获取到锁，尝试用CAS把同步状态变为1，如果成功则表示当前线程获取了锁，并把当前线程设置为Owner，如果失败则调用 acquire(1)，接下来的 acquire方法是核心方法，该方法的方法签名很清楚的说明了该方法的作用</p><p>在 acquire 方法中，先调用 tryAcquire 方法，该方法在 NonfairSync 类中的实现代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码结构很清晰，先获取同步状态c，如果值为0，也就是当前还没有线程获取到锁(也可能是之前有线程释放了锁），尝试通过CAS操作获取锁，如果成功则设置当前线程为Owner，返回true；如果同步状态不为0，判断当前线程是不是Owner，如果是则把同步状态增加acquires，返回true；其它返回false。在外层的 acquire 方法中，如果 tryAcquire 方法返回成功，则不会走 <code>&amp;&amp;</code> 之后的方法；如果 tryAcquire 方法返回false，继续调用后续方法<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code>，先看下方法：<code>addWaiter(Node mode)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把当前线程构建在互斥模式的Node节点中，然后操作入队操作，把该节点放到队尾。在入队时，先把尾节点tail赋给 pred，如果尾节点不为空，先尝试走 fast path，也就是把当前节点的前驱节点指向pred，然后通过CAS操作尝试(在非阻塞的数据结构中各种CAS尝试，毕竟比起内置锁这种重量级操作，CAS还是很划算的)把尾节点设置为node，如果成功，把 pred 的后继节点指向node节点，返回该节点即可(相当于通过CAS线程安全的把该节点插入了队尾)。如果上述操作失败，比如初始情况下，head和tail均为null，直接走入队操作方法<code>enq</code></p><p><code>enq</code>方法的代码如上，也很清晰，通过循环和CAS保证线程安全的在队尾新增加入队节点。最外层死循环保证了在多线程进行操作时，如果CAS操作失败，线程会不断自旋直到操作入队成功，else 分支的操作则通过CAS保证了多线程可以线程安全的入队一个节点(双链表尾插法新增节点)</p><p>节点入队成功后，调用<code>acquireQueued(final Node node, int arg)</code>方法，判断该节点线程是否在头部，能否尝试再次获取锁，或者判断是否需要挂起该线程(调用park方法)，该节点线程可能会被多次阻塞和唤醒，直到成功获取到锁并返回，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看acquireQueued方法，外层是一个死循环，先判断当前节点的前一个节点是不是头节点，如果是的话，尝试获取锁，如果成功，则把当前node节点设置为头节点，把原来头节点的后继指针断开(<strong>实现先进先出操作，队尾入队，队首出队</strong>)，如果失败，调用<code>shouldParkAfterFailedAcquire</code>方法，根据当前节点的前驱节点判断是否需要挂起当前节点的线程，并执行一些其它操作，比如更新节点状态，去除cancelled状态的节点，该方法的源码和注释很清晰不细说。如果判断成功，则执行<code>parkAndCheckInterrupt</code>方法，对当前线程调用park方法。最外层的for循环保证了该节点的线程最终会获取到锁</p><p>以上，lock操作基本分析完毕，简单总结一下，<strong>lock方法先尝试使用CAS获取锁，如果成功，设置当前线程为Owner，如果失败，则调用 acquire 方法，在该方法中，先通过 tryAcquire 方法再次获取锁，依然还是采用CAS操作，该方法实现了线程重入操作；如果获取成功则返回，如果失败，先把该节点线程安全的放置到队尾(CAS+死循环)，并从该队列中调用该节点获取锁(通过死循环，不断判断当前节点是否在队首并尝试获取锁，失败则判断是否需要挂起线程并执行相应操作，一旦挂起后，需要等其它线程对该线程执行唤醒操作，被唤醒继续判断是否处于队首并尝试获取锁，直到成功获取并返回)</strong></p><p>再分析下unlock操作，相对简单多了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很清晰，unlock 操作先尝试释放锁，在<code>tryRelease</code> 方法中，先判断当前线程是不是要释放的锁的owner，如果是则减去传入的参数，判断结果是不是0，如果是的话，说明没有线程再占用该锁(也就是AQS中的同步状态)，返回ture，否则返回false，如果返回ture，则调用<code>unparkSuccessor</code>方法，唤醒队首的节点</p><p>到此 AQS 框架和基于 AQS 实现的同步互斥锁 ReentrantLock 的总结就算结束了，还有很多细节没有整理，推荐去仔细阅读 Doug Lea 的论文，然后结合 jdk 文档和代码进一步加深理解</p><hr><h4 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h4><ul><li><a href="http://ifeve.com/java-special-troops-aqs/" target="_blank" rel="noopener">AQS的原理浅析</a></li><li><a href="http://ifeve.com/reentrantlock-and-fairness/" target="_blank" rel="noopener">ReentrantLock(重入锁)以及公平性</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着上一篇关于AQS的文章 &lt;a href=&quot;https://ryan-hou.github.io/2018/06/12/AQS解析-1/&quot;&gt;AQS解析(1)&lt;/a&gt; 继续分析，接下来是AQS框架的第二个重要组成部分&lt;/p&gt;
&lt;h3 id=&quot;Blocking&quot;&gt;&lt;a href=&quot;#Blocking&quot; class=&quot;headerlink&quot; title=&quot;Blocking&quot;&gt;&lt;/a&gt;Blocking&lt;/h3&gt;&lt;p&gt;在 JSR166 之前，除了基于内置的 monitor 的方法外(wait/notify)，Java 没有可用的API用于线程阻塞和唤醒操作来实现同步器。唯一可用的备选方案是 &lt;code&gt;Thread.suspend&lt;/code&gt; 和 &lt;code&gt;Thread.resume&lt;/code&gt;，但是这两个方法在遇到竞态问题时会出现无法解决的问题，比如：当一个当前未被阻塞的线程在一个线程执行 &lt;code&gt;suspend&lt;/code&gt; 方法之前调用 &lt;code&gt;resume&lt;/code&gt;  方法，那么这个 &lt;code&gt;resume&lt;/code&gt; 方法将没有任何效果(后面提到的 LockSupport 通过给每个线程引入一个permit解决了这个问题)&lt;/p&gt;
&lt;p&gt;j.u.c 包中新增了一个  &lt;code&gt;LockSupport&lt;/code&gt; 类提供了线程的 blocking/unblocking 操作(LockSupport: &lt;strong&gt;Basic thread blocking primitives for creating locks and other synchronization classes.&lt;/strong&gt;)，推荐去看该类的jdk文档，介绍的很清楚。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>AQS解析(1)</title>
    <link href="https://ryan-hou.github.io/2018/06/12/AQS%E8%A7%A3%E6%9E%90-1/"/>
    <id>https://ryan-hou.github.io/2018/06/12/AQS%E8%A7%A3%E6%9E%90-1/</id>
    <published>2018-06-12T02:14:01.000Z</published>
    <updated>2018-06-13T06:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文部分内容来自<code>Doug Lea</code>的论文<code>The java.util.concurrent Synchronizer Framework</code>和 jdk 中相关文档与源码，非常推荐大家去认真读一下这篇论文和相关代码，对AQS这个框架有一个全面的了解</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>AQS即<code>AbstractQueuedSynchronizer</code>，在jdk中大部分的同步器比如<code>locks, barriers, semaphore</code>等都是基于该框架实现的。这个框架提供了一些公共的方法用来<strong>原子化的管理同步状态，阻塞和唤醒线程，以及排队</strong>(这三个部分也是这个框架最核心的三部分组成，后面会逐一分析)。</p><a id="more"></a><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>在 JSR166 中，引入了 j.u.c 包，提供了一系列的并发支持，其中就包括了各种同步器，比如各种形式的互斥锁，读写锁，信号量，barriers，futures，事件指示器和 handoff queues。我们已经知道(有相关的文章可以证明)<strong>基本上任意的同步器都可以被用来实现其他的同步器，例如，我们可以用 reentrant locks 来实现 semaphores，反之也可以。</strong>但是这样做会引入额外的复杂性和开销，而且本身也没有太多合理性，如果这些同步器之间并不存在更基本的和底层的同步器用来实现其他的同步器，那么开发者就不应该被强制选择任意一个作为实现其他同步器的基础。基于此，JSR166中抽象出了一个用来实现大部分同步器以及用户自定义同步器的框架<code>AbstractQueuedSynchronizer</code></p><h3 id="lock-vs-synchronized"><a href="#lock-vs-synchronized" class="headerlink" title="lock vs synchronized"></a>lock vs synchronized</h3><p>这两种使用锁的方式，synchronized 关键字简单安全，能够满足绝大部分场景，并且JVM团队会不断对该关键字的实现提供优化，应该首先考虑。在使用 synchronized 满足不了需求时，考虑使用 Lock来替换，Lock相对于 synchronized 关键字灵活强大但是在使用时需要考虑更多的问题。</p><p>synchronized 语句在源代码被编译成字节码时，会在同步块的入口位置和退出位置分别插入 monitorenter 和 monitorexit 字节码指令(底层实现需要依赖于操作系统的 Mutex Lock 来实现，属于悲观锁，需要把线程从用户态切换到核心态挂起，所以存在一定的性能问题，JVM团队也在针对这部分进行优化)；synchronized方法在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1</p><p>关于Lock和synchronized的对比，推荐<strong>一定要去读一下Lock接口的jdk文档</strong>，写的很清晰，总结下：</p><p>总的来说，Lock 相比 Synchronized更加灵活，支持更灵活的结构，支持更多的属性，支持和多个 Condition 对象绑定，具体如下：</p><ul><li>synchronized 关键字保证了一次只有一个线程可以获取一个对象的 monitor，而Lock的实现除了提供和synchronized一样的互斥访问共享资源的实现，还提供了并发访问共享资源的实现，比如 <code>ReadWriteLock</code>中的读锁</li><li>synchronized 关键字会把没有获取到一个对象monitor的其它线程放置到该对象的同一个wait set，<strong>而Lock对象可以通过<code>Condition</code>来得到多个 wait set，把不同类型的等待线程放到不同的wait set 中</strong>，典型的应用就是在生产者消费者模式下，jdk 中的阻塞队列比如 <code>ArrayBlockingQueue</code> 就是借助了 Lock 和 Condition来实现阻塞操作</li><li>使用synchronized关键字，锁的获取和释放都是采用阻塞的方式，当一个线程获取多个锁后，必须逆序的释放锁，并且锁的获取和释放必须在同一个词法作用域下(这种性质在实际编程中会让代码变得简单，而且不容易出错)。而Lock的实现提供了更多的灵活性，Lock的获取和释放可以在不同的作用域下，也允许多个锁的获取和释放按照任意顺序进行(而这种灵活性实际也带来了复杂性，使用Lock需要确保锁获取后被合理的释放了)</li><li>相比于synchronized关键字的阻塞方式，Lock还提供了 <code>tryLock</code> <code>lockInterruptibly</code> he <code>tryLock(long, TimeUnit)</code> 方法来获取锁</li><li>JVM 团队对于 synchronized 关键字的优化主要在于减少空间开销(因为每一个Java对象都可以作为一个锁，因此实现锁必须尽可能的减少空间占用)和减少大部分单线程使用场景下的时间开销。而这些优化点都不是基于AQS实现的Lock所需要考虑的，AQS主要考虑的点在于<code>scalability</code></li></ul><h3 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h3><p>AQS的核心实现包括三部分内容，接下来我们会一一了解</p><blockquote><ul><li>Atomically managing synchronization state</li><li>Blocking and unblocking threads</li><li>Maintaining queues</li></ul></blockquote><h4 id="Synchronization-State"><a href="#Synchronization-State" class="headerlink" title="Synchronization State"></a>Synchronization State</h4><p>AQS通过一个32位的int属性来维护同步状态，代码为 <code>private volatile int state;</code>，并对外提供了操作同步状态的方法：<code>getState</code>,<code>setState</code> 和 <code>compareAndSetState</code>，其中<code>compareAndSetState</code>通过AQS内部提供的 Unsafe 实例来实现CAS操作，而没有直接使用<code>AtomicInger</code>，至于原因在源码注释中也有说明 <code>or the sake of permitting future enhancements, we cannot explicitly subclass AtomicInteger, which would be efficient and useful otherwise.</code></p><p>使用32位的int值来作为同步状态是出于实用角度的考虑(j.u.c包也提供了支持64位同步状态的<code>AbstractQueuedLongSynchronizer</code>)，一般情况下，用32bit来表示同步状态是足够的，j.u.c 中提供的同步器，只有 <code>CyclicBarrier</code> 需要更多的bit位来维护状态，所以该类通过内部的锁实例(ReentrantLock和Condition)来实现(这也说明了，各种同步器之间其实是可以相互实现的，AQS正是基于此抽象出来的便于实现各种同步器的框架)</p><p>基于AQS的具体实现类，应该根据AQS提供的操作同步状态的方法实现相关的acquire和release方法，比如<code>tryAcquire(由于 j.u.c 包中并没有提供统一的API，acquire操作在不同的类中对应不同的名字，比如 Lock.lock, Semaphore.acquire, CountDownLatch.await, FutureTask.get)</code>,<code>tryRelease</code>。这些方法会接收一个int类型参数用来表明所需要的同步状态值，在可重入锁的实现中，可以用该同步状态值记录锁重入的次数，大部分同步器并不需要显式的由用户提供该值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文部分内容来自&lt;code&gt;Doug Lea&lt;/code&gt;的论文&lt;code&gt;The java.util.concurrent Synchronizer Framework&lt;/code&gt;和 jdk 中相关文档与源码，非常推荐大家去认真读一下这篇论文和相关代码，对AQS这个框架有一个全面的了解&lt;/p&gt;
&lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;p&gt;AQS即&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;，在jdk中大部分的同步器比如&lt;code&gt;locks, barriers, semaphore&lt;/code&gt;等都是基于该框架实现的。这个框架提供了一些公共的方法用来&lt;strong&gt;原子化的管理同步状态，阻塞和唤醒线程，以及排队&lt;/strong&gt;(这三个部分也是这个框架最核心的三部分组成，后面会逐一分析)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>解读Java内存模型(下)</title>
    <link href="https://ryan-hou.github.io/2018/06/04/%E8%A7%A3%E8%AF%BBJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E4%B8%8B/"/>
    <id>https://ryan-hou.github.io/2018/06/04/%E8%A7%A3%E8%AF%BBJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E4%B8%8B/</id>
    <published>2018-06-04T09:58:27.000Z</published>
    <updated>2018-07-19T07:52:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇文章 <a href="https://ryan-hou.github.io/2018/06/04/%E8%A7%A3%E8%AF%BBJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">解读Java内存模型(上)</a> 继续整理Java内存模型相关的重要知识</p><h4 id="incorrectly-synchronized-program"><a href="#incorrectly-synchronized-program" class="headerlink" title="incorrectly synchronized program"></a>incorrectly synchronized program</h4><p>没有正确进行同步的代码对于不同的人来说可能代表不同的事儿，当我们在Java内存模型的上下文中讨论没有正确进行同步的代码时，我们指任何满足下面条件的代码：</p><ul><li>一个线程正在写一个变量</li><li>另外一个线程同时正在读同一个变量</li><li>这两个线程之间的读写操作没有通过同步来保证顺序</li></ul><p>当上面的规则被违背时，我们说那个变量出现了<strong>data race</strong>。一个存在竞态数据的程序是没有正确同步的程序</p><a id="more"></a><h4 id="what-synchronization-does"><a href="#what-synchronization-does" class="headerlink" title="what synchronization does?"></a>what synchronization does?</h4><ul><li>mutual exclusion</li></ul><p>一次只有一个线程可以持有一个monitor，所以在一个monitor上进行同步意味着只有一个线程可以进入被monitor保护的同步块，别的线程都不能进入该monitor保护的代码块直到占有该monitor的线程退出该同步块(注意必须是同一个monitor，比如下面就不行：synchronized(new Object()) {…..}),这段代码其实是没有用的，编译器会直接把这个同步块移除，因为编译器知道没有别的线程可以进入相同的monitor所控制的同步块。我们必须为不同的线程之间设立好 happens-before 关系</p><ul><li>happen before</li></ul><p>同步使得一个线程对内存的写操作对于其他访问同一个monitor的线程可见。当代码退出同步块后，会释放占有的 monitor(锁)，该操作会把线程缓存的数据直接刷新到主内存，所以该线程的写操作对于别的线程是可见的。在我们进入同步块之前，需要现获取monitor，该操作会验证线程中的缓存所以变量会从主内存中reload，这样我们就能看到前一次release操作的所有写操作</p><h4 id="what-is-happen-before"><a href="#what-is-happen-before" class="headerlink" title="what is happen before?"></a>what is happen before?</h4><p>假设A和B分别代表不同线程执行的不同操作，如果A happens-before B，那么A操作带来的内存变化在执行B之前对B操作是可见的。</p><p>新内存模型的语义创建了内存操作(read field, write field, lock, unlock)和一些其他的线程操作(start 和 join)的偏序关系，这其中的一些行为是 happen before 另外的一些行为。<strong>When one action happens before another, the first is guaranteed to be ordered before  and visible to the second.</strong>下面是一些顺序的规则：</p><ul><li>同一个线程内的执行顺序与代码顺序一致</li><li>同一个 monitor 上的解锁操作 happens before 随后的加锁操作</li><li>同一个 volatile 变量的写操作 happens before 随后的读操作</li><li>在一个线程上调用 call 方法 happens before 该启动的线程的后续操作</li><li>一个线程中的所有操作 happens before 任何调用该线程的 join 方法成功返回后的操作</li></ul><p>也即是说所有的内存操作happens before释放锁后的操作，释放锁 happens before 获取该锁的操作(<strong>since all the memory operations happen before the release, and the release happens before the acquire.</strong>)</p><h4 id="volatile-semantic"><a href="#volatile-semantic" class="headerlink" title="volatile semantic"></a>volatile semantic</h4><p>简单说，两个方面：</p><ul><li>内存可见性(内存屏障实现)</li><li>防止指令重排序</li></ul><p>volatile修饰的字段是用来在线程间交流状态的特殊字段。每一个volatile字段的读操作将会看到任何线程上一次对该字段的写操作。因此，他们被设计用来定义不接受因为缓存或者指令重排序而导致的“stale”值的字段</p><p>在新的内存模型下，volatile修饰的变量互相之间仍然不能重排序。不同之处在于现在volatile修饰的字段周围的普通字段的访问也很难存在重排序。volatile字段的写操作和monitor释放有一样的内存影响，volatile字段的读操作和monitor获取有一样的内存影响。<strong>事实上，因为新的内存模型对于volatile字段的访问和其他字段的访问（volatile字段或者普通字段）的指令重排序的限制，对于线程A来说任何对他可见的字段，当他写入一个 volatile 修饰的字段f时，对于随后访问该字段f的线程B，A可见的字段B也都是可见的</strong></p><p>下面的例子说明了volatile字段的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">v = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// uses x - guaranteed to see 42</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，volatile的语义已经被加强到几乎和synchronization 一个级别。<strong>Each read or write of a volatile field acts like “half” a synchronization, for purposes of visibility.</strong></p><p>需要注意的是，<strong>不同的线程需要访问同一个volatile修饰的变量才可以设置相应的 happens-before 关系</strong>。释放和获取操作需要对应起来才行，It is not the case that everything visible to thread A when it writes volatile field f becomes visible to thread B after it reads volatile field g.</p><h4 id="how-final-fields-work-in-JMM"><a href="#how-final-fields-work-in-JMM" class="headerlink" title="how final fields work in JMM?"></a>how final fields work in JMM?</h4><p>一个对象的final字段值在构造器中被赋予，假设这个对象被正确的创建，一但这个对象被创建了：</p><ul><li>在构造器中赋予final字段的值不需要同步操作就可以对所有的线程可见</li><li>此外，任何被final字段引用的对象或者数组的可见值至少会和其他final字段一样新(at least as up-to-date as the final fields.)</li></ul><p>能够看到一个被正确创建的对象的字段值是一件很好的事儿，但是如果字段本身是一个引用，那么你想要看到的是这个引用所指向的对象或者数组的最新的值。如果你的字段是final修饰，那么这就能得到保证。需要强调的是，这里的正确是指“<strong>up to date as of the end of the object’s constructor, not the latest value available.</strong>”</p><p>那么什么叫一个对象被正确的构建呢？<br>简单说就是在构建这个对象时，任何指向该对象的引用不能泄漏出去。换句话说，不要在构建一个对象时把指向该对象的引用放到别的线程可以访问得到的地方；不要把它赋值给静态字段；不要把他作为一个监听器注册到别的对象；<strong>这些操作应该放在对象被构建完成之后，而不是在对象的构建过程中</strong></p><p>即使说了上面这么多，如果想要在一个线程中构建一个不可变对象，你想要确保它能够被所有的其他线程正确的看到，你仍然需要使用同步。举个例子，没有别的方式可以确保一个指向不可变对象的引用对别的线程可见。程序中使用final字段带来的保证需要你对你的并发代码有深刻的理解才行</p><p>使用JNI来改变final字段的值会导致未定义的结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着上一篇文章 &lt;a href=&quot;https://ryan-hou.github.io/2018/06/04/%E8%A7%A3%E8%AF%BBJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/&quot;&gt;解读Java内存模型(上)&lt;/a&gt; 继续整理Java内存模型相关的重要知识&lt;/p&gt;
&lt;h4 id=&quot;incorrectly-synchronized-program&quot;&gt;&lt;a href=&quot;#incorrectly-synchronized-program&quot; class=&quot;headerlink&quot; title=&quot;incorrectly synchronized program&quot;&gt;&lt;/a&gt;incorrectly synchronized program&lt;/h4&gt;&lt;p&gt;没有正确进行同步的代码对于不同的人来说可能代表不同的事儿，当我们在Java内存模型的上下文中讨论没有正确进行同步的代码时，我们指任何满足下面条件的代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个线程正在写一个变量&lt;/li&gt;
&lt;li&gt;另外一个线程同时正在读同一个变量&lt;/li&gt;
&lt;li&gt;这两个线程之间的读写操作没有通过同步来保证顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当上面的规则被违背时，我们说那个变量出现了&lt;strong&gt;data race&lt;/strong&gt;。一个存在竞态数据的程序是没有正确同步的程序&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>解读Java内存模型(上)</title>
    <link href="https://ryan-hou.github.io/2018/06/04/%E8%A7%A3%E8%AF%BBJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ryan-hou.github.io/2018/06/04/%E8%A7%A3%E8%AF%BBJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2018-06-04T05:24:25.000Z</published>
    <updated>2018-06-25T07:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>理解Java内存模型，是更好的学习Java多线程并发和使用相关工具类/关键字的基础，本文主要参考了：<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">JSR 133 (Java Memory Model) FAQ</a> 和 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">The Java Memory Model</a>。非常推荐去看这两份权威文档</p><h3 id="why-should-I-care？"><a href="#why-should-I-care？" class="headerlink" title="why should I care？"></a>why should I care？</h3><p>主要原因在于并发程序很难debug。一般的测试很难发现问题，只有当你的系统负载比较大时问题才会出现，而且很难复现和捕捉。所以最好多花精力让我们的程序能正确的处理同步问题而不是寄希望于debug。 <strong>while this is not easy, it’s a lot easier than trying to debug a badly synchronized application.</strong></p><a id="more"></a><h3 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h3><p>Java内存模型<strong>描述了在多线程环境下什么行为是合法的和不同线程如何通过内存来交互</strong>。他描述了程序中变量之间的关系和从一个实际计算机系统的内存及寄存器中存取变量的底层细节。并在各种硬件及编译器优化中保持这种正确性</p><p>Java中的一些语法结构，包括<code>volatile,finial,和 synchronized</code>被设计用来帮助程序员更好的针对编译器描述关于程序的并发需求。<strong>Java内存模型定义了 volatile 和 synchronized 关键字的行为，更重要的是，保证了Java程序在各种处理器架构下都可以正确的实现同步</strong></p><p>在多处理器系统中，处理器通常会有一层或者多层内存缓存，这些缓存在访问内存数据时可以提高性能(缓存数据离处理器更近)，同时还可以减少共享内存总线的带宽(因为很多操作通过本地缓存就可以完成)。内存缓存极大的提高了性能，但是也带来了问题(计算机的任何问题都可以通过加一个间接层来解决，但同时也会引入新的问题)，比如当两个处理器访问同一个内存地址时，他们会看到一样的值吗？(也就是缓存一致性的问题)</p><p><strong>在处理器层面，内存模型定义了多处理器下，内存数据可见性的问题。</strong>内存模型定义了充分必要的条件来让程序员知道其他处理器写到内存的数据是否对当前处理器可见以及当前处理器写入内存的数据是否对于其他的处理器可见（读写数据的可见性问题）</p><p>有一些处理器使用强一致内存模型，所有的处理器在任何时刻都会看到一致的数据，另外一些处理器则使用了弱一致内存模型，通过特殊的指令 <code>to flush or invalidate the local processor cache</code>(内存屏障)来保证处理器读写内存的可见性。当执行加锁解锁操作时，会用到内存屏障，它们是通过高级的语言特性来对程序员透明的</p><p>一个线程的写操作对于其他的线程是否可见与编译器对于指令的重排序也有关系。例如，当编译器认为把一个写操作放到后面执行会提高程序效率，<code>as long as this code motion does not change the program&#39;s semantics, it is free to do so.</code>。如果编译器推迟了这个写操作，另外的线程在该操作没有执行时就观察不到执行结果，这就好像缓存带来的效果。同理当编译器提前执行一些操作，线程就可能看到一些程序中还没有真实发生的情况。这些都属于设计上的灵活性，在内存模型的限定下，编译器，runtime和硬件决定指令具体的执行顺序来提高程序运行效率</p><h3 id="JSR133"><a href="#JSR133" class="headerlink" title="JSR133"></a>JSR133</h3><blockquote><p>The goal of JSR133 was to create a set of formal semantics that provides an intuitive framework for how volatile, synchronized, and final work</p></blockquote><p>JSR133 主要的目标包括：</p><ul><li>程序员可以很自信的推理出多线程程序和内存的交互</li><li>一个新的安全的初始化操作应该被提供。如果一个对象被合理的构建(合理的构建意思是指在构建期间，对象的引用没有escape)，那么所有的线程不需要同步就可以看到该对象通过构造器中的 final 字段所赋的值</li><li>并发程序的正确语义应该尽可能的简单和符合直觉</li></ul><p>Java 内存模型是很有抱负的，这是第一次由一个编程语言规范来试图给各种架构提供一致的并发语义。不幸的是，定义这么一个一致的而且符合直觉操作的内存模型是一件比想象中更困难的事儿。JSR133 中定义了新的内存模型来修复之前的内存模型的缺陷，为了实现这一点，final 和 volatile 的语义都要发生改变</p><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>在很多场景下，访问一个程序的变量(比如对象实例字段，类字段，数组元素)可能会执行与程序中定义的顺序不同的操作。编译器可以以优化为目的来对指令进行重排序。</p><p>处理器在某些场景下可能会乱序执行指令，数据在寄存器，处理器缓存和主内存中的移动可能会与在程序中定义的顺序不同。有很多可以导致指令重排序的来源，比如编译器，JIT和缓存</p><p>编译器，runtime和硬件应该实现 as-if-serial 语义，也就是说在单线程程序中，程序执行不应该能看到重排序指令带来的影响。然而，在多线程环境下，重排序可能会导致并发程序出现与程序定义的行为不一致的情况。大部分情况下，一个线程不关心其他的线程在干什么，但是一旦他需要关心，这就需要通过来同步保证(single-thread program –&gt; as-if-serial semantic)，multithread program –&gt; synchronization)</p><h4 id="what’s-wrong-with-old-memory-model"><a href="#what’s-wrong-with-old-memory-model" class="headerlink" title="what’s wrong with old memory model?"></a>what’s wrong with old memory model?</h4><p>举个列子，如果字段被final修饰，那么线程之间不需要通过同步来保证可以看到该字段的值，这是一个合理的假设，也是我们希望的结果，然而在旧的内存模型下，并没有这样的保证</p><p>在旧的内存模型下，final字段并没有获得与别的字段不同的对待–也就是说同步是唯一的方式来保证各个线程看到一致的通过构造器赋的final字段值。这导致的结果就是，一个线程可能看到一个字段的默认值，然后又看到了这个字段通过构造器赋的值。举个例子，一个像String这样的不可变对象能够表现出变化的值，这是非常让人困惑的结果</p><p>旧的内存模型允许volatile字段的写操作和非volatile字段的读写操作进行重排序，这会导致开发者对于volatile字段作用的直觉不一致，从而带来困惑</p><p>最终就像我们上面看到的，程序员对于他们的程序是不是正确的同步会出现错误的直觉，JSR-133的目标之一就是来处理这些问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解Java内存模型，是更好的学习Java多线程并发和使用相关工具类/关键字的基础，本文主要参考了：&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JSR 133 (Java Memory Model) FAQ&lt;/a&gt; 和 &lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Java Memory Model&lt;/a&gt;。非常推荐去看这两份权威文档&lt;/p&gt;
&lt;h3 id=&quot;why-should-I-care？&quot;&gt;&lt;a href=&quot;#why-should-I-care？&quot; class=&quot;headerlink&quot; title=&quot;why should I care？&quot;&gt;&lt;/a&gt;why should I care？&lt;/h3&gt;&lt;p&gt;主要原因在于并发程序很难debug。一般的测试很难发现问题，只有当你的系统负载比较大时问题才会出现，而且很难复现和捕捉。所以最好多花精力让我们的程序能正确的处理同步问题而不是寄希望于debug。 &lt;strong&gt;while this is not easy, it’s a lot easier than trying to debug a badly synchronized application.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Using and avoiding null</title>
    <link href="https://ryan-hou.github.io/2018/05/31/Using-and-avoiding-null/"/>
    <id>https://ryan-hou.github.io/2018/05/31/Using-and-avoiding-null/</id>
    <published>2018-05-31T03:18:10.000Z</published>
    <updated>2018-05-31T12:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>不合理的使用null会带来各种可能出现的bug，针对如何合理的使用 null，Google Guava 里给出了一篇很好文档和相应的工具类，这里翻译一下，原文链接：<a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Using and avoiding null</a></p><blockquote><p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p></blockquote><p>(上面给出了两个大神的言论，质疑权威虽然是理工科出身的我们的好习惯，但是很多时候，权威说的话确实值得我们思考)</p><a id="more"></a><p>随意的使用null会带来数量令人吃惊的bug。在研究了Google内部的代码后，我们发现大约在95%的情况下，collections 中不应该有任何的null值，在往collections中添加null时，提供fail fast 而不是默认接受对于开发者来说是很有帮助的</p><p>此外，null值非常有歧义性。很难从返回的null值得到具体的含义－－例如，<code>Map.get(key)</code> 返回null值，既可能是因为该key对应的value是null，也可能是因为该key不存在。Null可以表示失败，可以表示成功，可以表示几乎所有的东西。使用其他的东西而不是null来让你的代码表义清晰</p><p>上面说了，绝大部分情况下都不要随意使用null，也就是说，null在一些场景下的使用也是正确合理的。从内存和速度来说，使用null很廉价，而且在对象数组中是不可避免的。相比类库，在应用代码中，null通常会带来表义不清，从而导致困难和奇葩的bug－－比如，当 <code>Map.get</code> 返回null，它可以表示值不存在或者值存在但是为null。更重要的是，null不会给null值到底意味着什么任何提示</p><p>综上原因，只要存在 null 友好的 workaround，Guava 中的很多工具类对于null值都使用 fail fast 策略而不允许使用null。此外，Guava 提供了很多工具在你必须要使用null时，让使用null更加容易并帮助你避免使用null</p><h3 id="Specific-Cases"><a href="#Specific-Cases" class="headerlink" title="Specific Cases"></a>Specific Cases</h3><p>如果你想要在 <code>Set</code> 或者 <code>Map</code> 的key中使用<br>null，不要这么做！单独定义明确的关于null的 <strong>special-case</strong>会使得在查询操作中代码更加清晰(毫不意外)</p><p>如果你想在<code>Map</code>中使用值为null的value，那么把这个键值对单独定义出来。把<code>Set</code>中非空的key(或者为空的key)单独定义。很容易把Map中不存在某个key和Map中存在某个key，该key对应的value值为null这两种完全不同的情景搞混。把这样的key单独定义出来要好得多，同时这样会让你思考你的应用中一个key对应的value值为空，是怎样的一种场景</p><p>如果你在<code>List</code>中使用null，如果这个List是稀疏的，可能定义一个<code>Map&lt;Integer, E&gt;</code>会让代码更加高效，同时很可能更加符合你的需求</p><p>考虑一下是否存在一个“null object”可以使用，这种情况不总是存在的，但是有些场景，比如一个枚举类可以加一个常量来代表你希望null值所表示的含义。例如，在 <code>java.math.RoundingMode</code> 中有一个 <code>UNNECESSARY</code> 值来表示“do no rounding, and throw an exception if rounding would be necessary.”</p><p>如果你确实需要null值，使用 null-hostile 的集合类存在问题，那么可以使用支持null的集合类实现。比如，使用 <code>Collections.unmodifiableList(Lists.newArrayList())</code> 而不是 <code>ImmutableList</code></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>在很多场景下，我们程序员使用null是用来表示某种缺失：在某个地方可能会存在一个值，但是现在没有或者找不到。比如，<code>Map.get</code>在找不到某个key对应的value值时返回null</p><p><code>Optional&lt;T&gt;</code>是一种把可为空的引用T替换为一个不可为空的值工具类。一个 Optional 要么包含一个非空的引用T(在这种场景下我们说这个引用是<strong>present</strong>的)，要么什么也不包含（在这种场景下，我们说这个引用是<strong>absent</strong>的）。绝不存在<strong>contain null</strong>这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; possible = Optional.of(<span class="number">5</span>);</span><br><span class="line">possible.isPresent(); <span class="comment">// returns true</span></span><br><span class="line">possible.get(); <span class="comment">// returns 5</span></span><br></pre></td></tr></table></figure><p>Optional 并不是作为实现别的语言已经存在的”option”或者”maybe”语言结构而存在的，尽管存在一些相似性</p><p>在下面列一些常用的操作：</p><h4 id="Making-an-Optional"><a href="#Making-an-Optional" class="headerlink" title="Making an Optional"></a>Making an Optional</h4><p>Optional 中的静态方法。</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>Make an Optional containing the given non-null value, or fail fast on null.</td></tr><tr><td>Optional.absent()</td><td>Return an absent Optional of some type.</td></tr><tr><td>Optional.fromNullable(T)</td><td>Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.    </td></tr></tbody></table><h4 id="Query-methods"><a href="#Query-methods" class="headerlink" title="Query methods"></a>Query methods</h4><p>下面是常用的实例方法</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>boolean isPresent()</td><td>Returns true if this Optional contains a non-null instance.</td></tr><tr><td>T get()</td><td>Returns the contained T instance, which must be present; otherwise, throws an IllegalStateException.</td></tr><tr><td>T or(T)</td><td>Returns the present value in this Optional, or if there is none, returns the specified default.</td></tr><tr><td>T orNull()</td><td>Returns the present value in this Optional, or if there is none, returns null. The inverse operation of fromNullable</td></tr><tr><td>Set<t> asSet()</t></td><td>Returns an immutable singleton Set containing the instance in this Optional, if there is one, or otherwise an empty immutable set.</td></tr></tbody></table><p>Optional 还提供了其它有用的方法，具体信息可以去看 Javadoc</p><h4 id="What’s-the-point"><a href="#What’s-the-point" class="headerlink" title="What’s the point?"></a>What’s the point?</h4><p>除了通过给null一个名字来增强可读性，Optional带来的最大好处在于它是 idiot-proof-ness 的，它迫使你去思考 absent 的场景到底是怎样的，否则你的程序可能会编译不过去，因为你必须手动 unwrap the Optional 并处理 absent 的情况。直接使用 null 使这些情况很容易被忽略，尽管 FindBugs 也可以提供帮助，但是我们不认为它能像 Optional 一样解决这个问题</p><p>当返回一个可能存在或者可能不存在的值时，使用Optional 更加有用。对于 <code>other.method(a, b)</code>方法，相比我们在实现这个方法时可能会忘记判断 a 可能为 null 这种情况，我们更容易忘记这个方法可能会返回 null。而返回 Optional 则使调用者不可能忘记处理这种情况，因为他们必须unwrap这个对象来使他们的代码能编译</p><h3 id="Convenience-methods"><a href="#Convenience-methods" class="headerlink" title="Convenience methods"></a>Convenience methods</h3><p>无论何时你想使用一个默认值来代替null，可以使用 <code>MoreObjects.firstNonNull(T, T)</code>。正如该方法的名字所示，如果两个输入都是null，该方法会通过抛出NPE来实现 fail fast。如果你在使用 Optional 对象，那么 first.or(second) 是更好的替代方法</p><p>在<code>Strings</code>类中提供了几个处理可能为空的方法，而且我们专门定义了恰当的名字：</p><ul><li>emptyToNull(String)</li><li>isNullOrEmpty(String)</li><li>nullToEmpty(String)</li></ul><p>我们想强调一下，这些方法主要是用来和那些把 null 字符串和 empty 字符串等同看待的API进行交互。每次你写出把null和empty字符串混用的代码，Guava 团队的小伙伴都哭了(把 null 字符串和 empty 字符串混用通常是令人困惑的 code smell)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不合理的使用null会带来各种可能出现的bug，针对如何合理的使用 null，Google Guava 里给出了一篇很好文档和相应的工具类，这里翻译一下，原文链接：&lt;a href=&quot;https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using and avoiding null&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Null sucks.” -Doug Lea&lt;br&gt;&lt;br&gt;&lt;br&gt;“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(上面给出了两个大神的言论，质疑权威虽然是理工科出身的我们的好习惯，但是很多时候，权威说的话确实值得我们思考)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的各种姿势</title>
    <link href="https://ryan-hou.github.io/2018/04/01/dan-li-mo-shi-de-ge-chong-zi-shi/"/>
    <id>https://ryan-hou.github.io/2018/04/01/dan-li-mo-shi-de-ge-chong-zi-shi/</id>
    <published>2018-04-01T02:58:05.000Z</published>
    <updated>2018-05-17T08:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多场景下，我们的类只允许有一个实例对象，比如线程池，注册表，缓存对象等，这时我们就需要单例模式来创建唯一的对象供程序调用，单例模式是很基础且常用的设计模式，有多种方式实现，下面总结一下</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过new关键字来实例化对象，同时要提供一个静态的访问方法来供应用程序访问该单例，很容易想到的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>优点：实现简单，线程安全(依赖JVM在加载这个类时马上创建此唯一的单例实例，JVM保证了任何线程访问uniqueInstance静态变量之前，一定先创建该实例)</li><li>缺点：不能延迟初始化，如果该类实例化需要的资源很多，会影响性能</li></ul><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>在jdk5之后，我们通过单元素的枚举可以实现单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">Singleton;</span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义 uniqueInstance 变量时不立即初始化，而是在使用时才延迟初始化。缺点是不能保证线程安全，当有多个线程同时执行 <code>if (uniqueInstance == null)</code> 时，可能会创建多个对象实例</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>使用同步方法</li></ul><p>最简单的方式就是在上面代码的基础上，把 getInstance 方法加上 synchronized 关键字，变为同步方法。这样每个线程在进入方法之前，必须先等待别的线程离开，保证了不会同时有多个线程进入这个方法</p><p>优点是：简单且有效，而且 JVM 会不断优化 synchronized 关键字的实现方式，如果应用程序可以接受同步的开销，推荐使用这种方式</p><p>缺点当然是同步方法带来的开销问题，而且在这里实际上只有第一次执行时才真正需要同步，一旦设置好 uniqueInstance 变量后，就不再需要同步这个方法了，所以我们有必要寻找更优的线程安全实现</p><ul><li>double-checked locking</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 检查实例，如果不存在才进入同步块</span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstace == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//  再次检查是否存在实例，不存在时才创建实例</span></span><br><span class="line"><span class="comment">// volatile 关键字保证了实例化对象的指令不被重排序，避免返回未正确初始化的对象实例</span></span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstace;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：通过同步代码块，减少了同步范围，同步double-checked 避免了多线程创建多个实例</p><p>缺点：在jdk5之前，这种实现方式是错误，当时的 jvm 对于 volatile 的实现不能保证返回的是正确初始化的对象</p><blockquote><p>This looks awfully clever – the synchronization is avoided on the common code path. There’s only one problem with it – it doesn’t work. Why not? The most obvious reason is that the writes which initialize instance and the write to the instance field can be reordered by the compiler or the cache, which would have the effect of returning what appears to be a partially constructed Something. <strong>The result would be that we read an uninitialized object.</strong></p></blockquote><blockquote><p><strong>In JVMs prior to 1.5, volatile would not ensure that it worked (your mileage may vary). Under the new memory model, making the instance field volatile will “fix” the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the Something by the constructing thread and the return of its value by the thread that reads it.</strong></p></blockquote><ul><li>On demand holder idiom</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This code is guaranteed to be correct because of the initialization guarantees</span></span><br><span class="line"><span class="comment">     * for static fields; if a field is set in a static initializer, it it guaranteed</span></span><br><span class="line"><span class="comment">     * to be made visible, correctly, to any thread that accesses that class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> LazySingletonHolder.singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码<strong>通过静态字段实例化保证了在实例变量被任何线程访问时返回正确初始化的变量，且静态字段只被初始化一次；使用了延迟初始化同时保证了线程安全</strong></p><p>以上就是实现一个单例模式的6种方法，原理比较简单，但是实现方式是多变的，我们需要根据不同的场景和要求，比如是否需要延迟初始化，是否需要线程安全选择合适的实现方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多场景下，我们的类只允许有一个实例对象，比如线程池，注册表，缓存对象等，这时我们就需要单例模式来创建唯一的对象供程序调用，单例模式是很基础且常用的设计模式，有多种方式实现，下面总结一下&lt;/p&gt;
&lt;h2 id=&quot;懒汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式&quot;&gt;&lt;/a&gt;懒汉模式&lt;/h2&gt;&lt;p&gt;因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过new关键字来实例化对象，同时要提供一个静态的访问方法来供应用程序访问该单例，很容易想到的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton uniqueInstance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; uniqueInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>再谈ThreadLocal</title>
    <link href="https://ryan-hou.github.io/2018/03/23/zai-tan-threadlocal/"/>
    <id>https://ryan-hou.github.io/2018/03/23/zai-tan-threadlocal/</id>
    <published>2018-03-23T06:20:44.000Z</published>
    <updated>2018-05-18T08:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前曾写过关于ThreadLocal的文章<a href="https://ryan-hou.github.io/2017/04/03/threadlocaljie-xi/">ThreadLocal解析</a>，主要从ThreadLocal的一些基本知识和代码实现思路来整理，本文将试着从更加深入的角度来看ThreadLocal以及在使用TreadLocal 中遇到的一些坑</p><h2 id="设计初衷"><a href="#设计初衷" class="headerlink" title="设计初衷"></a>设计初衷</h2><p>一句话：<strong>提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</strong></p><p>稍微展开来说一点，ThreadLocal的作用是提供线程内的局部变量 (类比方法的局部变量)，这种变量在自身线程的生命周期内起作用（其他线程访问不到），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度（同时隔离了多个线程）。</p><p>从上面的设计初衷，我们不难得出ThreadLocal的使用场景：</p><ul><li>在同一个线程中的多个函数需要操作相同的数据，使用线程局部变量(ThreadLocal)可以达到在本线程内的多个函数之间共享数据</li></ul><a id="more"></a><ul><li><strong>为多线程环境常出现的并发访问问题提供了一种隔离机制。</strong>通过ThreadLocal存取的数据，总是与当前线程相关，也就是说，JVM 为每个运行的线程，绑定了私有的本地实例存取空间， 从而为多线程环境常出现的并发访问问题提供了一种隔离机制。(<strong>对于多线程共享资源问题，同步机制采用了”时间换空间”的实现方式，而ThreadLocal采用了“空间换时间”的方式。</strong> 前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。)</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>如果让我们自己来实现一个ThreadLocal，大家应该比较容易想到的方式是实用Map实现，用线程id作为key，线程对应的值作为value。JDK在最早期就是这样实现的，在最新的jdk中使用了新的方式，简单概括下：每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。具体点说就是：</p><ul><li>每个线程都有一个 ThreadLocalMap 类型的 threadLocals 属性</li><li>ThreadLocalMap 类相当于一个Map（<strong>该map底层是由 Entry 数组实现，和HashMap使用链地址法解决冲突不同，ThreadLocalMap使用了开放地址法解决哈希冲突</strong>），<strong>每一个 Entry 封装了 key－value 键值对，key 是 ThreadLocal 本身，value 就是我们的值</strong></li><li>当我们使用 threadLocal.set(new Integer(111)); 我们就会在这个线程中的 threadLocals 属性中放入一个键值对，key 就是这个 threadLocal，value 就是111</li><li>当我们通过 threadlocal.get() 方法的时候，首先会根据这个线程得到这个线程的 threadLocals 属性，然后由于这个属性放的是键值对，我们就可以根据键 threadlocal 拿到值。 注意，<strong>这时候这个键 threadlocal 和 我们 set 方法的时候的那个键 threadlocal 是一样的，所以我们能够拿到相同的值</strong></li></ul><p>通过上面描述我们就会思考，为什么jdk后来采用了新的实现方式，这是一个好问题，我认为一个比较合理的解释方式是使用Map来实现的ThreadLocal需要自己处理线程并发的问题，而使用Thread来维护一个threadLocalMap则不需要；另外当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</p><h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2><p>针对ThreadLocalMap使用弱引用的ThreadLocal来作为key，存在这样一种看法</p><blockquote><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链，永远无法回收，造成内存泄露。</p></blockquote><p>实际上造成ThreadLocal内存泄露的根本原因在于<strong>ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</strong>我们可以针对ThreadLocal使用强引用和弱引用分别来分析(下面分析来自其它博客，原文链接结尾会给出)：</p><blockquote><p>key 使用强引用：<br><br>引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。<br><br>key 使用弱引用：<br><br>引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br><br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</p></blockquote><p>综上，<strong>使用 threadlocal 要注意设置，清理上下文(因为线程池的原因）。每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</strong><br>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。（但是在清理上下文时，要注意会不会把其他业务代码中还在使用的同一个上下文给清理掉？）</p><p>而且JDK建议将ThreadLocal变量定义成<strong>private static</strong>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p><h2 id="ThreadLocal其它要注意的问题"><a href="#ThreadLocal其它要注意的问题" class="headerlink" title="ThreadLocal其它要注意的问题"></a>ThreadLocal其它要注意的问题</h2><p>除了上面说的内存血泄漏问题，每次在使用时要注意设置清理上下文，还有其它要考虑的地方</p><ul><li>ThreadLocal不能解决父子线程传递问题</li></ul><p>JDK提供了<code>InheritableThreadLocal</code>来实现父子线程的传递问题</p><blockquote><p>This class extends ThreadLocal to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values. </p></blockquote><p>当我们创建一个新的线程的时候X，X线程就会有 ThreadLocalMap 类型的 inheritableThreadLocals，因为它是 Thread 类的一个属性。然后，先得到当前线程存储的这些值，例如 Entry[] parentTable = parentMap.table; 再通过一个 for 循环，不断的把当前线程的这些值复制到我们新创建的线程X 的inheritableThreadLocals 中</p><ul><li>在线程池中使用ThreadLocal</li></ul><p>除了要注意设置清理上下文，并且在清理上下文时要注意不要把别的业务还在使用的上下文一起清除掉；还要注意线程池缓存线程带来的 ThreadLocal 取值不是任务提交时值。<strong>对于使用线程池等会缓存线程的组件的情况，线程由线程池创建好，并且线程是缓存起来反复使用的；这时父子线程关系的ThreadLocal值传递已经没有意义，应用需要的实际上是把 任务提交给线程池时的ThreadLocal值传递到 任务执行时。</strong>这时我们可以使用阿里开源的 <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">transmittable-thread-local</a></p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://www.importnew.com/22039.html" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a></li><li><a href="https://stackoverflow.com/questions/17968803/threadlocal-memory-leak" target="_blank" rel="noopener">ThreadLocal &amp; Memory Leak</a></li><li><a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">alibaba/transmittable-thread-local</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前曾写过关于ThreadLocal的文章&lt;a href=&quot;https://ryan-hou.github.io/2017/04/03/threadlocaljie-xi/&quot;&gt;ThreadLocal解析&lt;/a&gt;，主要从ThreadLocal的一些基本知识和代码实现思路来整理，本文将试着从更加深入的角度来看ThreadLocal以及在使用TreadLocal 中遇到的一些坑&lt;/p&gt;
&lt;h2 id=&quot;设计初衷&quot;&gt;&lt;a href=&quot;#设计初衷&quot; class=&quot;headerlink&quot; title=&quot;设计初衷&quot;&gt;&lt;/a&gt;设计初衷&lt;/h2&gt;&lt;p&gt;一句话：&lt;strong&gt;提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;稍微展开来说一点，ThreadLocal的作用是提供线程内的局部变量 (类比方法的局部变量)，这种变量在自身线程的生命周期内起作用（其他线程访问不到），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度（同时隔离了多个线程）。&lt;/p&gt;
&lt;p&gt;从上面的设计初衷，我们不难得出ThreadLocal的使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在同一个线程中的多个函数需要操作相同的数据，使用线程局部变量(ThreadLocal)可以达到在本线程内的多个函数之间共享数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>再谈线程池</title>
    <link href="https://ryan-hou.github.io/2018/03/17/zai-tan-xian-cheng-chi/"/>
    <id>https://ryan-hou.github.io/2018/03/17/zai-tan-xian-cheng-chi/</id>
    <published>2018-03-17T08:21:43.000Z</published>
    <updated>2018-05-18T07:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于线程池的文章，<a href="https://ryan-hou.github.io/2017/03/15/javaxian-cheng-chi-shi-xian-yuan-li/">Java线程池实现原理</a>，侧重于从代码的角度(主要是execute方法的实现)来解释线程池的实现，本文将结合一些例子来谈谈实际使用中遇到的问题，侧重于从使用层面看待线程池</p><h2 id="线程池使用中涉及的重要问题"><a href="#线程池使用中涉及的重要问题" class="headerlink" title="线程池使用中涉及的重要问题"></a>线程池使用中涉及的重要问题</h2><p>还是再强调一下，Executor 和 ThreadPoolExecutor 这两个接口/类，一定去认真读一下jdk文档，写的很好</p><p>先从<code>ThreadPoolExecutor</code>实现的顶层接口<code>Executor</code>来说，该接口设计的目的是为了实现任务提交和任务执行解耦，线程池类ThreadPoolExecutor实现了该接口，因此能将任务的提交与执行进行解耦，不仅如此，通过池化技术，可以控制线程的创建销毁，可以复用线程资源，减少开销，同时提供对于线程等资源的管理</p><a id="more"></a><p><strong>ThreadPoolExecutor构造方法的每一个参数都要清楚的知道他的含义</strong>：<br><code>int corePoolSize, int maximumPoolSize, long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler</code> </p><p>前面四个参数的含义不多说了，可以参考之前那篇文章，重点说一下后面几个：</p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>任务队列（阻塞队列，关于阻塞队列及几个常见的实现类，建议去阅读jdk文档并动手实践下），我们知道当运行的线程大于等于 corePoolSize 时，Executor始终首选将请求加入队列，而不添加新的线程。 在线程池中我们用到的任务队列主要是三类（使用任务队列时要结合线程池的corePoolSize和maximumPoolSize）：</p><ul><li>无界队列：比如不指定大小的LinkedBlockingQueue，有坑，后面再说</li><li>有界队列: 比如ArrayBlockingQueue(FIFO),PriorityBlockingQueue(使用堆实现的经典数据结构)，该类队列的大小需要和最大线程数进行trade-off,阅读jdk文档！</li><li>同步队列：direct handoffs，非常适合用来做要求高响应并且线程数不固定的线程池的Queue</li></ul><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>默认采用 Executors.defaultThreadFactory() ，但是建议自己基于该实现类重新实现ThreadFactory接口，支持自定义线程池名字，这样在出了问题时方便排查问题，而不是一堆类似pool-x-thread-y的线程名字（<strong>虽然看似是个小改动，背后涉及的思想是很根本的，比如命名问题，编程里命名是一件根本的问题，每一个名字都是对一个事物的抽象，要清晰有意义；出了问题如何快速排查，日志怎么打印都是很讲究的</strong>）</p><h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><p>触发场景<code>when  Executor has been shut down, and also when the Executor uses finite bounds for both maximum threads and work queue capacity, and is saturated.</code>，jdk提供了4种策略：</p><ul><li>默认的ThreadPoolExecutor.AbortPolicy策略，直接抛出 RejectedExecutionException</li><li>CallerRunsPolicy，执行execute方法的线程自己执行该任务，<code>This provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted.</code></li><li>DiscardPolicy：直接丢弃任务</li><li>DiscardOldestPolicy：丢弃队首的任务，重新尝试执行</li></ul><h3 id="Hook-method"><a href="#Hook-method" class="headerlink" title="Hook method"></a>Hook method</h3><p>线程池提供了几个Hook方法（<strong>模版方法模式</strong>的典型使用），方便我们自己定义线程执行任务前后进行一些自定义的操作，比如：<code>These can be used to manipulate the execution environment; for example, reinitializing ThreadLocals, gathering statistics, or adding log entries.</code></p><h2 id="实际使用的一些坑"><a href="#实际使用的一些坑" class="headerlink" title="实际使用的一些坑"></a>实际使用的一些坑</h2><h3 id="错误使用Executors的newFixedThreadPool方法导致OOM"><a href="#错误使用Executors的newFixedThreadPool方法导致OOM" class="headerlink" title="错误使用Executors的newFixedThreadPool方法导致OOM"></a>错误使用Executors的newFixedThreadPool方法导致OOM</h3><p>项目代码里使用newFixedThreadPool方法创建线程池来执行任务，因为该方法采用了无界的队列，当任务执行时间过长或者QPS很高导致任务堆积过快，不停地阻塞到队列里，最终导致了OOM。<strong>这其实不仅仅是线程池使用的问题，而是一件更根本的问题，在使用任何有限的资源时，都要有控制资源使用量的意识，比如线程数，队列大小，缓存大小等</strong></p><p>所以阿里的规范手册里有这样一条：</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。</p></blockquote><h3 id="错误使用BlockQueue导致长时间阻塞"><a href="#错误使用BlockQueue导致长时间阻塞" class="headerlink" title="错误使用BlockQueue导致长时间阻塞"></a>错误使用BlockQueue导致长时间阻塞</h3><p>使用BlockQueue既要对容量敏感(不然OOM了就悲剧了)，还要对阻塞操作敏感（下面引用之前看到的一篇文章，文章的出处在结尾给出）:</p><blockquote><p>对于在线业务场景而言，所有的并发，外部访问阻塞的地方的一个真理就是一定要有<strong>超时机制</strong>。我不知道见过多少次由于没有超时造成的在线业务的严重故障，在线业务最强调的是快速处理掉一次请求，所以<strong>fail fast是在线业务系统设计，代码编写中的最重要原则，</strong>按照这个原则上面的代码最起码明显犯的错误就是用put而不是带超时机制的offer，或者说如果是不重要的场景，完全就应该直接用offer，false了直接抛异常或记录下异常即可。<br><br>Java的ThreadPoolExecutor中有个参数是BlockingQueue，如果这个地方用的是ArrayBlockingQueue或LinkedBlockingQueue，而线程池的coreSize和poolSize不一样的话，在coreSize线程满了后，这个时候线程池首先会做的是offer到BlockingQueue，成功的话就结束，这种场景同样不符合在线业务的需求，在线业务更希望的是快速处理，而不是先排队，而且其实在线业务最好是不要让请求堆在排队队列里，在线业务这样做很容易引发雪崩，超出处理能力范围直接拒绝抛错是相对比较好的做法，至于在前面页面上排队什么这个是可以的，那是另外一种限流机制。<br><br>所以说在写高并发、分布式的代码时，除了系统设计外，代码细节的功力是非常非常重要的。</p></blockquote><h3 id="在与ThreadLocal结合使用时也有坑-在后续介绍ThreadLocal的坑时在说明"><a href="#在与ThreadLocal结合使用时也有坑-在后续介绍ThreadLocal的坑时在说明" class="headerlink" title="在与ThreadLocal结合使用时也有坑(在后续介绍ThreadLocal的坑时在说明)"></a>在与ThreadLocal结合使用时也有坑(在后续介绍ThreadLocal的坑时在说明)</h3><hr><p><strong>推荐阅读：</strong></p><ul><li><a href="http://mp.weixin.qq.com/s/7bqeJGPfwylpbhJEeHC1OA" target="_blank" rel="noopener">从一个故障说说Java的三个BlockingQueue</a></li><li><a href="http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5MzYzMzkyMQ==&amp;appmsgid=10000009&amp;itemidx=1&amp;mpshare=1&amp;scene=24&amp;srcid=1213QacIuA7Meq7epXgmCBmR#wechat_redirect" target="_blank" rel="noopener">Java中容易踩到的“坑”系列之线程池篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/32867181" target="_blank" rel="noopener">一次Java线程池误用引发的血案和总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇关于线程池的文章，&lt;a href=&quot;https://ryan-hou.github.io/2017/03/15/javaxian-cheng-chi-shi-xian-yuan-li/&quot;&gt;Java线程池实现原理&lt;/a&gt;，侧重于从代码的角度(主要是execute方法的实现)来解释线程池的实现，本文将结合一些例子来谈谈实际使用中遇到的问题，侧重于从使用层面看待线程池&lt;/p&gt;
&lt;h2 id=&quot;线程池使用中涉及的重要问题&quot;&gt;&lt;a href=&quot;#线程池使用中涉及的重要问题&quot; class=&quot;headerlink&quot; title=&quot;线程池使用中涉及的重要问题&quot;&gt;&lt;/a&gt;线程池使用中涉及的重要问题&lt;/h2&gt;&lt;p&gt;还是再强调一下，Executor 和 ThreadPoolExecutor 这两个接口/类，一定去认真读一下jdk文档，写的很好&lt;/p&gt;
&lt;p&gt;先从&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;实现的顶层接口&lt;code&gt;Executor&lt;/code&gt;来说，该接口设计的目的是为了实现任务提交和任务执行解耦，线程池类ThreadPoolExecutor实现了该接口，因此能将任务的提交与执行进行解耦，不仅如此，通过池化技术，可以控制线程的创建销毁，可以复用线程资源，减少开销，同时提供对于线程等资源的管理&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>重新认识信息隐藏</title>
    <link href="https://ryan-hou.github.io/2018/03/09/zhong-xin-ren-shi-xin-xi-yin-cang/"/>
    <id>https://ryan-hou.github.io/2018/03/09/zhong-xin-ren-shi-xin-xi-yin-cang/</id>
    <published>2018-03-09T11:25:51.000Z</published>
    <updated>2018-05-18T09:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个重要却容易忽略的问题"><a href="#一个重要却容易忽略的问题" class="headerlink" title="一个重要却容易忽略的问题"></a>一个重要却容易忽略的问题</h2><p>在谈到 OOP 的特征时，大家都会想到<strong>封装，继承和多态</strong>，所谓封装，<strong>就是将数据与相关行为包装在一起以实现信息隐藏</strong>，更准确来说，信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。那么信息隐藏为什么重要？</p><p>引用一段<code>Effective Java</code>中的话：</p><blockquote><p>要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信</p></blockquote><a id="more"></a><p>除了设计好的需要公开的API外，其他的成员原则上都要隐藏，<strong>在写代码时要保持有意识的状态，我们写的每一行代码都是一种“承诺”</strong>，如果不能很好的实现信息隐藏，被客户进行操作会导致对象状态的不可控，<strong>轻诺者，必寡信</strong></p><h2 id="封装与访问控制"><a href="#封装与访问控制" class="headerlink" title="封装与访问控制"></a>封装与访问控制</h2><p>谈信息隐藏，自然避不开封装。广义上的封装仅仅只是打包，把一些数据和行为封闭到一个盒子，这个盒子可能是黑盒子也可能是白盒子。相比c语言，Java的封装引入了一种<strong>模块机制</strong>，<strong>把相关的数据和作用在其上的运算捆绑为称为类的模块，从而为域和函数(准确的说应该是成员方法)提供一个上下文。</strong></p><p>我们通常所说的狭义的封装是<strong>指在打包的基础上加上访问控制，以实现信息隐藏</strong>，<strong>访问控制不仅仅是语法的限制，也是语义上的规范</strong>，标有 public 的是接口，标有 private 的是实现；这种语义显然比文档注释更加直观。访问控制是对静态代码的控制，也并非牢不可破，通过反射机制一样可以访问到private成员，这里也引出一个常见的误区，信息隐藏是为了安全性。然而并不是，<strong>信息隐藏通过屏蔽一个模块中非本质，容易变化的部分，从而保证了内部的修改不会波及客户，他的目的是为了提高应变性和灵活性</strong>，通过信息隐藏，一个类也相当于被划分为阴阳两面，阴面的实现对于阳面来说是透明的</p><h2 id="如何更好的隐藏信息"><a href="#如何更好的隐藏信息" class="headerlink" title="如何更好的隐藏信息"></a>如何更好的隐藏信息</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><p>这个很好理解，举个简单例子，把一个类的<code>private</code>成员改为<code>public</code>不会产生问题，如果反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广</p><ul><li>顶层类如果可以包级私有，那就包级私有</li></ul><p>我们通过IDE生成类时，一般会默认用public修饰类，然而这并不合理，一个包中的类大部分都是为本包提供服务的，没有必要作为包的API导出，因为一旦导出，你就要负责一直维护他</p><ul><li>在公有类中使用访问方法而非公有域</li></ul><p><strong>公有类永远都不应该暴露可变的域</strong>。在特殊情况下，暴露公有的静态final域是可以接受的，但是这里的域要么是基本类型，要么是不可变的。很常见的错误就是：<code>public Date getBirthday() { return birthday }</code> 这样即使birthday使用<code>private</code>的访问修饰符，仍然没有用，因为 Date 类不是不可变的，当然了这也是类库设计的缺陷，这里应该提供防御性复制</p><ul><li>警惕长度不为0的数组</li></ul><p><strong>长度不为0的数组总是可变的，类具有公有的静态final数组域或者返回这种域的访问方法，几乎总是错误的</strong>。可以通过把数组域私有，并添加一个公有方法，返回私有数组域的一个备份:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;.....&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line"><span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者有的时候，并不需要一次返回一个数组，而是返回数组的某一个元素，提供这样细粒度的API可能会更方便，而且效率更好</p><ul><li>不要追求get/set对称的教条，set方法能不用就不用</li><li>信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如<code>public int computeAge()</code> 这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏</li><li><strong>使用private不需要理由，不使用才需要理由</strong>，这也是为什么如C#之类的语言默认的访问修饰符是 private（Java默认是包级私有）</li><li>使可变性最小化</li></ul><p>除非有很好的理由使类成为可变的，不然就应该是不可变的类。构造一个不可变的类遵循相应的规则即可(参考<code>Effective Java</code>)。不可变的类只有一种状态，那就是被创建时的状态；而且不可变的类本质上是线程安全的，不需要同步，可以被自由的共享而不用进行保护性拷贝。对于频繁用到的值，可以使用公有静态final常量，或者使用静态工厂替换构造器提供缓存功能。但是不可变类也有缺点，那就是每一个值都是一个对象，有时为了性能需要提供可变的配套类，如<code>StringBuilder</code></p><p>如果类不能做成不可变的，那也要尽可能的降低它的可变性，降低对象可以存在的状态，可以更容易的分析它的行为，减少出错的几率。<strong>除非有令人信服的理由，不然所有的域都应该是final的</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于信息隐藏的一些重要知识，很基础但是也很容易被忽略，通过合理的信息隐藏，我们才能构建稳健的类和包，<strong>使他们提供尽可能少的开口，以更好的面对变化，不至于失控</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;a href=&quot;#一个重要却容易忽略的问题&quot; class=&quot;headerlink&quot; title=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;/a&gt;一个重要却容易忽略的问题&lt;/h2&gt;&lt;p&gt;在谈到 OOP 的特征时，大家都会想到&lt;strong&gt;封装，继承和多态&lt;/strong&gt;，所谓封装，&lt;strong&gt;就是将数据与相关行为包装在一起以实现信息隐藏&lt;/strong&gt;，更准确来说，信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。那么信息隐藏为什么重要？&lt;/p&gt;
&lt;p&gt;引用一段&lt;code&gt;Effective Java&lt;/code&gt;中的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>创建一个对象的思考</title>
    <link href="https://ryan-hou.github.io/2018/03/08/chuang-jian-yi-ge-dui-xiang-de-si-kao/"/>
    <id>https://ryan-hou.github.io/2018/03/08/chuang-jian-yi-ge-dui-xiang-de-si-kao/</id>
    <published>2018-03-08T05:59:25.000Z</published>
    <updated>2018-07-19T07:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事情可能没有看起来那么简单"><a href="#事情可能没有看起来那么简单" class="headerlink" title="事情可能没有看起来那么简单"></a>事情可能没有看起来那么简单</h2><p>Java作为OOP的语言，对象的创建自然是最基本不过的，然而如何创建对象这件事，并没有那么简单，不是 new 关键字加构造器这么容易。那么创建一个对象，我们可能要思考哪些问题呢？</p><ul><li>创建方式，是使用构造器，用工厂类，用Builder，用反射，克隆，还是反序列化呢？</li><li>数量，是构造单例，还是通过对象池构造有限个对象，还是不加限制？</li><li>时间，是立即构建，还是延迟构建呢？</li><li>形式，是构造实际对象，还是构造代理对象？是本地对象，还是远程对象？</li></ul><a id="more"></a><p>以上这些，在不同的场景下，我们都需要做不同的思考，本文从构造器的弊端来谈一下静态工厂方法，工厂方法模式，抽象工厂模式和Builder模式</p><h2 id="构造器的问题在哪里"><a href="#构造器的问题在哪里" class="headerlink" title="构造器的问题在哪里"></a>构造器的问题在哪里</h2><p>用构造器来创建对象，是很自然也很简单的，但是存在一定的问题，下面具体谈一下</p><h3 id="构造器缺乏表现力"><a href="#构造器缺乏表现力" class="headerlink" title="构造器缺乏表现力"></a>构造器缺乏表现力</h3><p><strong>构造器的名字必须和类名保持一致，缺乏表现力。</strong>而且在构造器参数除了名字不同外，会使构造器的方法签名重复，比如，很经典的一个例子就是用 Point 类代表平面坐标系的点，通过构造器提供直角坐标和极坐标的创建方式，代码会出现：<code>Point(double x, double y) 和 Point(double r, double theta)</code> 不仅表现力不足，而且方法签名冲突，我们可以使用<strong>静态工厂方法</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">cartesian</span><span class="params">(<span class="keyword">double</span> x, doubly y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">polar</span><span class="params">(doule r, <span class="keyword">double</span> theta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Point(r * Math.cos(theta), r * Math.sin(theta));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码可读性和直观性都要好很多</p><h3 id="构造器的每次调用都会创建对象"><a href="#构造器的每次调用都会创建对象" class="headerlink" title="构造器的每次调用都会创建对象"></a>构造器的每次调用都会创建对象</h3><p>每次调用构造器都会创建对象，这并总是合适的。不公开构造器而是借助静态方法创建对象，还可以控制对象的个数。不管是出于管理的原因，如单例模式，还是处于性能的考虑，如对象池技术，这都是单纯使用构造器做不到的。典型的代表就是 jdk 中 Boolean 类提供的 <code>valueOf</code> 方法，但是该方法提出的比较晚，Boolean 类还是可以用构造器创建多余的对象，因此在 <code>valueOf</code> 的文档中说明了用该方法替代构造器</p><h3 id="构造器无法被继承，也就无法提供多态"><a href="#构造器无法被继承，也就无法提供多态" class="headerlink" title="构造器无法被继承，也就无法提供多态"></a>构造器无法被继承，也就无法提供多态</h3><p><strong>要使用构造器，就要知道具体的类型，这违背了针对接口编程的原则，同时也违背了依赖倒置原则，当然了这里不能一概而论，如果是依赖像 String 这样稳定的类，也是无可厚非，但是在实际编程中，考虑减少对具体类的依赖是好的习惯</strong>，这里就可以引出工厂方法模式了</p><p>我们把创建对象的过程封装到工厂中，这实际上就是一种<strong>保变原则</strong>的使用，也提供了一种<strong>间接层</strong>，我们的客户端代码不需要知道对象如何创建，只需要知道我去工厂里拿就可以了，这样将来创建对象的代码发生变化也不会波及客户端代码。同时<strong>工厂方法一般是一个抽象的方法，由工厂的实现类来决定要实例化的具体类是哪个，而且经常结合模版方法模式一起使用</strong>，下面是一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"> <span class="comment">//这里经常结合模版方法模式提供一个骨架，把可扩展的部分也就是创建对象的代码交由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        pizza  = createPizza(type);</span><br><span class="line"></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法,由子类来具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式-抽象工厂模式与构造者模式"><a href="#工厂方法模式-抽象工厂模式与构造者模式" class="headerlink" title="工厂方法模式/抽象工厂模式与构造者模式"></a>工厂方法模式/抽象工厂模式与构造者模式</h2><p>有时候我们要创建的对象需要各种组件来构成，这些组件构成一个系列，这里我们可以使用抽象工厂模式来定义一套接口。<strong>抽象工厂模式提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类</strong></p><p>与工厂方法模式相比，两种模式都能将对象的创建封装起来,使应用程序解耦,并降低其对特定实现的依赖；但是，<strong>工厂方法使用继承</strong>: 把对象的创建委托给子类,子类实现工厂方法来创建对象；<strong>抽象工厂使用对象组合</strong>:对象的创建被实现在工厂接口所暴露出得方法中;抽象工厂提供创建一个产品家族的抽象类型,这个类型的子类定义了产品被产生的方法,要使用这个工厂,必须先实例化它,然后将它传入一些针对抽象类型所写的代码中，部分示例代码如下；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    Veggies[] createVeggies();</span><br><span class="line">    <span class="function">Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体对象的创建通过组合的具体工厂类来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory pizzaIngredientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = pizzaIngredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原料工厂生产pizza原料,代码中使用抽象类型的接口,把客户从使用的实际具体产品中解耦</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Preparing "</span> + name);</span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式是把一个对象的创建分成不同的组件，而Builder模式则是把创建对象分为一系列步骤，两者经常结合使用；Builder模式不关心中间的过程，只关心最后得到的对象，符合<strong>最少知识原则</strong>，而且可以结合链式调用构造复杂的对象，Builder模式的基本思路如下：</p><p>定义一个<strong>静态内部类</strong>，并且<strong>静态内部类的内部属性就是我们要赋值的属性</strong>。通过各个方法把我们要赋的值封装到静态内部类对象中，返回 <strong>this</strong>，目的是要使用链式的结构;定义一个方法，创建目标对象，并且传入已经封装了各个参数的静态内部类对象。目标类定义一个参数为静态内部类的构造函数；完成创建目标对象，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexObj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String s1;</span><br><span class="line">    <span class="keyword">private</span> String s2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComplexObj</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s1 = builder.s1;</span><br><span class="line">        <span class="keyword">this</span>.s2 = builder.s2;</span><br><span class="line">        <span class="keyword">this</span>.n1 = builder.n1;</span><br><span class="line">        <span class="keyword">this</span>.n2 = builder.n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String s1;</span><br><span class="line">        <span class="keyword">private</span> String s2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s1</span><span class="params">(String s1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s1 = s1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s2</span><span class="params">(String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s2 = s2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n1</span><span class="params">(<span class="keyword">int</span> n1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n1 = n1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n2</span><span class="params">(<span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n2 = n2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComplexObj <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComplexObj(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在实际调用时就可以通过链式调用，使代码更清晰</span></span><br><span class="line">ComplexObj test = <span class="keyword">new</span> ComplexObj.Builder()</span><br><span class="line">                .s1(<span class="string">"test"</span>)</span><br><span class="line">                .s2(<span class="string">"ff"</span>)</span><br><span class="line">                .n2(<span class="number">2</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于使用构造器创建对象可能需要思考的各种问题，以及引出的几种设计模式，这里只是做一个介绍，并不是教条；面对不同的使用场景，需要有不同的考量，要做不同的取舍，程序设计也是设计，<strong>做设计就要懂得取舍</strong>，这需要经验，思考和功夫，共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;a href=&quot;#事情可能没有看起来那么简单&quot; class=&quot;headerlink&quot; title=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;/a&gt;事情可能没有看起来那么简单&lt;/h2&gt;&lt;p&gt;Java作为OOP的语言，对象的创建自然是最基本不过的，然而如何创建对象这件事，并没有那么简单，不是 new 关键字加构造器这么容易。那么创建一个对象，我们可能要思考哪些问题呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建方式，是使用构造器，用工厂类，用Builder，用反射，克隆，还是反序列化呢？&lt;/li&gt;
&lt;li&gt;数量，是构造单例，还是通过对象池构造有限个对象，还是不加限制？&lt;/li&gt;
&lt;li&gt;时间，是立即构建，还是延迟构建呢？&lt;/li&gt;
&lt;li&gt;形式，是构造实际对象，还是构造代理对象？是本地对象，还是远程对象？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Phantom types in Java</title>
    <link href="https://ryan-hou.github.io/2018/02/20/phantom-types-in-java/"/>
    <id>https://ryan-hou.github.io/2018/02/20/phantom-types-in-java/</id>
    <published>2018-02-20T04:12:36.000Z</published>
    <updated>2018-05-18T03:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为翻译文章，原文链接为：<a href="http://gabrielsw.blogspot.com/2012/09/phantom-types-in-java.html" target="_blank" rel="noopener">Phantom types in Java</a></p><p>相比于Python这种动态类型语言来说，使用Java这种静态语言在有些场景下会让代码显得啰嗦冗长，但是合理的利用静态语言的类型系统，对于写出<strong>更安全且语义更明确</strong>的代码是非常有帮助的，这篇翻译的文章，实际上就是关于如何利用类型系统(Phantom type)来书写更健壮的代码的一个技巧，值得思考和借鉴</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>我喜欢编程语言中的类型，其中一个原因就在于它会帮助我们(尽管有时也有相反的作用，比如相比动态类型语言，类型有时会让代码显得啰嗦)。在编译期能进行的检查越多，在测试时需要做的检查就越少(运行时出错的可能性也就越小)。</p><p>自从Java1.5，我们有了参数化类型(泛型)－－也就是可以把类型参数加到其他类型上：<br><code>public class MyType&lt;TypeParameter&gt; { ... }</code></p><p>我们也可以在方法上使用类型参数:<br><code>public &lt;T&gt; Result doSomething(MyType&lt;T&gt; p) { ... do something with p ... }</code></p><p>或者限制在方法上使用确定的类型参数(也叫 generic type in invocation):</p><p><code>public Result doSomethingStringy(MyType&lt;String&gt; p) {... do something with p ... }</code></p><a id="more"></a><h2 id="A-ghost-in-the-type-machine"><a href="#A-ghost-in-the-type-machine" class="headerlink" title="A ghost in the (type) machine"></a>A ghost in the (type) machine</h2><p>所以，什么是 phantom types 呢？通常来说，当我们在方法参数中使用一个参数化的类型时，在方法体中我们也会使用这个参数化类型(比如，我们有这样一个方法 <code>sum(List&lt;Integer&gt; xs)</code>,我们通常会在方法中计算xs中的整数的和)，但是，如果我们不这样用呢？也就是<strong>我们在方法参数中使用参数化类型来限制传入的参数，进行编译期检查，但是我们在方法体中并不使用这个方法参数，这就是一个  phantom type</strong></p><h2 id="A-simple-example"><a href="#A-simple-example" class="headerlink" title="A simple example"></a>A simple example</h2><p>下面是个例子，让我们实例化一个飞机类型，该飞机对象要么是飞行状态要么是着陆状态，并且提供 takeOff 和 land 方法分别作用于着陆状态和飞行状态的飞机</p><p>首先，我们把不同的飞行状态定义为marker接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlightStatus</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flying</span> <span class="keyword">extends</span> <span class="title">FlightStatus</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Landed</span> <span class="keyword">extends</span> <span class="title">FlightStatus</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的飞机类使用飞行状态来进行参数化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">FlightStatus</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Plane</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// blah blah blah</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Plane</span><span class="params">(Plane&lt;? extends FlightStatus&gt; p)</span> </span>&#123;</span><br><span class="line"><span class="comment">// copy whatever info we need</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Plane&lt;Landed&gt; <span class="title">newPlane</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Plane&lt;Landed&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的 flight controller 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirTrafficController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">pulic <span class="keyword">static</span> Plane&lt;Landed&gt; <span class="title">land</span><span class="params">(Plane&lt;Flying&gt; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Plane&lt;Landed&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Plane&lt;Flying&gt; <span class="title">takeOff</span><span class="params">(Plane&lt;Landed&gt; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Plane&lt;Flying&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Plane&lt;Landed&gt; p = Plane.newPlane();</span><br><span class="line"></span><br><span class="line">Plane&lt;Flying&gt; fly = takeOff(p);</span><br><span class="line">Plane&lt;Landed&gt; land = land(fly);</span><br><span class="line"></span><br><span class="line"><span class="comment">// doesn't compile:</span></span><br><span class="line"><span class="comment">// Plane&lt;Landed&gt; reallyLanded = land(land);</span></span><br><span class="line"><span class="comment">// Plane&lt;Flying&gt; reallyFlying = takeOff(fly);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有意思的地方在于 land 和 takeOff 这两个方法，例如，在land方法中，我们要求传入一个<code>Plane&lt;Flying&gt;</code>但是我们只是返回一个着陆的飞机(而没有在方法体中使用到 Flying 接口)。这就是我们强制要求一个飞机必须是飞行状态的才能够进行着陆操作。我通过这个比较傻的例子就是想说明我们如何使用 phantom types 来进行一些限制和编译检查(enforce some rules)</p><h2 id="What-are-they-good-for"><a href="#What-are-they-good-for" class="headerlink" title="What are they good for?"></a>What are they good for?</h2><p>现在我们有了一种可以在编译时限定类型的类型参数的方法，我们可以用它来做什么呢？实际上我们可以用这种方式来进行很多编译限制来增强代码的安全性和加强语义：比如强制使用一种特定的状态，在上面的例子中，我们使用 phantom types 在方法中强制特定的状态。使用相同的方式，我们可以要求一个连接是打开的当我们需要查询或者关闭它时：</p><p><code>public void close(Connection&lt;Open&gt; c) ....</code></p><p>我们还可以使用 phantom types 来进行更安全的id传参，通常id是int或者String，而且很容易搞混，比如在 buy(String productId, String customId)中，你可以交换两个id从而得到一个很微妙的bug。而使用 Phantom type，我们可以使用不同的实体定义参数化的Id类，得到<code>buy(Id&lt;Product&gt; productId, Id&lt;Customer&gt; customerId)</code>，这样如果我们把两个id再弄混的话，就会得到一个编译错误，下面是一个 Scala 实现的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Id</span>[<span class="type">T</span>&lt;:<span class="type">Entity</span>](<span class="params">id:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">buy</span>(<span class="params">pId:<span class="type">Id</span>[<span class="type">Product</span>], uId:<span class="type">Id</span>[<span class="type">User</span>]</span>) </span>= <span class="string">"Bought product %s for user %s"</span>.format(pId.id,uId.id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pId = <span class="keyword">new</span> <span class="type">Id</span>[<span class="type">Product</span>](<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">val</span> uId = <span class="keyword">new</span> <span class="type">Id</span>[<span class="type">User</span>](<span class="string">"2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">scala&gt; buy(pId,uId)</span></span><br><span class="line"><span class="string">res2: String = Bought product 1 for user 2</span></span><br><span class="line"><span class="string">scala&gt; buy(uId,pId)</span></span><br><span class="line"><span class="string">&lt;console&gt;:16: error: type mismatch;</span></span><br><span class="line"><span class="string"> found   : Id[User]</span></span><br><span class="line"><span class="string"> required: Id[Product]</span></span><br><span class="line"><span class="string">              buy(uId,pId)</span></span><br><span class="line"><span class="string">                  ^</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为翻译文章，原文链接为：&lt;a href=&quot;http://gabrielsw.blogspot.com/2012/09/phantom-types-in-java.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Phantom types in Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相比于Python这种动态类型语言来说，使用Java这种静态语言在有些场景下会让代码显得啰嗦冗长，但是合理的利用静态语言的类型系统，对于写出&lt;strong&gt;更安全且语义更明确&lt;/strong&gt;的代码是非常有帮助的，这篇翻译的文章，实际上就是关于如何利用类型系统(Phantom type)来书写更健壮的代码的一个技巧，值得思考和借鉴&lt;/p&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;我喜欢编程语言中的类型，其中一个原因就在于它会帮助我们(尽管有时也有相反的作用，比如相比动态类型语言，类型有时会让代码显得啰嗦)。在编译期能进行的检查越多，在测试时需要做的检查就越少(运行时出错的可能性也就越小)。&lt;/p&gt;
&lt;p&gt;自从Java1.5，我们有了参数化类型(泛型)－－也就是可以把类型参数加到其他类型上：&lt;br&gt;&lt;code&gt;public class MyType&amp;lt;TypeParameter&amp;gt; { ... }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们也可以在方法上使用类型参数:&lt;br&gt;&lt;code&gt;public &amp;lt;T&amp;gt; Result doSomething(MyType&amp;lt;T&amp;gt; p) { ... do something with p ... }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者限制在方法上使用确定的类型参数(也叫 generic type in invocation):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public Result doSomethingStringy(MyType&amp;lt;String&amp;gt; p) {... do something with p ... }&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Efficient data transfer through zero copy</title>
    <link href="https://ryan-hou.github.io/2017/11/27/efficient-data-transfer-through-zero-copy/"/>
    <id>https://ryan-hou.github.io/2017/11/27/efficient-data-transfer-through-zero-copy/</id>
    <published>2017-11-27T09:03:56.000Z</published>
    <updated>2018-05-18T15:24:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为翻译文章，原文链接为:<a href="https://www.ibm.com/developerworks/library/j-zerocopy/" target="_blank" rel="noopener">Efficient data transfer through zero copy</a></p><p>许多web应用都会提供从磁盘读取大量的静态数据，然后再把这些数据写到 response socket 中。这种服务看起来几乎不会用到 cpu 计算，但是这里却存在不高效的情况：内核从磁盘读取数据后，会把它通过kernel-user边界push到应用，然后再通过kernel-user边界push回socket buffer供socket写出。实际上，这里应用层成了磁盘和socket之间一个低效的中间介质</p><p>每次数据通过kernel-user边界时，必须被复制，这就会消耗cpu cycles 和内存带宽。幸运的是，我们可以通过<code>zero copy</code>技术来消除这些拷贝。<strong>使用 zero copy技术，应用可以直接把磁盘数据移动到socket，不需要经过应用</strong>。zero copy 技术很大的提升了应用性能并且减少了kernel和user模式的切换</p><p>Java 类库通过 <code>java.nio.channels.FileChannel</code>类的<code>transferTo()</code>方法支持在 Linux 和 Unix操作系统上的zero copy技术。你可以使用 transferTo() 方法把字节流从调用这个方法的 channel直接移动到另一个可写的字节channel，不需要数据经由应用。本文首先会证明使用传统的复制语义会带来 overhead，然后展示使用zero copy技术的transferTo()方法如何实现更好的性能</p><a id="more"></a><h2 id="Date-transfer-The-traditional-approach"><a href="#Date-transfer-The-traditional-approach" class="headerlink" title="Date transfer: The traditional approach"></a>Date transfer: The traditional approach</h2><p>考虑这样一个场景：从文件中读取数据然后通过网络把数据转移到另一个程序中(这个场景描述了很多服务应用的行为，包括提供静态内容的web应用，FTP服务器，邮件服务等)，这个操作的核心代码如下 Listing1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing1.Copying bytes from a file to a socket</span></span><br><span class="line">File.read(fileDesc, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br></pre></td></tr></table></figure><p>尽管Listing1在概念上看起来很简单，在内部，这个copy操作需要在 user模式和kernel模式间转换4次，同时数据也需要4次。下面Figure1展示了数据是如何从文件移动到socket的：</p><p>Figure1.Traditional data copying approach</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure1.png" alt></p><p>Figure2展示了上下文的切换：</p><p>Figure2.Traditional context switches</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure2.png" alt></p><p>涉及到的步骤如下：</p><ol><li>read() 调用会导致图二中从用户模式到内核模式的切换。Figure1中的第一次复制是通过DMA（Direct Memory Access），从磁盘中读取文件内容然后保存到内核地址空间的buffer</li><li>请求的数据从 read buffer被复制到user buffer，然后read() 调用返回。从call调用返回导致上下文从kernel态切换回用户态。现在数据保存在用户地址空间的buffer</li><li>socket的send()方法调用使用户态再一次切换到kernel态，第三次拷贝再一次把数据复制到内核地址空间的buffer，但是这一次数据被放在了不同的buffer，这个buffer与目标socket相关联</li><li>send()系统调用返回，导致第四次上下文切换，第四次拷贝发生在DMA引擎把数据从内核buffer传递到protocol引擎</li></ol><p>使用间接的内核buffer(而不是直接把数据转移到用户buffer)看起来是很低效的。但是内核缓存被引入进程却提高了性能，使用间接的缓存在读取数据量不大于缓存容量的数据时，可以把应用数据缓存到内核buffer作为“readahead cache”，这会很好的提高性能。同时该中间缓存允许写数据实现异步</p><p>不幸的是，<strong>当请求的数据比内核buffer的容量大很多时，这种方式就变成了性能瓶颈</strong>。数据在磁盘，内核buffer，用户buffer，与应用之间被复制了多次</p><p><strong>Zero copy通过消除这些冗余的数据拷贝来提升性能</strong></p><h2 id="Data-transfer-The-zero-copy-approach"><a href="#Data-transfer-The-zero-copy-approach" class="headerlink" title="Data transfer: The zero-copy approach"></a>Data transfer: The zero-copy approach</h2><p>如果你再看一下上面传统的复制方式，你会注意到第二次和第三次的数据拷贝并不是必须的。应用除了缓存数据然后把数据移动到socket buffer外，什么也没有做。事实上，数据可以从read buffer直接移动到socket buffer。transferTo() 方法就是这样做的。Listing2 展示了该方法签名:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing2. The transferTo() method</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> posiiton, <span class="keyword">long</span> count, WritableByteChannel target)</span></span>;</span><br></pre></td></tr></table></figure><p>transferTo()方法把数据从文件 channel转移到一个可写的字节channel，他依赖于底层的操作系统支持zero copy；在Unix和各种 Linux系统中，通过 <code>sendfile()</code>方法调用来实现，在 Listing3中展示了数据从一个文件 descriptor转移到另一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>在Listing1中的<code>file.read()</code>和<code>socket.send()</code>调用可以被Listing4中的一个transferTo()调用替换:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferTo(position, count, writableChannel);</span><br></pre></td></tr></table></figure><p>Figure3展示了当transferTo()方法被调用时数据的移动：</p><p>Figure3.Data copy with transferTo()</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure3.png" alt></p><p>Figure4展示了transferTo方法调用时上下文的切换</p><p>Figure4. Context switching with transferTo()</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure4.png" alt></p><p>在Listing4中使用transferTo()方法时的步骤为：</p><ol><li>transferTo方法使文件内容通过DMA被拷贝到read buffer，然后数据再被内核拷贝到与输出socket相关的内核buffer</li><li>第三次拷贝发生在DMA把数据从内核socket buffer传递到protocol引擎</li></ol><p>上面的操作发生了如下改进：我们把上下文切换从四次减少到了两次，把数据拷贝从四次减少到了三次（只有一次需要cpu参与）。但是这还没有到达我们zero copy的目标，我们可以进一步减少数据复制如果底层的网络接口支持<code>gather operations</code>。在Linux2.4及以后的内核版本中，socket buffer descriptor被修改用来支持该操作。这不仅减少了上下文的切换，而且消除了需要cpu参与的那次内存复制。客户端的使用保持不变，但是内在的操作发生了变化：</p><ol><li>transferTo() 方法使文件内容通过DMA被拷贝到内核buffer</li><li>没有数据被拷贝到socket buffer。相应的，只有带有关于数据位置和数据长度信息的descriptors被append到socket buffer。DMA直接把数据从内核缓存传递到protocol引擎，因此消除了仅有的那一次cpu拷贝</li></ol><p>Figure5展示了使用 gather operation的transferTo方法的数据拷贝过程：</p><p>Figure5. Data copies when transferTo() and gather operations are used</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure5.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为翻译文章，原文链接为:&lt;a href=&quot;https://www.ibm.com/developerworks/library/j-zerocopy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Efficient data transfer through zero copy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;许多web应用都会提供从磁盘读取大量的静态数据，然后再把这些数据写到 response socket 中。这种服务看起来几乎不会用到 cpu 计算，但是这里却存在不高效的情况：内核从磁盘读取数据后，会把它通过kernel-user边界push到应用，然后再通过kernel-user边界push回socket buffer供socket写出。实际上，这里应用层成了磁盘和socket之间一个低效的中间介质&lt;/p&gt;
&lt;p&gt;每次数据通过kernel-user边界时，必须被复制，这就会消耗cpu cycles 和内存带宽。幸运的是，我们可以通过&lt;code&gt;zero copy&lt;/code&gt;技术来消除这些拷贝。&lt;strong&gt;使用 zero copy技术，应用可以直接把磁盘数据移动到socket，不需要经过应用&lt;/strong&gt;。zero copy 技术很大的提升了应用性能并且减少了kernel和user模式的切换&lt;/p&gt;
&lt;p&gt;Java 类库通过 &lt;code&gt;java.nio.channels.FileChannel&lt;/code&gt;类的&lt;code&gt;transferTo()&lt;/code&gt;方法支持在 Linux 和 Unix操作系统上的zero copy技术。你可以使用 transferTo() 方法把字节流从调用这个方法的 channel直接移动到另一个可写的字节channel，不需要数据经由应用。本文首先会证明使用传统的复制语义会带来 overhead，然后展示使用zero copy技术的transferTo()方法如何实现更好的性能&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="OS" scheme="https://ryan-hou.github.io/tags/OS/"/>
    
      <category term="优化" scheme="https://ryan-hou.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>important conceptions in language</title>
    <link href="https://ryan-hou.github.io/2017/09/30/basic-but-important-conception-in-language/"/>
    <id>https://ryan-hou.github.io/2017/09/30/basic-but-important-conception-in-language/</id>
    <published>2017-09-30T06:21:37.000Z</published>
    <updated>2018-05-25T07:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些非常基础容易忽视但是却很重要的语言概念，概念不是教条，但是对概念有一个清晰的认识是一件好事。内容大部分来自 Oracle 官方文档的翻译和对维基百科的翻译。会给出链接，需要详细信息的可以自行查阅</p><h2 id="Expression-Statements-Blocks"><a href="#Expression-Statements-Blocks" class="headerlink" title="Expression, Statements, Blocks"></a>Expression, Statements, Blocks</h2><blockquote><p>Operators may be used in building expressions, which compute values; expressions are the core componens of statements; statements may be grouped into blocks.</p></blockquote><h3 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h3><p>一个表达式是由各种变量，操作符和方法调用按照语言提供的语法规则构成，<strong>并且可以计算得到一个值。</strong>表达式得到的值的类型根据表达式中的元素推导出。比如表达式 <code>cadence = 0</code> 返回 int 类型的数据，因为赋值操作符返回一个相同的数据类型给操作符左边的操作数。在这个例子中，cadence 是一个 int 类型数据</p><p>Java 编程语言允许你通过各种更小的表达式来构造复合的表达式，只要表达式的返回类型互相匹配即可。比如<code>1 * 2 * 3</code> 就是一个比较简单的复合表达式</p><p><strong>在书写复合表达式时，通过使用括号来明确的指定各运算符的优先顺序会使代码更加易读和可维护。把复杂的表达式拆分成简单的表达式并用合适的变量定义也是很好的代码重构手段</strong></p><a id="more"></a><h3 id="Statements"><a href="#Statements" class="headerlink" title="Statements"></a>Statements</h3><p>Statements 可以大致类比为自然语言中的句子，一个 Statement 构成一个完整的执行单元。下面的表达式通过在表达式末尾增加一个分号<code>;</code>就可以构成一个 statement：</p><ul><li>赋值表达式</li><li>使用 ++ 或者 –  的表达式</li><li>方法调用</li><li>对象创建表达式</li></ul><p>这些 Statements 就叫做 <code>expression statements</code>。下面就是一些表达式Statements的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assignment statement</span></span><br><span class="line">aValue = <span class="number">9999.1</span>;</span><br><span class="line"><span class="comment">// increment statement</span></span><br><span class="line">aValue++;</span><br><span class="line"><span class="comment">// method invocation statement</span></span><br><span class="line">System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line"><span class="comment">// object creation statement</span></span><br><span class="line">Bicycle myBike = <span class="keyword">new</span> Bicycle();</span><br></pre></td></tr></table></figure><p>除了表达式语句，还有两种类型的语句：声明语句和控制流语句。一个声明语句声明一个变量。你早已经见过了很多声明语句了： <code>double aValue = 11.2; // // declaration statment</code>最后就是控制流statements了，用来控制statements的执行顺序。</p><p>文件中的 statements 通常是按照他们在文件中出现的顺序来执行的。然而，控制流statements <strong>通过决定，循环和分支来打破原来的流程，使你的程序可以按条件来执行特定的代码块。</strong>控制流语句包括了 decision-making statements（<strong>if-then,if-then-else,switch</strong>），the looping statements(<strong>for, while, do-while</strong>)和 the branching statements(<strong>break, continue, return</strong>)</p><h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><blockquote><p>A block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.</p></blockquote><p>举个例子来解释blocks的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> condition = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123; <span class="comment">// begin block 1</span></span><br><span class="line">System.out.println(<span class="string">"Condition is true"</span>);</span><br><span class="line">&#125; <span class="comment">// end block one</span></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// begin block 2</span></span><br><span class="line">System.out.println(<span class="string">"Condition is false"</span>);</span><br><span class="line">&#125; <span class="comment">// end block 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>在计算机编程中，命名绑定(name binding－名字和实体的关联(比如变量和绑定的值))的scope是程序中的一个范围，在这个范围内该绑定是有效的：可以使用这个名字来引用这个实体。在程序的其它部分这个名字可能会指向不同的实体，或者指向空</p><p>这个绑定的scope通常也被叫做一个实体的可见性。这是从被引用实体的视角来描述的，前面说的绑定是从指向引用的名字的角度来说的。精确的定义这个 Scope 是比较困难的，但是在平常使用和实践中，通常Scope会根据使用的语言和实体的类型被指代为 <code>a block, a function, or a file</code></p><h3 id="Lexical-scope-VS-Dynamic-scope"><a href="#Lexical-scope-VS-Dynamic-scope" class="headerlink" title="Lexical scope VS Dynamic scope"></a>Lexical scope VS Dynamic scope</h3><p>在scope中存在一个根本的不同是“程序中的一部分”指的是什么。在使用词法作用域(也叫静态作用域)的语言中，名称解析依赖于源码中名称的位置和词法上下文（根据命名变量和函数定义的位置来定义）。相对的，使用动态作用域的语言，名称解析依赖于程序状态，当这个名字被解析到时执行上下文是什么。在实际中，使用词法作用域的变量定义通过搜寻包含他的block或者function来解析，如果失败了，会继续搜寻外面一层的block，以此类推。当然，在这两种规则中，我们都是首先查看该变量的本地定义。</p><p>大部分现代语言都使用词法作用域，动态作用域主要被 Lisp 的一些方言使用，还有一些脚本语言如Perl，和一些模版语言。即使在词法作用域中，闭包作用域对于一些没有专门知识的人理解起来也是困惑的。这是由于<strong>闭包的词法作用域依赖于她定义的位置，而不是她调用的位置</strong></p><h2 id="语言的类型系统"><a href="#语言的类型系统" class="headerlink" title="语言的类型系统"></a>语言的类型系统</h2><h3 id="statically-typed-system-VS-dynamically-typed-system"><a href="#statically-typed-system-VS-dynamically-typed-system" class="headerlink" title="statically typed system VS dynamically typed system"></a>statically typed system VS dynamically typed system</h3><p>先区分静态类型系统和动态类型系统:</p><p>在动态类型系统中，值在运行时有类型，但是变量和函数没有类型。在静态类型系统中，变量和函数的类型在编译期是已知的。举例来说，在 Python 中，x 可以是任意的东西，在运行时，如果他是1，那么x就是number类型，如果他是”foo”,那么x就是一个 string。你只有在运行时才能知道x的类型，而且在你每次运行程序时，这个类型可能不一样。在像 Java 这样的静态类型语言中，如果x是number，你一般直接定义 int x，编译器在编译期就知道x是int类型，而且不会在运行时改变。</p><h3 id="Explicit-VS-Implicit"><a href="#Explicit-VS-Implicit" class="headerlink" title="Explicit VS Implicit"></a>Explicit VS Implicit</h3><p>在静态类型系统下，再区分：</p><p>静态类型系统是说，一个变量的类型是在编译期已知的，但是不表示你必须像Java那样显示的写出来，比如<code>public int foo(String bra, Object baz) {...}</code>这是一个静态的，显示的方式。有的语言编译器会自己进行类型推导，不需要显示的把类型写出来，比如在 OCaml中，<code>let foo x = x + 1</code>，因为你使用了操作符<code>+</code>所以OCaml会推断出x是int类型，你不需要自己显示的写出来</p><h3 id="Nominal-typing-VS-Structural-typing"><a href="#Nominal-typing-VS-Structural-typing" class="headerlink" title="Nominal typing VS Structural typing"></a>Nominal typing VS Structural typing</h3><p>一个类型像是 a string，a boolean，an object，or a class，它们都有一个名字和结构，像string 或者boolean 这样的基本数据类型的结构很简单，基本只有一个名字。像类这样的类型的结构就比较复杂了，它们也都有自己的名字，即使他们的结构是一样的</p><p>静态类型检查器如果通过类型的名字来检查类型是否一样，这就是 nominal typing，如果是通过结构来检查，这就是 structural typing</p><hr><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html" target="_blank" rel="noopener">Expressions, Statements, and Blocks</a></li><li><a href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4#.wo7rcsj48" target="_blank" rel="noopener">Type Systems: Structural vs. Nominal typing explained</a></li><li><a href="https://en.wikipedia.org/wiki/Type_system" target="_blank" rel="noopener">Type system</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一些非常基础容易忽视但是却很重要的语言概念，概念不是教条，但是对概念有一个清晰的认识是一件好事。内容大部分来自 Oracle 官方文档的翻译和对维基百科的翻译。会给出链接，需要详细信息的可以自行查阅&lt;/p&gt;
&lt;h2 id=&quot;Expression-Statements-Blocks&quot;&gt;&lt;a href=&quot;#Expression-Statements-Blocks&quot; class=&quot;headerlink&quot; title=&quot;Expression, Statements, Blocks&quot;&gt;&lt;/a&gt;Expression, Statements, Blocks&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Operators may be used in building expressions, which compute values; expressions are the core componens of statements; statements may be grouped into blocks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Expressions&quot;&gt;&lt;a href=&quot;#Expressions&quot; class=&quot;headerlink&quot; title=&quot;Expressions&quot;&gt;&lt;/a&gt;Expressions&lt;/h3&gt;&lt;p&gt;一个表达式是由各种变量，操作符和方法调用按照语言提供的语法规则构成，&lt;strong&gt;并且可以计算得到一个值。&lt;/strong&gt;表达式得到的值的类型根据表达式中的元素推导出。比如表达式 &lt;code&gt;cadence = 0&lt;/code&gt; 返回 int 类型的数据，因为赋值操作符返回一个相同的数据类型给操作符左边的操作数。在这个例子中，cadence 是一个 int 类型数据&lt;/p&gt;
&lt;p&gt;Java 编程语言允许你通过各种更小的表达式来构造复合的表达式，只要表达式的返回类型互相匹配即可。比如&lt;code&gt;1 * 2 * 3&lt;/code&gt; 就是一个比较简单的复合表达式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在书写复合表达式时，通过使用括号来明确的指定各运算符的优先顺序会使代码更加易读和可维护。把复杂的表达式拆分成简单的表达式并用合适的变量定义也是很好的代码重构手段&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="总结" scheme="https://ryan-hou.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>反转单链表的几种姿势</title>
    <link href="https://ryan-hou.github.io/2017/09/30/fan-zhuan-dan-lian-biao-de-ji-chong-zi-shi/"/>
    <id>https://ryan-hou.github.io/2017/09/30/fan-zhuan-dan-lian-biao-de-ji-chong-zi-shi/</id>
    <published>2017-09-30T03:20:02.000Z</published>
    <updated>2018-05-17T15:07:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>基础数据结构的操作，简单但是有意义，整理下几种实现思路</p><h2 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h2><p>由头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给出的单链表，利用头插法建立新的单链表，返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 <code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LinkNode <span class="title">reverseWithCreate</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头指针</span></span><br><span class="line">        LinkNode newHead = <span class="keyword">new</span> LinkNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 头插法建立单链表</span></span><br><span class="line">            LinkNode cur = <span class="keyword">new</span> LinkNode(head.val);</span><br><span class="line">            cur.next = newHead.next;</span><br><span class="line">            newHead.next = cur;</span><br><span class="line"></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><p>反转一个单链表，可以分解为，先反转单链表除了头节点之后的单链表，然后处理反转后的单链表与头节点的关系即可。递归出口是头节点为空或者头节点的下一个节点为空。使用递归这种声明式的方式使代码更加简洁，重在描述代码做什么而不是怎么做。空间复杂度为<code>O(1)</code>，时间复杂度为<code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LinkNode <span class="title">reverseWithRecursion</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head; <span class="comment">// 递归出口</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkNode headOfLeftNode = reverseWithRecursion(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> headOfLeftNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="指针移动实现反转"><a href="#指针移动实现反转" class="headerlink" title="指针移动实现反转"></a>指针移动实现反转</h2><p>反转一个单链表还有一种很直观的解决方法就是遍历这个单链表，然后依次反转每个需要反转的节点。但是这里存在一个问题，在反转当前节点的时候，当前节点的下一个节点需要先提前保存一下，不然会存在丢失的情况。对于算法的边界，需要考虑链表为空，链表只有一个节点，有两个节点和多于两个节点这几种情况。时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LinkNode <span class="title">reverseWithIter</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkNode pre = head;</span><br><span class="line">        LinkNode cur = head.next;</span><br><span class="line">        LinkNode next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// next 保存指针将要变化的节点原本的下一个节点</span></span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">// pre,cur 同时后移一个距离</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础数据结构的操作，简单但是有意义，整理下几种实现思路&lt;/p&gt;
&lt;h2 id=&quot;头插法建立单链表&quot;&gt;&lt;a href=&quot;#头插法建立单链表&quot; class=&quot;headerlink&quot; title=&quot;头插法建立单链表&quot;&gt;&lt;/a&gt;头插法建立单链表&lt;/h2&gt;&lt;p&gt;由头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给出的单链表，利用头插法建立新的单链表，返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 &lt;code&gt;O(n)&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LinkNode &lt;span class=&quot;title&quot;&gt;reverseWithCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LinkNode head)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 虚拟头指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LinkNode newHead = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (head != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 头插法建立单链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            LinkNode cur = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(head.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cur.next = newHead.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            newHead.next = cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            head = head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; newHead.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="https://ryan-hou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Sharding &amp; IDs at Instagram</title>
    <link href="https://ryan-hou.github.io/2017/09/27/sharding-and-ids-at-instagram/"/>
    <id>https://ryan-hou.github.io/2017/09/27/sharding-and-ids-at-instagram/</id>
    <published>2017-09-27T05:50:26.000Z</published>
    <updated>2018-05-18T10:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 Instagram Engineering 博客中的翻译文章，原文链接为：<a href="https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c" target="_blank" rel="noopener">Sharding &amp; IDs at Instagram</a></p><p>每秒超过25张照片，90个like 在 Instagram 上产生，应用的后台存储了大量的数据。为了保证所有重要的数据可以放在内存中，并被用户快速的获取，Instagram 进行了 shard(数据分片)，换句话说就是把数据分别放在很多小的 bucket 中。</p><p>ins 的后台服务运行在 Django，数据存储在 PostgreSQL中。在决定进行数据 shard 后，遇到的第一个问题就是是否仍然采用PostgreSQL作为主存储，还是选择别的存储方案。在调研了其他的 NoSQL 方案后，最后确定<strong>最适合目前场景</strong>的方案是把数据 shard 到多台 PostgreSQL 服务器上</p><p>在把数据写到这些存储服务器上前，还有一个重要的问题需要解决，那就是如何为每一条数据生成一个<strong>唯一ID</strong>(例如，在我们系统中每一个发布的照片)。传统的单台数据库下使用数据库自带的自增主键在当前场景下不再适用(同一时刻需要往不同机器的数据库插入数据)。这篇文章的后半部分主要就来探讨如何解决这个问题</p><a id="more"></a><p>在开始前，我们先来明确下在我们系统中生成的id需要满足哪些条件：</p><ul><li>1.生成的唯一id应该是可以按时间有序的(这样，一组照片id列表不需要再去获取照片别的字段数据就可以进行排序)</li><li>2.ID最好是64bit大小(这样可以更节省索引空间和存储空间)</li><li>3.系统应该尽可能少的引入”moving parts（即尽可能少的引入别的依赖或者需要学习的新技术）”(ins 的工程师团队非常精干，之所以可以用这么少的工程师完成这么牛的系统，一部分原因就在于她们会倾向于选择简单的，容易理解和让人信服的解决方案)</li></ul><h2 id="Existing-solutions"><a href="#Existing-solutions" class="headerlink" title="Existing solutions"></a>Existing solutions</h2><p>有很多已经存在的解决ID生成的方案，下面是一些我们调研和考虑的：</p><h3 id="Generate-IDs-in-web-application"><a href="#Generate-IDs-in-web-application" class="headerlink" title="Generate IDs in web application"></a>Generate IDs in web application</h3><p>这种方案把ID生成的问题由数据库转移到应用层面。例如，使用<a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank" rel="noopener">MongoDB’s ObjectId</a>，一个12字节长并且把时间戳作为第一个组成部分的ID值。另一个比较流行的就是使用<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">UUIDs</a></p><p>优点：</p><ul><li>1.每一个应用线程独立的产生ID值，减少了单点故障和ID集中生成的压力</li><li>2.如果你使用时间戳作为ID的第一个组成部分，那么生成的ID就是时间有序的</li></ul><p>缺点:</p><ul><li>1.为了保证唯一性，通常需要更大的存储空间(96 bits 或者更大)</li><li>2.一些UUID 类型是完全随机的，没有顺序</li></ul><h3 id="Generate-IDs-through-dedicated-service"><a href="#Generate-IDs-through-dedicated-service" class="headerlink" title="Generate IDs through dedicated service"></a>Generate IDs through dedicated service</h3><p>比较有名的就是 Twitter 开源的 <a href="https://github.com/twitter/snowflake/" target="_blank" rel="noopener">Snowflake</a>，一个使用 Apache ZooKeeper 来协调各节点生成 64bit 大小的ID值的 Thrift 服务</p><p>优点：</p><ul><li>1.Snowflake 生成的ID大小为 64bit，只有 UUID 大小的一半</li><li>2.可以使用时间作为第一部分从而保持有序</li><li>3.分布式服务可以避免单点故障</li></ul><p>缺点：</p><ul><li>1.需要在现有架构中引入额外的复杂度和更多的”moving parts”（ZooKeeper，Snowflake servers）</li></ul><h3 id="DB-Ticket-Servers"><a href="#DB-Ticket-Servers" class="headerlink" title="DB Ticket Servers"></a>DB Ticket Servers</h3><p>使用数据库的自增来保证唯一性。<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Flicker users this apprach</a>，但是Flickr使用了两个 ticket DB(一个从奇数开始自增，一个从偶数开始自增，步长为2)来避免单点故障</p><p>优点：</p><ul><li>1.数据库很好理解而且很好预测将来的扩展问题</li></ul><p>缺点：</p><ul><li>1.最终还是会变成写瓶颈（尽管 Flicker 声称即使在量很大的情况下不存在问题）</li><li>2.需要管理额外的两台机器（或者是 EC2 的实例）</li><li>3.如果使用单台DB，会导致单点故障，如果使用多台 DB，就不能严格保证它们是按时间有序的</li></ul><p>在上面所有的方案中，Twitter 的 Snowflake 是最接近我们理想方案的，但是需要引入额外的复杂性和ID生成服务。所以我们采用了一种概念上相似，但是在 PostgreSQL 内实现的方案</p><h2 id="Our-solution"><a href="#Our-solution" class="headerlink" title="Our solution"></a>Our solution</h2><p>我们的分片系统由几千个“逻辑”上的分片映射到远远少于逻辑分片的物理分片上，通过这种方式，我们只需要使用几个数据库服务器即可，并且可以很方便的扩展到更多的物理服务器上，需要做的就是把一台数据库服务器上的部分逻辑分片的数据转移到别的数据库服务器上，而不需要重新对我们的数据进行分桶。我们使用了 Postgre 的 schema 特性来使这一切很容易的脚本化和管理</p><p>Schemas(不要与SQL定义表结构的schema混淆) 是 Postgres 中提供的逻辑分组的特性。每一个 Postgres 数据库可以有多个 schema，每一个 schema 可以包含一个或者多个表。<strong>表的名字必须是schema唯一的，而不用是数据库唯一的 (相当于在数据库的物理存储之上增加了一层，从而提供了很大的灵活性，引入中间层是常见的问题解决方案)</strong>，默认情况下Postgres把所有东西存储在一个叫做‘public’的schema下</p><p>在我们的系统中，每一个逻辑的分片都是一个 Postgres schema，每一个 sharded 表（比如我们的照片数据）都存在于一个schema中</p><p>我们使用 Postgres 内部提供的编程语言 PL/PGSQL 和 Postgres 提供的自增功能来为每一个shard中的表生成ID</p><p>每一个ID的构成如下：</p><ul><li>41bits 用来存储毫秒时间（使用我们自定义的epoch可以表示41年的时间范围）</li><li>13bits 存储逻辑分片ID</li><li>10bits 存储一个自增的序列值，对1024取模。这意味着每一个shard，每一毫秒我们可以生成1024个ID</li></ul><p>我们来看个例子：假如现在是September 9th, 2011, at 5:00pm 并且我们的 epoch 从January 1st, 2011开始。那么从我们的epoch开始，总共1387263000毫秒，所以我们通过左移来保存ID的最开始的41bits：<code>id = 1387263000 &lt;&lt;(64-41)</code></p><p>接下来我们取当前要插入的数据的shard ID，比如说我们通过用户id来 sharding，并且已知有2000个逻辑分片，如果我们的用户id是 31341，那么我们的 shard ID 是 31341%2000 ＝ 1314，然后我们填充我们ID值的接下来的13bits：<code>id |= 1341 &lt;&lt;(64-41-13)</code></p><p>最后，我们取数据库表的自增的id值来填充剩下的 bits 位（这个序列对于每一个schema下的每一个表是唯一）。假设说我们已经为当前的表生成了5000个id，那么下一个值就是5001，对1024取模后就可以放到我们id值的最后10bit中：<code>id |= (5001 % 1024)</code></p><p>现在我们已经获得了完整的ID值，在插入数据时通过<strong>RETURN</strong>关键字可以把这个ID值返回给应用</p><p>下面是 PL/PGSQL 的代码实现（以 schema insta5 为例）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> insta5.next_id(<span class="keyword">OUT</span> <span class="keyword">result</span> <span class="built_in">bigint</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    our_epoch <span class="built_in">bigint</span> := <span class="number">1314220021721</span>;</span><br><span class="line">    seq_id bigint;</span><br><span class="line">    now_millis bigint;</span><br><span class="line">    shard_id int := 5;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">nextval</span>(<span class="string">'insta5.table_id_seq'</span>) %% <span class="number">1024</span> <span class="keyword">INTO</span> seq_id;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="keyword">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> clock_timestamp()) * <span class="number">1000</span>) <span class="keyword">INTO</span> now_millis;</span><br><span class="line">    result := (now_millis - our_epoch) &lt;&lt; 23;</span><br><span class="line">    result := result | (shard_id &lt;&lt;10);</span><br><span class="line">    result := result | (seq_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">    $$ LANGUAGE PLPGSQL;</span><br></pre></td></tr></table></figure><p>在建表时我们执行下面操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> insta5.our_table (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> insta5.next_id(),</span><br><span class="line">    ...rest <span class="keyword">of</span> <span class="keyword">table</span> schema...</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>上面就是我们应用中唯一主键的生成过程(还有一个额外的好处，在这个主键中包含了shard ID，方便我们进行匹配，ps：这种唯一id生成算法是很通用的解决方案，Snowflake 或者其他基于 zk 的id生成服务，比如美团的Leaf，也是采用了类似的思路)。我们把这个实现部署到了生产环境并对目前的结果很满意。有兴趣帮我们在业务继续扩展时改进这个方案吗？<a href="https://www.instagram.com/about/jobs/" target="_blank" rel="noopener">We’re hiring</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为 Instagram Engineering 博客中的翻译文章，原文链接为：&lt;a href=&quot;https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sharding &amp;amp; IDs at Instagram&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每秒超过25张照片，90个like 在 Instagram 上产生，应用的后台存储了大量的数据。为了保证所有重要的数据可以放在内存中，并被用户快速的获取，Instagram 进行了 shard(数据分片)，换句话说就是把数据分别放在很多小的 bucket 中。&lt;/p&gt;
&lt;p&gt;ins 的后台服务运行在 Django，数据存储在 PostgreSQL中。在决定进行数据 shard 后，遇到的第一个问题就是是否仍然采用PostgreSQL作为主存储，还是选择别的存储方案。在调研了其他的 NoSQL 方案后，最后确定&lt;strong&gt;最适合目前场景&lt;/strong&gt;的方案是把数据 shard 到多台 PostgreSQL 服务器上&lt;/p&gt;
&lt;p&gt;在把数据写到这些存储服务器上前，还有一个重要的问题需要解决，那就是如何为每一条数据生成一个&lt;strong&gt;唯一ID&lt;/strong&gt;(例如，在我们系统中每一个发布的照片)。传统的单台数据库下使用数据库自带的自增主键在当前场景下不再适用(同一时刻需要往不同机器的数据库插入数据)。这篇文章的后半部分主要就来探讨如何解决这个问题&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="分布式" scheme="https://ryan-hou.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Debunking the Myths of RPC &amp; REST</title>
    <link href="https://ryan-hou.github.io/2017/09/24/debunking-the-myths-of-rpc-and-rest/"/>
    <id>https://ryan-hou.github.io/2017/09/24/debunking-the-myths-of-rpc-and-rest/</id>
    <published>2017-09-24T14:40:00.000Z</published>
    <updated>2018-05-19T15:18:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为翻译文章，原文链接为:<a href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/" target="_blank" rel="noopener">Debunking the Myths of RPC &amp; REST</a></p><p>网上有很多关于 RPC 和 REST 的文章，博客与讨论，但是大部分都在回答某一个特定的应用下，应该选择使用 RPC 还是 REST，而这本身并不是一个正确的二分法。这些回答普遍没有解释我想要知道的问题，而是让我感觉到大部分的开发者并不懂为什么要使用 REST，而仅仅是因为觉得这个架构听起来很酷。讽刺的是<a href="https://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="noopener">Roy Fielding</a>在介绍REST的论文中就提到了这种<strong>“design by fad”</strong></p><blockquote><p>“Consider how often we see software projects begin with adoption of the latest fad in architectural design, and only later discover whether or not the system requirements call for such an architecture.”</p></blockquote><a id="more"></a><p>如果你想深入了解REST而且只能读一篇文档，那不要阅读本文，去参考 Fielding 的论文<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">DISSERTATION</a>。如果你没有时间或者只是想在比较高的层面上了解RPC和REST，那么可以继续阅读，在开始之前，我们先来看下RPC，REST和HTTP的一些细节</p><p><strong>Remote Procedure Call(RPC)</strong>是一种允许你调用其他进程的方法并且通过通信来交换数据。通常会在客户端生成方法 stub,使用 stub 使得调用看起来更像本地调用，而实际上在 stub 背后会包装请求然后把请求发送到服务端，然后服务端进程会解析这个请求并且调用客户端想要调用的方法，然后再反向的把这个调用的执行结果返回给客户端。<strong>HTTP协议有时会是底层的信息传递协议，但是RPC并不强制要求一定使用HTTP协议。</strong>远程方法调用(RMI)和RPC更相近，RMI比RPC的远程调用更进一步，它更加面向对象，可以保存远程对象的引用并且调用这个对象的相关方法</p><p><strong>Representational State Transfer(REST)是一种架构方式，通过对接口进行一系列限制来实现一些目标。</strong>REST 强制使用 客户端／服务器模型，客户端获取和操作由服务端管理的各种资源，服务端通过提供各种资源的状态来告诉客户端相关资源的信息，同时提供获取资源最新状态和操作这些资源的方法。客户端和服务端所有的信息交互必须是无状态的和可缓存的。REST 架构的实现通常被称为 RESTful</p><p><strong>Hypertext Transfer Protocol(HTTP)</strong>是一个 RESTful 的协议，可以在分布式环境下暴露相应的资源。在 HTTP 协议中，服务端通过 HTTP 响应的body告诉客户端这些资源的信息。如果body是HTML的话，那么后续合法的操作会给出在 A 标签里，让客户端要么通过 GET 请求获取新的资源状态，要么通过 POST/PUT 或者 DELETE 请求来操作这些资源</p><p>通过以上这些定义，我们可以得出下面结论：</p><ul><li><strong>把 RPC 和 REST 作类比是没有道理的</strong>。事实上你可以通过在任何RPC实现的基础上构建RESTful的服务，只要创建遵守REST架构限制的方法即可。你甚至可以基于RPC的实现构建HTTP风格的REST架构，你需要做的就是通过实现相应的 GET,POST,PUT,DELETE 方法来把 HTTP 请求头和请求体的数据提取并转化到 RPC 的调用</li><li><strong>HTTP和REST不是一对一的关系，HTTP是REST一种实现方式</strong>。REST 是由一组限制构成，但是并没有包括HTTP实现方面的限制。例如你的服务可以不使用HTTP协议来暴露接口仍然可以是RESTful 的</li></ul><p>事实上当人们在问她们是否应该用 RPC 或者 REST 时，真正想要问的是<strong>“我应该通过HTTP协议实现的RESTful服务来对外暴露我的资源，还是我应该使用像 SOAP 或者 XML－RPC 这样更个性化的方式来构建更高一层的抽象”</strong>。要回答这个问题，我们首先来看一下 REST 和 HTTP 的优点，注意，虽然我们分开来说为什么你要使服务RESTful和为什么你要使用HTTP协议，然而前者的观点对于后者也是适用的(反之则不适用)</p><p>REST 架构的优点在于任何状态下合法的行为都是被服务端控制的，只需要制定很少的与客户端的约定。就 HTTP 协议实现的 REST 架构来说，服务端与客户端之间的约定仅仅是顶层的 URI，我可以使用这个 URI 来发送一个 GET 请求。从这里也可以看出，这些服务端对于客户端的限制是在运行时的。相比之下，传统的RPC实现的REST限制更为严格，服务端定义的需要被客户端消费的程序在构建时就要被明确定义好。为了方便理解，可以比较通过页面导航来找到需要的商品(通过调用服务端提供各种链接)和直接通过产品的名字来获取这个产品。在第一种方式中，API的变化完全是由服务端来控制的，但是在第二种情况下需要协同部署客户端与服务端。在这个例子中很明显的问题在于计算机并不能很好的动态消费API，所以如果你正在构建一个被其他服务消费的服务，你很难获得由服务端来控制行为的好处。</p><p>使用HTTP协议来暴露资源的一个很大的好处在于，你可以使用很多专门为 HTTP 协议而开发的工具而不需要自己额外的进行开发。我们来考虑下使用缓存的例子，因为HTTP的响应的输入是被良好定义的(query string,HTTP headers,POST data)，所以我可以在我的服务前面加一个中间层<a href="http://www.squid-cache.org/" target="_blank" rel="noopener">Squid</a>。如果使用 RPC，即使 RPC 的消息传递协议使用 HTTP，我们无法保证消息和远程调用是一对一的，因为一个远程调用可能需要传入多个消息，当然RPC的输入可以通过一种标准的方式被使用或者忽略，从而使对请求和对应的响应进行缓存成为可能。而请求中也可能需要相应的信息来知道如何处理缓存(像 HTTP <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html" target="_blank" rel="noopener">dose</a>)。通过使用 HTTP 协议我们可以避免重新造一些轮子</p><p>使用HTTP协议的另一个好处就是它通过一种很通用的<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">方式</a>，GET,POST/PUT和 DELETE 来暴露资源，这使得测试很容易进行。在实际中如果你为了将来的扩展而使用了过于窄的语义，这会导致你的方法，接口或者服务过分膨胀，并最终成为你的 SOA 的一部分。关于这一点其实就可以单独写一篇文章来解释，所以在这一篇文章中就不深入的探讨了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为翻译文章，原文链接为:&lt;a href=&quot;http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Debunking the Myths of RPC &amp;amp; REST&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网上有很多关于 RPC 和 REST 的文章，博客与讨论，但是大部分都在回答某一个特定的应用下，应该选择使用 RPC 还是 REST，而这本身并不是一个正确的二分法。这些回答普遍没有解释我想要知道的问题，而是让我感觉到大部分的开发者并不懂为什么要使用 REST，而仅仅是因为觉得这个架构听起来很酷。讽刺的是&lt;a href=&quot;https://en.wikipedia.org/wiki/Roy_Fielding&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Roy Fielding&lt;/a&gt;在介绍REST的论文中就提到了这种&lt;strong&gt;“design by fad”&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Consider how often we see software projects begin with adoption of the latest fad in architectural design, and only later discover whether or not the system requirements call for such an architecture.”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="分布式" scheme="https://ryan-hou.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Visitor pattern</title>
    <link href="https://ryan-hou.github.io/2017/09/23/visitor-pattern/"/>
    <id>https://ryan-hou.github.io/2017/09/23/visitor-pattern/</id>
    <published>2017-09-23T07:48:14.000Z</published>
    <updated>2018-05-18T08:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为翻译文章，介绍一个比较强大的设计模式 – <strong>Visitor pattern</strong>，原文链接为: <a href="https://dzone.com/articles/design-patterns-visitor" target="_blank" rel="noopener">Visitor Pattern Tutorial with Java Examples</a></p><h2 id="Visitors-in-the-Real-World"><a href="#Visitors-in-the-Real-World" class="headerlink" title="Visitors in the Real World"></a>Visitors in the Real World</h2><p>通过类比真实世界可以帮助更好的理解设计模式。已打出租车为例，乘客叫好车后，车来了，乘客上车，这时出租车就会为乘客提供运送服务(个人觉得这个例子可以帮助理解但不是特别好，下面的例子更好些)</p><p>在超市购物是另一个比较好的例子，购物车里放的是你购买的各种商品。当你去结账的时候，收银员就扮演了一个 visitor 的角色，他会一个一个的处理你购物车里的商品，有些标有价格，有些需要称重，处理完后会得到你购物的总花费。</p><p>其实这是一个比较难通过现实世界来解释的模式，所以接下来我们通过模式的定义和示例代码来更清楚的学习这个模式</p><h2 id="The-Visitor-Pattern"><a href="#The-Visitor-Pattern" class="headerlink" title="The Visitor Pattern"></a>The Visitor Pattern</h2><p>Visitor 模式是一个行为模式，是用来管理算法，及不同对象之间的关系和责任(个人觉得<strong>Visitor模式很好的体现了单一职责原则，通过分离部分逻辑实现了解耦</strong>)。“四人帮”的 <code>Design patterns</code> 对该模式的定义为：</p><a id="more"></a><blockquote><p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p></blockquote><p>Visitor 实际上做的事情是通过创建一个外部类来操作其他类的数据。如果你需要在一组不同的对象上进行一些操作，那就可以考虑使用这个模式(个人认为Visitor 模式本质上类似于模式匹配，对能匹配上的对象进行一些操作)。GoF 的书中也提到了该模式为一个类提供了扩展的方法而没有修改这个类(所以这个模式<strong>也体现出了开闭原则</strong>)。下面我们看一下 Visitor 模式的类图：</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/visitor.png" alt></p><p>这个模式的核心是 <code>Visitor</code> 接口，这个接口定义了对于每一个 <code>ConcreteElement</code> 类型对象的 <code>visit</code> 操作。同时，ConcreteVisitor 实现了 Visitor 接口中定义的所有操作。这个具体的 visitor 会保存一个局部状态，通常是在遍历每一个 Element 时使用。<code>Element</code> 接口就是很简单的定义了一个 <code>accept</code> 方法来允许 visitor 在该 element 上执行一些操作，ConcreteElement 类则会具体的实现这个 accept 方法</p><h2 id="Where-Would-I-Use-This-Pattern"><a href="#Where-Would-I-Use-This-Pattern" class="headerlink" title="Where Would I Use This Pattern?"></a>Where Would I Use This Pattern?</h2><p><strong>当你需要在一些不同类型的对象结构上执行一些不相关的操作时可以使用该模式。这样就避免了你需要把这些操作直接加到每一个类型上，从而带来了更干净的代码。也就是说如果你想把一些逻辑处理的代码从各种 element 类中解耦出去(通常这些elements实例会作为逻辑代码的输入)，那么visitor模式可能就是最好的手段</strong></p><h2 id="So-How-Does-It-Work-In-Java"><a href="#So-How-Does-It-Work-In-Java" class="headerlink" title="So How Does It Work In Java?"></a>So How Does It Work In Java?</h2><p>接下来的例子展示了一个该模式的简单实现，这个例子是一个邮费系统，我们的 elements 集合是我们购物车中的各种 items，邮费会根据不同的 element 元素的类型，重量等有所不同，当然也会根据运送地点的不同而产生不同的邮费</p><p>我们为每一个地区创建一个单独的 visitor，这样我们就可以把计算总邮费的逻辑从每一个 items 中分离出来。这就意味着我们每一个 elements 不需要知道任何和邮费计算相关的规则(符合单一职责原则和最少知识原则)，这样我们的 element 就从这些逻辑中解耦出来</p><p>首先看一下我们的 visitable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Element interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们创建一个接口的实现类，a Book</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//concrete element</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Visitable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//accept the visitor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor vistor)</span> </span>&#123;</span><br><span class="line">    visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这个类就是一个简单的 POJO，同时提供一个 <code>accept</code> 方法用以允许 visitor 来访问这个 element。我们这里可以增加别的类型来处理别的 items，比如 CDs,DVDs or games</p><p>现在我们来看 <code>Visitor</code> 接口，对于每一个不同的具体的 element，我们都要在这里增加一个 <code>visit</code> 方法，对于我们之前定义好的 Book 类，我们提供如下的 visit 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Book book)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//visit other concrete items</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(CD cd)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(DVD dvd)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Visitor 接口的实现类就可以在我们 visit 一个 Book 对象时提供具体的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostageVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> totalPostageForCart;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//collect data about the book</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//assume we have a calculation here related to weight and price</span></span><br><span class="line">    <span class="comment">//free postage for a book over 10 </span></span><br><span class="line">    <span class="keyword">if</span>(book.getPrice() &lt; <span class="number">10.0</span>) &#123;</span><br><span class="line">      totalPostageForCart += book.getWeight() * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//add other visitors here</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(CD cd)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(DVD dvd)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="comment">//return the internal state</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalPostage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> totalPostageForCart;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>你可以看到这是一个简单的 formula，重点在于对于书本邮费的计算全都集中在一个地方</strong></p><p>为了使用这个 visitor，我们需要提供一个方法来遍历我们的购物车，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  <span class="comment">//normal shopping cart stuff</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;Visitable&gt; items;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculatePostage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//create a visitor</span></span><br><span class="line">    PostageVisitor visitor = <span class="keyword">new</span> PostageVisitor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//iterate through all items</span></span><br><span class="line">    <span class="keyword">for</span>(Visitable item: items) &#123;</span><br><span class="line">      item.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> postage = visitor.getTotalPostage();</span><br><span class="line">    <span class="keyword">return</span> postage;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果我们又新增加了新的 item，只要我们的 visitor 实现了 visit 这个 item 的方法，我们就可以轻松的计算出总的邮费</p><p>所以，可能这个模式开始看起来比较奇怪，但是确实能使你的代码更干净。<strong>这个模式的关键就在于，让你可以把 element 中的部分逻辑分离出去，保持你的 data 类简单</strong></p><h2 id="Watch-Out-for-the-Downsides"><a href="#Watch-Out-for-the-Downsides" class="headerlink" title="Watch Out for the Downsides"></a>Watch Out for the Downsides</h2><p>visiting 方法的入参和返回值类型需要提前知道，所以Visitor模式不太适合用在被 visit 的类容易变化的情景下。每增加一个新的 Element 类，都需要对应的增加 Visitor 接口及其实现类中的 visit 方法</p><p>如果你的代码不是最开始就设计使用Visitor模式，想要重构成该模式是困难的，会让你的代码看起来难懂，Visitor模式是强大的，但是你要自己确认是不是有必要引入这个模式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为翻译文章，介绍一个比较强大的设计模式 – &lt;strong&gt;Visitor pattern&lt;/strong&gt;，原文链接为: &lt;a href=&quot;https://dzone.com/articles/design-patterns-visitor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Visitor Pattern Tutorial with Java Examples&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Visitors-in-the-Real-World&quot;&gt;&lt;a href=&quot;#Visitors-in-the-Real-World&quot; class=&quot;headerlink&quot; title=&quot;Visitors in the Real World&quot;&gt;&lt;/a&gt;Visitors in the Real World&lt;/h2&gt;&lt;p&gt;通过类比真实世界可以帮助更好的理解设计模式。已打出租车为例，乘客叫好车后，车来了，乘客上车，这时出租车就会为乘客提供运送服务(个人觉得这个例子可以帮助理解但不是特别好，下面的例子更好些)&lt;/p&gt;
&lt;p&gt;在超市购物是另一个比较好的例子，购物车里放的是你购买的各种商品。当你去结账的时候，收银员就扮演了一个 visitor 的角色，他会一个一个的处理你购物车里的商品，有些标有价格，有些需要称重，处理完后会得到你购物的总花费。&lt;/p&gt;
&lt;p&gt;其实这是一个比较难通过现实世界来解释的模式，所以接下来我们通过模式的定义和示例代码来更清楚的学习这个模式&lt;/p&gt;
&lt;h2 id=&quot;The-Visitor-Pattern&quot;&gt;&lt;a href=&quot;#The-Visitor-Pattern&quot; class=&quot;headerlink&quot; title=&quot;The Visitor Pattern&quot;&gt;&lt;/a&gt;The Visitor Pattern&lt;/h2&gt;&lt;p&gt;Visitor 模式是一个行为模式，是用来管理算法，及不同对象之间的关系和责任(个人觉得&lt;strong&gt;Visitor模式很好的体现了单一职责原则，通过分离部分逻辑实现了解耦&lt;/strong&gt;)。“四人帮”的 &lt;code&gt;Design patterns&lt;/code&gt; 对该模式的定义为：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>volatile与final关键字解析</title>
    <link href="https://ryan-hou.github.io/2017/07/07/volatileyu-finalguan-jian-zi-jie-xi/"/>
    <id>https://ryan-hou.github.io/2017/07/07/volatileyu-finalguan-jian-zi-jie-xi/</id>
    <published>2017-07-07T07:25:57.000Z</published>
    <updated>2018-05-18T11:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>保证内存可见性</li><li>防止指令重排序</li></ul><p>此外需注意volatile并不保证操作的原子性</p><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己的工作内存(比如CPU寄存器)，<strong>工作内存中保存了主内存共享变量的副本。线程只能访问自己的工作内存，不可以访问其他线程的工作内存</strong>。这就导致了<strong>各个线程的工作内存与主内存的数据可能并不是完全一致的</strong>，即共享变量的改变在不同的线程间是不可见的</p><p>内存不可见会带来一些问题，比如有一个共享变量<code>boolean open = true;</code> 描述一个资源的状态，true 表示可用。现在线程 A 进行操作后，把该变量值改为 false，但是该变量的改动尚未同步到线程 B 的工作内存，那么线程 B 会操作一个不可用的资源，从而产生错误</p><a id="more"></a><p>上面的例子，为了能够保证变量的修改对其他线程可见，需要使用 volatile 关键字。volatile 关键字保证可见性的原理是在每次访问volatile修饰的变量时都会强制从主内存获取最新的值，因此每次访问的都是主内存的最新版本</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>指令重排序是比较复杂的一块儿内容，涉及到处理器，编译器等指令的优化，包括计算机处理器架构等硬件知识，这里抛砖引玉，文章结尾会给出推荐文章的链接</p><blockquote><p>大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。通过乱序执行的技术，处理器可以大大提高执行效率。<br>除了处理器，<strong>常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。</strong></p></blockquote><p>简单说指令重排序的目的是为了优化指令，提高运行效率，在不影响单线程程序执行结果的前提下，尽可能的提高并行度。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r = <span class="number">2.3</span>;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> area = pi * r * r;</span><br></pre></td></tr></table></figure><p>上面代码中，第三行依赖于前两行代码，但是前两行之间没有顺序，可以先执行任何一行代码</p><p><strong>as-if-serial 语义</strong></p><blockquote><p>As-if-serial语义的意思是，所有的动作(Action)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义</p></blockquote><p>指令重排序在多线程下带来的问题：如果一个操作不是原子的，就会给 JVM 留下重排序的机会，最经典的例子就是double checked 的单例模式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 非原子操作，可能会被重排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>instance = new Singleton()</code> 并不是一个原子操作，在 JVM 中可以抽象为三条指令：</p><blockquote><p>memory = allocate(); // 1:分配对象的内存空间<br>ctorInstnace(memory); // 2:初始化对象<br>instance = memory; // 3:设置instance指向刚分配的内存地址</p></blockquote><p>上面三条指令中 2 依赖于 1，但是 3 并不依赖于 2，所以实际执行时可能是 <code>1 - 3 - 2</code>；那么线程 A 在执行完 3 时，对象还没有初始化就已经赋值给 instance，这时线程 B 进入方法判断 instance 引用不为 null，然后返回一个没有被初始化好的对象，导致出错</p><p>在 JDK5 之后可以使用 <code>private static volatile Singleton instance;</code> 来防止指令重排序。原理是为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</p><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><h3 id="final-表示不可变"><a href="#final-表示不可变" class="headerlink" title="final 表示不可变"></a>final 表示不可变</h3><p>final 关键字的第一种用法很常见了，就是控制可变性；final 修饰的基本类型，其值是不允许被修改的，final 修饰的对象引用，该引用不可以指向别的对象，但是该引用指向的对象本身是可以变化的</p><p>控制代码的可访问性和可变性是一个工程师应该有的习惯，也就是说<strong>代码中使用 private 和 final 不需要理由，不使用才需要理由</strong></p><h3 id="final-的内存语义"><a href="#final-的内存语义" class="headerlink" title="final 的内存语义"></a>final 的内存语义</h3><blockquote><p>Java内存模型对 volatile 和 final 的语义做了扩展。对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化</p></blockquote><p>关于final的具体语义，建议去看 JLS 文档，链接最后会给出</p><p>具体的使用方式如下，来自 Stack Overflow，写的很清楚不需要翻译，链接最后给出：</p><blockquote><p>Marking a field as final forces the compiler to complete initialization of the field before the constructor completes. There is no such guarantee however for non-final fields. This might seem weird, however there are many things done by the compiler and JVM for optimization purposes such as reordering instructions, that cause such stuff to occur.<br><br>The usage model for final fields is a simple one: Set the final fields for an object in that object’s constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object’s constructor is finished. If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object’s final fields. </p></blockquote><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ul><li><a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a></li><li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5" target="_blank" rel="noopener">17.5. final Field Semantics</a></li><li><a href="https://stackoverflow.com/questions/27254152/what-exactly-does-the-final-keyword-guarantee-regarding-concurrency" target="_blank" rel="noopener">What exactly does the final keyword guarantee regarding concurrency?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;volatile关键字&quot;&gt;&lt;a href=&quot;#volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;volatile关键字&quot;&gt;&lt;/a&gt;volatile关键字&lt;/h2&gt;&lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;保证内存可见性&lt;/li&gt;
&lt;li&gt;防止指令重排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外需注意volatile并不保证操作的原子性&lt;/p&gt;
&lt;h3 id=&quot;内存可见性&quot;&gt;&lt;a href=&quot;#内存可见性&quot; class=&quot;headerlink&quot; title=&quot;内存可见性&quot;&gt;&lt;/a&gt;内存可见性&lt;/h3&gt;&lt;p&gt;Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己的工作内存(比如CPU寄存器)，&lt;strong&gt;工作内存中保存了主内存共享变量的副本。线程只能访问自己的工作内存，不可以访问其他线程的工作内存&lt;/strong&gt;。这就导致了&lt;strong&gt;各个线程的工作内存与主内存的数据可能并不是完全一致的&lt;/strong&gt;，即共享变量的改变在不同的线程间是不可见的&lt;/p&gt;
&lt;p&gt;内存不可见会带来一些问题，比如有一个共享变量&lt;code&gt;boolean open = true;&lt;/code&gt; 描述一个资源的状态，true 表示可用。现在线程 A 进行操作后，把该变量值改为 false，但是该变量的改动尚未同步到线程 B 的工作内存，那么线程 B 会操作一个不可用的资源，从而产生错误&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从一个简单的前端Bug谈点感受</title>
    <link href="https://ryan-hou.github.io/2017/05/30/cong-[?%5D-ge-jian-dan-de-qian-duan-bugtan-tan-jsde-dan-xian-cheng/"/>
    <id>https://ryan-hou.github.io/2017/05/30/cong-[?%5D-ge-jian-dan-de-qian-duan-bugtan-tan-jsde-dan-xian-cheng/</id>
    <published>2017-05-30T09:47:26.000Z</published>
    <updated>2018-05-24T09:45:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>为了防止按钮多次点击发送多次异步请求到服务器，在点击按钮后，需要disabled 掉该按钮，等异步请求执行完成后再恢复按钮状态为可点击。原本很简单的操作，通过 jQuery 拿到按钮对象后，使用 attr 方法把按钮的 disabled 属性置为 true 然后等请求执行完成后再移除该属性即可。然而就这么一个简单的操作，代码就是不按想象的执行，按钮仍然可以点击多次，执行多次请求</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>最开始在 Google 上搜索了一下 jQuery attr 函数在 chrom 浏览器下失效的原因，找到很多答案，基本都指向了同一个问题，那就是 jQuery 的新版本需要使用 prop 函数，换上 prop 函数后，仍然没有效果；</p><p>接下来，决定用更直接的方法，在按钮事件中定义一个布尔变量，当执行 jQuery ajax 请求时，先把该变量置为 false，执行完成后再置为 true，仍然没有效果。</p><a id="more"></a><p>这时候，进一步猜测，是不是我的按钮有问题，因为这个按钮是一个 jsp 自定义的标签，但是看了页面源代码，这个按钮和别的按钮的 html 代码一样的啊，这个猜测也排除了。</p><p>没办法，只能进一步做假设，这一次缩小范围，在按钮请求发出时把按钮置为 disabled，并且请求执行完成后保持 disabled，先看一下是不是这个函数没有执行，执行之后发现，按钮在一次点击后保持 disabled 状态，也就是说这个函数的行为时正常的。这时候，本来已经很接近原因了，我又做了一步比较二的假设，假设是我的请求执行的太快了，使得按钮的 disabled 效果没有体现出来，于是我又给 disabled 加了一个 setTimeout 函数，设置了一个时间差，果然有效果，但是总觉得哪里不对，于是我把 setTimeout 的时间设置为 0，依然有效。折腾到这里，才终于回想起刚毕业那会儿学习 JS 时的知识，想到了 setTimeout 的诡异行为，想到了 JS 是单线程的，这时才假设会不会是我的请求不是异步是同步的啊，我看了一眼 ajax 请求的参数，果然 <code>async : false</code>，想哭。</p><p>虽然好长时间不写页面，也确实对前端无感，但是这么一个简单的bug花了不少时间才解决，值得记录一下，顺便整理一下相关的知识</p><h2 id="关于同步-异步，阻塞-非阻塞"><a href="#关于同步-异步，阻塞-非阻塞" class="headerlink" title="关于同步/异步，阻塞/非阻塞"></a>关于同步/异步，阻塞/非阻塞</h2><p>同步是指你提交了一个请求，并没有立即返回，要等到服务器处理完成后，连带着返回值一起返回；异步是指你触发了事件后，服务端立即返回，但是是不带返回值， 然后当服务端处理完这件事情后， 通过回调等各种方式通知你这个返回值；举个例子，比如你用手机叫车，叫车后你在路边一直等着司机，这就是同步；而叫车后，你继续做你的事，等司机到了联系你，这就是异步</p><p>阻塞是指在执行某个操作时，当前线程挂起，不允许执行其他操作，只能等待当前操作结束；而非阻塞则是在等待期间，当前线程不会挂起，可以进行别的操作(比如轮询操作)</p><h2 id="JS是单线程的"><a href="#JS是单线程的" class="headerlink" title="JS是单线程的"></a>JS是单线程的</h2><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来复杂的同步问题。比如，<code>假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</code></p><p>这里有的同学可能会困惑，既然JS是单线程的，那么 Ajax 的异步请求是真的异步吗？在回答这个问题前，先要搞清楚几个问题：</p><ul><li>虽然<strong>JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的</strong>，一般的浏览器都有以下线程：javascript引擎线程，界面渲染线程，浏览器事件触发线程，Http请求线程</li><li>浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。<strong>javascript引擎是单线程处理它的任务队列</strong>，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如 mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。</li><li>JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</li></ul><p>综上，我们不难得出结论，<strong>Ajax 的异步请求是真的异步，这请求是由浏览器新开一个线程请求，事件回调的时候是放入Event loop单线程事件队列等候处理。</strong></p><p>说到这里，也不难理解我上面在调试bug时设置 <code>setTimeout(func, 0)</code> 的作用了，虽然时间设置为0，但是这相当于告诉js引擎，在0ms以后把func放到主事件队列中，等待当前的代码执行完毕再执行，重点是<strong>改变了代码执行流程</strong>，把func的执行放到了等待当前的代码执行完毕再执行</p><p>虽然只是一个小bug，但是仔细分析下来还是很有收获的，对于bug也应该保持敬畏的态度：</p><ul><li>没有愚蠢的bug。你总能从中学到些什么，哪怕只是字母拼错了，或者代码顺序有问题，或者别名问题</li><li><strong>没有不可思议的bug，如果有，那么很可能是你自己做了错误的假设</strong>，比如我这里假设自己的 ajax 请求是异步的，结果不是，遇到不可思议的bug，需要我们用科学实验的方法来做假设，排除非相关变量的影响，然后根据试验结果验证我们的假设</li></ul><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://www.cnblogs.com/Mainz/p/3552717.html" target="_blank" rel="noopener">Javascript是单线程的深入分析</a></li><li><a href="https://segmentfault.com/a/1190000007254883" target="_blank" rel="noopener">异步， 同步， 阻塞， 非阻塞</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;为了防止按钮多次点击发送多次异步请求到服务器，在点击按钮后，需要disabled 掉该按钮，等异步请求执行完成后再恢复按钮状态为可点击。原本很简单的操作，通过 jQuery 拿到按钮对象后，使用 attr 方法把按钮的 disabled 属性置为 true 然后等请求执行完成后再移除该属性即可。然而就这么一个简单的操作，代码就是不按想象的执行，按钮仍然可以点击多次，执行多次请求&lt;/p&gt;
&lt;h2 id=&quot;分析问题&quot;&gt;&lt;a href=&quot;#分析问题&quot; class=&quot;headerlink&quot; title=&quot;分析问题&quot;&gt;&lt;/a&gt;分析问题&lt;/h2&gt;&lt;p&gt;最开始在 Google 上搜索了一下 jQuery attr 函数在 chrom 浏览器下失效的原因，找到很多答案，基本都指向了同一个问题，那就是 jQuery 的新版本需要使用 prop 函数，换上 prop 函数后，仍然没有效果；&lt;/p&gt;
&lt;p&gt;接下来，决定用更直接的方法，在按钮事件中定义一个布尔变量，当执行 jQuery ajax 请求时，先把该变量置为 false，执行完成后再置为 true，仍然没有效果。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="总结" scheme="https://ryan-hou.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="FE" scheme="https://ryan-hou.github.io/tags/FE/"/>
    
  </entry>
  
  <entry>
    <title>基于JNDI和项目框架使用JUnit</title>
    <link href="https://ryan-hou.github.io/2017/05/26/ji-yu-jndihe-xiang-mu-kuang-jia-shi-yong-junit/"/>
    <id>https://ryan-hou.github.io/2017/05/26/ji-yu-jndihe-xiang-mu-kuang-jia-shi-yong-junit/</id>
    <published>2017-05-26T09:37:49.000Z</published>
    <updated>2018-05-30T08:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>新参与的项目，由于之前赶进度开发，代码质量堪忧，没有任何单元测试，项目使用JNDI在Tomcat容器配置数据源信息，并且公司的架构对Spring和iBatis做了二次开发。最近打算重构一部分代码，需要加上单元测试，考虑到项目的部署环境并不复杂，数据访问也不是很大，第一步先使用Junit测试，直连数据库，后期再引入Mock环境</p><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><ul><li>整合JNDI和Spring Test</li><li>整合Spring Test 和公司封装的框架</li></ul><h2 id="关于JNDI及与测试框架整合"><a href="#关于JNDI及与测试框架整合" class="headerlink" title="关于JNDI及与测试框架整合"></a>关于JNDI及与测试框架整合</h2><h3 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h3><blockquote><p>JNDI stands for Java Naming and Directory Interface. It is an API to providing access to a directory service, that is, a service mapping name (strings) with objects, reference to remote objects or simple data<br>Applications use the JNDI interface to access resources.</p></blockquote><a id="more"></a><p>简单来说，可以类比为一个 hashmap，有一个String类型的key，同时对应一个用来表示网络资源的对象类型的值。通常，这些资源被组织为分层级的目录服务，不同的层级通过分隔符来定义(比如，在DNS中使用<code>.</code>，在LDAP中使用<code>,</code>)。这是一个命名惯例，不同的上下文有自己的命名惯例。</p><h3 id="为什么使用JNDI"><a href="#为什么使用JNDI" class="headerlink" title="为什么使用JNDI"></a>为什么使用JNDI</h3><p>JDNI可以使分布式应用以一种抽象的，资源无关的方式来寻找服务。最常见的应用是在 Java EE 应用服务器（比如Tomcat）配置数据库连接池（使用统一的配置中心来进行集中管理也是一种思路）。这样任何部署在这台服务器上的应用都可以使用 JNDI 名<code>java:comp/env/FooBarPool</code> 来获取连接而不用知道具体的连接信息。这种做法有两个主要的好处：</p><ul><li>如果你的应用是在不同的环境下都要部署的，比如<code>dev-&gt;test-&gt;pre-&gt;prod</code>，那么你可以在不同的环境下使用相同的 JNDI 名字，应用在不同的环境下迁移不需要做任何的修改</li><li>最小化配置信息的知情人，把配置和管理服务器的人与开发的人分开，不同的环境可以控制自己相应的账户与密码等信息</li></ul><h3 id="与Spring-JUnit-整合"><a href="#与Spring-JUnit-整合" class="headerlink" title="与Spring JUnit 整合"></a>与Spring JUnit 整合</h3><p>从上面我们知道，一般使用JNDI是结合JavaEE容器来使用，配置信息在容器层面，但是我们要使用单元测试，就需要把配置信息在项目层面进行配置，即配置数据源连接信息，分三步走：</p><ul><li>把JavaEE容器中的信息获取到，配置为项目的bean，举个例子：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceUC"</span><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://xx.xx.xx.xx:3306/database_name?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8<span class="symbol">&amp;amp;</span>zeroDateTimeBehavior=convertToNull"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"xxx"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxx"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用 Spring 官方提供的 <strong>SimpleNamingContextBuilder</strong> <code>binding a JDBC DataSource to a well-known JNDI location, to be able to use traditional J2EE data access code outside of a J2EE container.</code>（具体信息见官网，文章最后会给出链接）</p></li><li><p>优化上面的操作，通过继承<strong>SpringJUnit4ClassRunner</strong>类来进行JNDI和数据源的绑定操作，示例代码如下，具体信息文章最后会给出相应的文章链接，写的很好很详细</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class adds the JNDI capabilities to the SpringJUnit4ClassRunner.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringWithJNDIRunner</span> <span class="keyword">extends</span> <span class="title">SpringJUnit4ClassRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isJNDIactive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JNDI is activated with this constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> klass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InitializationError</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NamingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringWithJNDIRunner</span><span class="params">(Class&lt;?&gt; klass)</span> <span class="keyword">throws</span> InitializationError,</span></span><br><span class="line"><span class="function">            IllegalStateException, NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(klass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (SpringWithJNDIRunner<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isJNDIactive) &#123;</span><br><span class="line"></span><br><span class="line">                ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                        <span class="string">"initTestEnvir.xml"</span>);</span><br><span class="line">                <span class="comment">// 这里的bean是用来初始化项目的路径用的，与公司的架构封装有关，可以忽略       </span></span><br><span class="line">                applicationContext.getBean(<span class="string">"initPath"</span>);</span><br><span class="line"></span><br><span class="line">                applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"dataAccessContext-ibatis-UC.xml"</span>);</span><br><span class="line">                SimpleNamingContextBuilder builder = <span class="keyword">new</span> SimpleNamingContextBuilder();</span><br><span class="line">                builder.bind(<span class="string">"java:comp/env/jdbc/ucmysql,ucmysql_read_1"</span>,</span><br><span class="line">                        applicationContext.getBean(<span class="string">"dataSourceUC"</span>));</span><br><span class="line">                builder.activate();</span><br><span class="line"></span><br><span class="line">                isJNDIactive = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringWithJNDIRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= &#123;<span class="string">"classpath:dataAccessContext-ibatis-UC.xml"</span>,</span><br><span class="line">        <span class="string">"classpath:com/xxx/framework/config/spring/applicationContext_annotation.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleRetireDAOImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(VehicleRetireDAOImplTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> VehicleRetireDAO vehicleRetireDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetRetireById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"-----------------Start---------------"</span>);</span><br><span class="line"></span><br><span class="line">        VehicleRetire vehicleRetire = vehicleRetireDAO.getRetireById(<span class="number">100L</span>);</span><br><span class="line">        logger.error(<span class="string">"Vehicle info = &#123;&#125;"</span>, JSONObject.toJSONString(vehicleRetire));</span><br><span class="line">        logger.error(<span class="string">"-----------------End------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整合公司开发框架"><a href="#整合公司开发框架" class="headerlink" title="整合公司开发框架"></a>整合公司开发框架</h3><p>在整合公司的框架时，遇到了不少的问题，因为是基于开源框架的二次开发，而且没有什么文档，只能一点点的调试和debug，主要解决的问题有三个，也算是有参考价值的点：</p><ul><li>设置项目编译后的路径信息，并在加载其他配置文件前，先设置好该路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitPath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GlobalMessage.setPath(Thread.currentThread().getContextClassLoader().getResource(<span class="string">""</span>).getPath().replace(<span class="string">"test-classes/"</span>,<span class="string">"xxx"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>找到项目Bean注解扫描(如@Service,@Resource,@Autowired等)的配置</li><li>梳理项目整合数据源与封装后的iBatis配置，及整合Spring的配置</li></ul><p>至此，项目终于可以正常使用 JUnit 来进行单元测试，为下一步进行代码重构准备好前提条件</p><hr><p>####参考文章</p><ul><li><a href="http://blog.manupk.com/2014/03/integration-testing-for-spring.html" target="_blank" rel="noopener">Integration Testing for Spring Applications with JNDI Connection Pools</a></li><li><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mock/jndi/SimpleNamingContextBuilder.html" target="_blank" rel="noopener">Class SimpleNamingContextBuilder</a></li><li><a href="http://docs.spring.io/spring-batch/reference/html/testing.html" target="_blank" rel="noopener">10. Unit Testing</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;新参与的项目，由于之前赶进度开发，代码质量堪忧，没有任何单元测试，项目使用JNDI在Tomcat容器配置数据源信息，并且公司的架构对Spring和iBatis做了二次开发。最近打算重构一部分代码，需要加上单元测试，考虑到项目的部署环境并不复杂，数据访问也不是很大，第一步先使用Junit测试，直连数据库，后期再引入Mock环境&lt;/p&gt;
&lt;h2 id=&quot;需要解决的问题&quot;&gt;&lt;a href=&quot;#需要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;需要解决的问题&quot;&gt;&lt;/a&gt;需要解决的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;整合JNDI和Spring Test&lt;/li&gt;
&lt;li&gt;整合Spring Test 和公司封装的框架&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;关于JNDI及与测试框架整合&quot;&gt;&lt;a href=&quot;#关于JNDI及与测试框架整合&quot; class=&quot;headerlink&quot; title=&quot;关于JNDI及与测试框架整合&quot;&gt;&lt;/a&gt;关于JNDI及与测试框架整合&lt;/h2&gt;&lt;h3 id=&quot;什么是JNDI&quot;&gt;&lt;a href=&quot;#什么是JNDI&quot; class=&quot;headerlink&quot; title=&quot;什么是JNDI&quot;&gt;&lt;/a&gt;什么是JNDI&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;JNDI stands for Java Naming and Directory Interface. It is an API to providing access to a directory service, that is, a service mapping name (strings) with objects, reference to remote objects or simple data&lt;br&gt;Applications use the JNDI interface to access resources.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="优化" scheme="https://ryan-hou.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
