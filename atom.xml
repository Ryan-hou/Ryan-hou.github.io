<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x08 0x17</title>
  
  <subtitle>Build something useful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ryan-hou.github.io/"/>
  <updated>2020-04-24T03:40:57.703Z</updated>
  <id>https://ryan-hou.github.io/</id>
  
  <author>
    <name>0x08 0x17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>零拷贝技术解析</title>
    <link href="https://ryan-hou.github.io/2019/11/11/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/"/>
    <id>https://ryan-hou.github.io/2019/11/11/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</id>
    <published>2019-11-11T12:03:56.000Z</published>
    <updated>2020-04-24T03:40:57.703Z</updated>
    
    <content type="html"><![CDATA[<p>本文为翻译文章，原文链接为: <a href="https://developer.ibm.com/technologies/java/articles/j-zerocopy/" target="_blank" rel="noopener">Efficient data transfer through zero copy</a></p><h3 id="Zero-copy-是什么"><a href="#Zero-copy-是什么" class="headerlink" title="Zero-copy 是什么"></a>Zero-copy 是什么</h3><blockquote><p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.       – from Wikipedia</p></blockquote><a id="more"></a><h3 id="应用场景及实现原理"><a href="#应用场景及实现原理" class="headerlink" title="应用场景及实现原理"></a>应用场景及实现原理</h3><p>许多 web 应用都会提供从磁盘读取大量的静态数据，然后再把这些数据写到 response socket 中。这种服务看起来几乎不会用到 cpu 计算，但事实并非如此：内核从磁盘读取数据后，会把它通过 kernel-user 边界 push 到应用，然后再通过kernel-user 边界 push 回 socket buffer 供 socket 写出。实际上，这里应用层成了磁盘和 socket 之间一个低效的中间介质</p><p>每次数据通过 kernel-user 边界时，必须被复制，这就会消耗cpu cycles 和内存带宽。幸运的是，我们可以通过 <code>zero copy</code> 技术来消除这些拷贝。<strong>使用 zero copy技术，应用可以直接把磁盘数据移动到 socket，不需要经过应用</strong>。zero copy 技术提升了应用性能并且减少了 kernel 和 user 模式的切换</p><p>Java 类库通过 <code>java.nio.channels.FileChannel</code> 类的<code>transferTo()</code> 方法支持在 Linux 和 Unix 操作系统上的zero copy 技术。你可以使用 transferTo() 方法把字节流从调用这个方法的 channel 直接转移到另一个可写的字节channel，数据不需要经过应用。本文首先会证明使用传统的复制语义会带来 overhead，然后展示使用 zero copy 技术的transferTo() 方法如何实现更好的性能</p><h3 id="Data-transfer-The-traditional-approach"><a href="#Data-transfer-The-traditional-approach" class="headerlink" title="Data transfer: The traditional approach"></a>Data transfer: The traditional approach</h3><p>考虑这样一个场景：从文件中读取数据然后通过网络把数据传输到另一个程序中(这个场景描述了很多服务应用的行为，包括提供静态内容的 web 应用，FTP 服务器，邮件服务等)，这个操作的核心代码如下 Listing1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing1 Copying bytes from a file to a socket</span></span><br><span class="line">File.read(fileDesc, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br></pre></td></tr></table></figure><p>尽管 Listing1 看起来很简单，但在内部这个 copy 操作需要在 user 模式和 kernel 模式间转换4次，数据也需要拷贝4次。下面 Figure1 展示了数据是如何从文件移动到 socket 的：</p><p>Figure1 Traditional data copying approach</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure1.png" alt></p><p>Figure2 展示了上下文的切换：</p><p>Figure2 Traditional context switches</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure2.png" alt></p><p>涉及到的步骤如下：</p><ol><li>read() 调用会导致图二中从用户模式到内核模式的切换。Figure1 中的第一次复制是通过 DMA（Direct Memory Access），从磁盘中读取文件内容然后保存到内核地址空间的buffer(CPU 不参与复制)</li><li>请求的数据从内核 read buffer 被复制到 user buffer，然后 read() 调用返回。从 call 调用返回导致上下文从内核态切换回用户态。现在数据保存在用户地址空间的buffer</li><li>socket 的 send() 方法调用使用户态再一次切换到内核态，第三次拷贝再一次把数据复制到内核地址空间的 buffer，但是这一次数据被放在了不同的 buffer，这个 buffer 与目标socket 相关联</li><li>send() 系统调用返回，导致第四次上下文切换，第四次拷贝发生在 DMA 引擎把数据从内核 buffer 传递到 protocol 引擎</li></ol><p>使用作为间接层的内核 buffer(而不是直接把数据转移到用户buffer)看起来是很低效的。但是内核缓存被引入进程却提高了性能，使用内核缓存在读取数据量不大于缓存容量的数据时，可以把应用数据缓存到内核 buffer 作为 “readahead cache”，这能很好的提高性能。同时该中间缓存允许写数据实现异步</p><p>不幸的是，<strong>当请求的数据比内核 buffer 的容量大很多时，这种方式就变成了性能瓶颈。数据在磁盘，内核 buffer，用户buffer，与应用之间被复制了多次。Zero copy 通过消除这些冗余的数据拷贝来提升性能</strong>（注：本来是为了提升性能引入的内核缓存，却在特殊的场景下成为了性能的阻碍。软件开发中通过引入中间层可以解决所有问题，但同时也会引入新的问题）</p><h3 id="Data-transfer-The-zero-copy-approach"><a href="#Data-transfer-The-zero-copy-approach" class="headerlink" title="Data transfer: The zero-copy approach"></a>Data transfer: The zero-copy approach</h3><p>如果你再看一下上面传统的复制方式，你会注意到第二次和第三次的数据拷贝并不是必须的。应用除了缓存数据然后把数据移动到 socket buffer 外，什么也没有做。事实上，数据可以从 read buffer 直接移动到 socket buffer。transferTo() 方法就是这样做的。Listing2 展示了该方法签名:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing2 The transferTo() method()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span></span>;</span><br></pre></td></tr></table></figure><p>transferTo() 方法把数据从一个文件 channel 转移到另一个可写的字节 channel，这依赖于底层的操作系统支持 zero copy；在 Unix  和各种 Linux系统中，通过 <code>sendfile()</code>系统调用来实现，在 Listing3 中展示了数据从一个文件 descriptor 转移到另一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing3 the sendfile() system call</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>在 Listing1 中的 <code>file.read()</code> 和 <code>socket.send()</code> 调用可以被 Listing4 中的一个 transferTo() 调用替换:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing4 Using transferTo() to copy data from a disk file to a socket</span></span><br><span class="line">transferTo(position, count, writableChannel);</span><br></pre></td></tr></table></figure><p>Figure3 展示了当 transferTo() 方法被调用时数据的移动：</p><p>Figure3 Data copy with transferTo()</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure3.png" alt></p><p>Figure4 展示了 transferTo 方法调用时上下文的切换</p><p>Figure4 Context switching with transferTo()</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure4.png" alt></p><p>在 Listing4 中使用 transferTo() 方法时的步骤为：</p><ol><li>transferTo 方法使文件内容通过 DMA 被拷贝到 read buffer，然后数据再被内核拷贝到与输出 socket 相关的内核buffer</li><li>第三次拷贝发生在 DMA 把数据从内核 socket buffer 传递到 protocol 引擎</li></ol><p>上面的操作发生了如下改进：我们把上下文切换从四次减少到了两次，把数据拷贝从四次减少到了三次（只有一次需要cpu参与）。但是这还没有到达我们 zero copy 的目标，我们可以进一步减少数据复制如果底层的网络接口支持 <code>gather operations</code>。在 Linux2.4 及以后的内核版本中，socket buffer descriptor 被修改用来支持该操作。这不仅减少了上下文的切换，而且消除了需要 cpu 参与的那次内存复制。客户端的使用保持不变，但是内在的操作发生了变化：</p><ol><li>transferTo() 方法使文件内容通过 DMA 被拷贝到内核buffer</li><li>没有数据被拷贝到 socket buffer。相应的，只有带有关于数据位置和数据长度信息的 descriptors 被 append 到socket buffer。DMA 直接把数据从内核缓存传递到 protocol 引擎，因此消除了仅有的那一次 cpu 拷贝</li></ol><p>Figure5 展示了使用 gather operation 的 transferTo 方法的数据拷贝过程：</p><p>Figure5 Data copies when transferTo() and gather operations are used</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/zeroCopy/figure5.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为翻译文章，原文链接为: &lt;a href=&quot;https://developer.ibm.com/technologies/java/articles/j-zerocopy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Efficient data transfer through zero copy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Zero-copy-是什么&quot;&gt;&lt;a href=&quot;#Zero-copy-是什么&quot; class=&quot;headerlink&quot; title=&quot;Zero-copy 是什么&quot;&gt;&lt;/a&gt;Zero-copy 是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.       – from Wikipedia&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="系统" scheme="https://ryan-hou.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="优化" scheme="https://ryan-hou.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster扩展性和可用性设计</title>
    <link href="https://ryan-hou.github.io/2019/10/01/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>https://ryan-hou.github.io/2019/10/01/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/</id>
    <published>2019-10-01T07:38:24.000Z</published>
    <updated>2020-04-22T09:10:50.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis-Cluster-如何解决扩展性问题"><a href="#Redis-Cluster-如何解决扩展性问题" class="headerlink" title="Redis Cluster 如何解决扩展性问题"></a>Redis Cluster 如何解决扩展性问题</h3><p>思考如下场景，当单台 redis 服务节点存储容量达到上限，不考虑加内存等垂直扩展方式，如何通过增加 redis 服务节点实现水平扩展？增加服务节点本身不是难点所在，问题在于增加了服务节点后，客户端如何确定需要访问哪个服务节点？</p><p>最简单的方式是客户端计算出 key 的哈希值后，对服务节点数量做取模运算，结果即为服务节点下标值(服务节点从零开始进行编号)。当然弊端也很明显，一旦增加或者删除节点，会导致大量缓存键失效重建，一般不会采用这种实现。</p><a id="more"></a><p>为了解决大量缓存键失效的问题，业界设计了一致性哈希算法。算法思路是将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个服务节点（使用服务器的 ip 或主机名）进行 hash 后放置到该哈希环上。这样客户端计算出 key 的哈希值后，从该值所在的哈希环位置顺时针行走，遇到的第一个服务节点就是 key 所在位置。这样在增删服务节点时，受影响的只是此节点到环空间前一个节点（逆时针方向行走）之间的数据。为了解决服务节点过少时导致的数据分布不均匀，引入了虚拟节点机制，即每一个服务节点计算多个哈希值，每个计算结果都放到哈希环上参与计算</p><h4 id="hash-slot"><a href="#hash-slot" class="headerlink" title="hash slot"></a>hash slot</h4><p>在 Redis Cluster 架构下，每个 Redis 服务节点要放开两个端口号，6379 和 16379。16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权</p><p>Redis Cluster 没有使用一致性哈希算法，而是引入哈希槽这个概念作为一个中间层解决了扩展性问题。在 Redis Cluster 总共有 16384 个 hash slot，对于每个 key，通过 CRC16 算法计算出哈希值后对 16384 取模，得到的值就是具体哪个 hash slot。对于客户端来说同一个 key 对应的 hash slot 是不会变的，由 Redis Cluster 来完成从 hash slot 到具体服务节点的映射，通过这个 hash slot，数据分片和服务节点扩容缩容完全对客户端透明</p><p>Redis 提供了一组 <code>CLUSTER SETSLOT</code> 命令来支持 hash slot 的数据在不同服务节点间迁移，通过这些命令就可以很方便的在服务节点间 resharding 数据，服务节点的增加和删除很自然也就能实现了，不存在缓存键失效的问题（因为缓存键对应的 hash slot 不变）；而且移动 hash slot 的成本是很低的，整个迁移过程可能出现对于单个 key 的访问阻塞，但是一般来说，一个 key 的数据不会特别大，所以绝大多数情况下瞬间都能完成，所以一般不会真正影响使用。上述扩展操作可以通过脚本或者统一的运维工具来实现（比如搜狐tv的 redis 运维工具 cachecloud，本人目前所在公司的 redis 管理平台就是基于该开源项目二次开发的）</p><h3 id="Redis-Cluster-如何解决可用性问题"><a href="#Redis-Cluster-如何解决可用性问题" class="headerlink" title="Redis Cluster 如何解决可用性问题"></a>Redis Cluster 如何解决可用性问题</h3><p>hash slot 通过数据分片，解决了扩展性问题。但是当其中一个服务节点不可用时，该节点上分配的所有的 hash slot 都不可用，为了增强可用性，Redis Cluster 也支持主从模式，每个主节点都可以配置一个或多个从节点，当主节点出现问题时，从节点可以提升为主节点对外继续提供服务。需要注意的是，Redis Cluster 不支持强一致性，也就是在故障转移过程中，客户端的写操作可能丢失。在性能和一致性的取舍中，Redis Cluster 默认选择了性能</p><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis cluster tutorial</a></li><li><a href="https://redis.io/commands/cluster-setslot" target="_blank" rel="noopener">CLUSTER SETSLOT slot</a></li><li><a href="https://www.jianshu.com/p/fe7b7800473e" target="_blank" rel="noopener">Redis Cluster及hash slot 算法</a></li><li><a href="https://zhuanlan.zhihu.com/p/44679936" target="_blank" rel="noopener">redis cluster的数据迁移</a></li><li><a href="https://github.com/sohutv/cachecloud" target="_blank" rel="noopener">搜狐视频(sohu tv)Redis私有云平台</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis-Cluster-如何解决扩展性问题&quot;&gt;&lt;a href=&quot;#Redis-Cluster-如何解决扩展性问题&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster 如何解决扩展性问题&quot;&gt;&lt;/a&gt;Redis Cluster 如何解决扩展性问题&lt;/h3&gt;&lt;p&gt;思考如下场景，当单台 redis 服务节点存储容量达到上限，不考虑加内存等垂直扩展方式，如何通过增加 redis 服务节点实现水平扩展？增加服务节点本身不是难点所在，问题在于增加了服务节点后，客户端如何确定需要访问哪个服务节点？&lt;/p&gt;
&lt;p&gt;最简单的方式是客户端计算出 key 的哈希值后，对服务节点数量做取模运算，结果即为服务节点下标值(服务节点从零开始进行编号)。当然弊端也很明显，一旦增加或者删除节点，会导致大量缓存键失效重建，一般不会采用这种实现。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="分布式" scheme="https://ryan-hou.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="中间件" scheme="https://ryan-hou.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Sharding &amp; IDs at Instagram</title>
    <link href="https://ryan-hou.github.io/2019/09/10/Sharding-IDs-at-Instagram/"/>
    <id>https://ryan-hou.github.io/2019/09/10/Sharding-IDs-at-Instagram/</id>
    <published>2019-09-10T15:50:26.000Z</published>
    <updated>2020-04-21T09:15:41.367Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 Instagram Engineering 博客中文章的翻译，原文链接：<a href="https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c" target="_blank" rel="noopener">Sharding &amp; IDs at Instagram</a></p><p>每秒有超过25张照片，90个 like 在 Instagram 上产生，导致应用存储了大量数据。为了保证所有重要数据可以加载入内存，并被用户快速获取，Instagram 进行了 shard(数据分片)，换句话说就是要把数据放在很多小的 bucket 中</p><p>ins 的后台服务使用 Django 框架，数据存储在 PostgreSQL中。在决定进行数据 shard 后，遇到的第一个问题就是是否仍然采用 PostgreSQL 作为主存储，还是选择别的存储方案。在调研了其他的 NoSQL 方案后，确定<strong>最适合目前场景</strong>的方案是把数据 shard 到多台 PostgreSQL 服务器上（注：虽然这里一笔带过，但是整个调研过程是很重要的）</p><p>在把数据写到这些存储服务器前，还有一个重要的问题需要解决，那就是如何为每一条数据生成一个<strong>唯一ID</strong>(例如，在我们系统中发布的每一张照片)。传统的单台数据库下使用数据库自带的自增主键在当前场景下不再适用(同一时刻需要往不同机器的数据库插入数据)。这篇文章的后半部分主要就来探讨如何解决这个问题</p><a id="more"></a><p>在开始前，我们先来明确下系统中生成的 id 需要满足哪些条件(注：明确需求是第一步，也是至关重要的一步)：</p><ul><li>1.生成的唯一 id 应该是按时间有序的(这样，一组照片 id 列表不需要再去获取照片别的字段就可以进行排序)</li><li>2.id 最好是 64bit 大小(这样可以更节省索引空间和存储空间)</li><li>3.系统应该尽可能少的引入”moving parts（即尽可能少的引入额外的依赖）”(ins 的工程师团队非常精干，之所以可以用这么少的工程师来完成应用扩展，一部分原因就在于他们会倾向于选择简单的，容易理解和让人信服的解决方案)</li></ul><h2 id="Existing-solutions"><a href="#Existing-solutions" class="headerlink" title="Existing solutions"></a>Existing solutions</h2><p>有很多已经存在的解决 ID 生成的方案，下面一些是我们调研过的：</p><h3 id="Generate-IDs-in-web-application"><a href="#Generate-IDs-in-web-application" class="headerlink" title="Generate IDs in web application"></a>Generate IDs in web application</h3><p>这种方案把ID生成的问题由数据库转移到应用层面。例如，使用<a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank" rel="noopener">MongoDB’s ObjectId</a>，一个12字节长并且把时间戳作为第一个组成部分的ID值。另一个比较流行的就是使用<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">UUIDs</a></p><p>优点：</p><ul><li>1.每一个应用线程独立产生ID值，减少了单点故障和ID集中生成的压力</li><li>2.如果你使用时间戳作为ID的第一个组成部分，那么生成的ID就是时间有序的</li></ul><p>缺点:</p><ul><li>1.为了保证唯一性，通常需要更大的存储空间(96 bits 或者更大)</li><li>2.一些UUID 类型是完全随机的，没有顺序</li></ul><h3 id="Generate-IDs-through-dedicated-service"><a href="#Generate-IDs-through-dedicated-service" class="headerlink" title="Generate IDs through dedicated service"></a>Generate IDs through dedicated service</h3><p>比较有名的就是 Twitter 开源的 <a href="https://github.com/twitter/snowflake/" target="_blank" rel="noopener">Snowflake</a>，一个使用 Apache ZooKeeper 来协调各节点生成 64bit 大小的ID值的 Thrift 服务</p><p>优点：</p><ul><li>1.Snowflake 生成的ID大小为 64bit，只有 UUID 大小的一半</li><li>2.可以使用时间戳作为第一部分从而保持有序</li><li>3.分布式服务可以避免单点故障</li></ul><p>缺点：</p><ul><li>1.需要在现有架构中引入额外的复杂度和更多的”moving parts”（ZooKeeper，Snowflake servers）</li></ul><h3 id="DB-Ticket-Servers"><a href="#DB-Ticket-Servers" class="headerlink" title="DB Ticket Servers"></a>DB Ticket Servers</h3><p>使用数据库的自增功能来保证唯一性。<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Flicker users this apprach</a>，Flickr 使用了两个 ticket DB(一个从奇数开始自增，一个从偶数开始自增，步长为2)来避免单点故障</p><p>优点：</p><ul><li>1.数据库方案易于理解而且很好预测将来的扩展问题</li></ul><p>缺点：</p><ul><li>1.最终还是会演变为写瓶颈（尽管 Flicker 声称在请求量很大的情况下不存在问题）</li><li>2.需要管理额外的两台机器（或者是 EC2 实例）</li><li>3.如果使用单台 DB，会导致单点故障，如果使用多台 DB，就不能严格保证它们是按时间有序的</li></ul><p>在上面所有的方案中，Twitter 的 Snowflake 是最接近我们理想方案的，但是需要引入额外的复杂性和ID生成服务。所以我们采用了一种概念上相似，但是在 PostgreSQL 内实现的方案（注：类 Snowflake 方案是业界比较普遍使用的方案，美团的 Leaf 也是基于 Snowflake 来设计的）</p><h2 id="Our-solution"><a href="#Our-solution" class="headerlink" title="Our solution"></a>Our solution</h2><p>我们的分片系统由几千个“逻辑”上的分片映射到远少于逻辑分片的物理机器上。通过这种方式，起始我们只需要几个数据库服务器即可，后续扩展也很方便，需要做的就是把一台数据库服务器上的部分逻辑分片的数据转移到别的数据库服务器上，而不需要重新对数据进行分桶。我们借助了 Postgre 的 schema 特性来使这一切很容易的脚本化和管理</p><p>Schemas(不要与 SQL 定义表结构的 schema 混淆) 是 Postgres 中提供的逻辑分组的特性。每一个 Postgres 数据库可以有多个 schema，每一个 schema 可以包含一个或者多个表。<strong>表的名字必须是 schema 唯一的，而不用是数据库唯一的 (注：相当于在数据库的物理存储之上增加了一层，从而提供了很大的灵活性，引入中间层是常见的问题解决方案)</strong>，默认情况下 Postgres 把所有东西存储在一个叫做 public 的 schema 下</p><p>在我们的系统中，每一个逻辑的分片都是一个 Postgres schema，每一个 sharded 表（比如存储照片数据的表）都存在于一个 schema 中</p><p>我们使用 Postgres 内部提供的编程语言 PL/PGSQL 和 Postgres 提供的自增功能来为每一个 shard 中的表生成ID</p><p>每一个ID的构成如下：</p><ul><li>41bits 用来存储毫秒时间（使用我们自定义的 epoch 可以表示41年的时间范围）</li><li>13bits 存储逻辑分片ID</li><li>10bits 存储一个自增的序列值，对1024取模。这意味着每一个 shard，每一毫秒我们可以生成1024个ID</li></ul><p>我们来看个例子：假如现在是 September 9th, 2011, at 5:00pm 并且我们的 epoch 从 January 1st, 2011 开始。那么从我们的 epoch 开始，总共1387263000毫秒，所以我们通过左移来保存ID的最开始的41bits：<code>id = 1387263000 &lt;&lt;(64-41)</code></p><p>接下来我们取当前要插入的数据的 shard ID，比如说我们通过用户id来 sharding，并且已知有2000个逻辑分片，如果我们的用户id是 31341，那么我们的 shard ID 是 31341%2000 ＝ 1314，然后我们填充我们ID值的接下来的13bits：<code>id |= 1341 &lt;&lt;(64-41-13)</code></p><p>最后，我们取数据库表的自增id值来填充剩下的 bits 位（这个序列对于每一个 schema 下的每一个表是唯一）。假设说我们已经为当前的表生成了 5000 个id，那么下一个值就是5001，对1024 取模后就可以放到我们id值的最后10bit中：<code>id |= (5001 % 1024)</code></p><p>现在我们已经获得了完整的ID值，在插入数据时通过<strong>RETURN</strong>关键字可以把这个ID值返回给应用</p><p>下面是 PL/PGSQL 的代码实现（以 schema insta5 为例，5 表示 shard id 为5）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> insta5.next_id(<span class="keyword">OUT</span> <span class="keyword">result</span> <span class="built_in">bigint</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    our_epoch <span class="built_in">bigint</span> := <span class="number">1314220021721</span>;</span><br><span class="line">    shard_id int := 5;</span><br><span class="line">    seq_id bigint;</span><br><span class="line">    now_millis bigint;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">nextval</span>(<span class="string">'insta5.table_id_seq'</span>) %% <span class="number">1024</span> <span class="keyword">INTO</span> seq_id;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="keyword">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> clock_timestamp()) * <span class="number">1000</span>) <span class="keyword">INTO</span> now_millis;</span><br><span class="line">    result := (now_millis - our_epoch) &lt;&lt; 23;</span><br><span class="line">    result := result | (shard_id &lt;&lt; 10);</span><br><span class="line">    result := result | (seq_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">    $$ LANGUAGE PLPGSQL</span><br></pre></td></tr></table></figure><p>在建表时我们执行下面操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TAbLE</span> insta5.out_table &#123;</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> insta5.next_id(),</span><br><span class="line">    ... rest <span class="keyword">of</span> <span class="keyword">table</span> schma ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是我们应用中唯一主键的生成过程(这里还有一个额外的好处，在这个主键中包含了shard ID，方便我们进行匹配)。我们把这个实现部署到了生产环境并对目前的结果很满意。有兴趣帮我们在业务继续扩展时改进这个方案吗？<a href="https://www.instagram.com/about/jobs/" target="_blank" rel="noopener">We’re hiring</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为 Instagram Engineering 博客中文章的翻译，原文链接：&lt;a href=&quot;https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sharding &amp;amp; IDs at Instagram&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每秒有超过25张照片，90个 like 在 Instagram 上产生，导致应用存储了大量数据。为了保证所有重要数据可以加载入内存，并被用户快速获取，Instagram 进行了 shard(数据分片)，换句话说就是要把数据放在很多小的 bucket 中&lt;/p&gt;
&lt;p&gt;ins 的后台服务使用 Django 框架，数据存储在 PostgreSQL中。在决定进行数据 shard 后，遇到的第一个问题就是是否仍然采用 PostgreSQL 作为主存储，还是选择别的存储方案。在调研了其他的 NoSQL 方案后，确定&lt;strong&gt;最适合目前场景&lt;/strong&gt;的方案是把数据 shard 到多台 PostgreSQL 服务器上（注：虽然这里一笔带过，但是整个调研过程是很重要的）&lt;/p&gt;
&lt;p&gt;在把数据写到这些存储服务器前，还有一个重要的问题需要解决，那就是如何为每一条数据生成一个&lt;strong&gt;唯一ID&lt;/strong&gt;(例如，在我们系统中发布的每一张照片)。传统的单台数据库下使用数据库自带的自增主键在当前场景下不再适用(同一时刻需要往不同机器的数据库插入数据)。这篇文章的后半部分主要就来探讨如何解决这个问题&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="分布式" scheme="https://ryan-hou.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从简单模式匹配到KMP算法</title>
    <link href="https://ryan-hou.github.io/2019/06/22/%E4%BB%8E%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%88%B0KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://ryan-hou.github.io/2019/06/22/%E4%BB%8E%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%88%B0KMP%E7%AE%97%E6%B3%95/</id>
    <published>2019-06-21T23:45:01.000Z</published>
    <updated>2020-04-22T03:29:32.560Z</updated>
    
    <content type="html"><![CDATA[<p>在日常编程中，字符串的使用是相当频繁的，从一个文本串中找到另一个我们需要的子串是常见的场景，所以有必要了解一下模式匹配的知识</p><p>本文主要从思路上来比较简单模式匹配与 KMP 算法的不同之处，体会<strong>解决问题的思路</strong>对于算法设计的重要性。当然程序的编写也有用到一些技巧，不过技巧这种东西随着不断练习只是时间问题，而思路这东西就未必了，尤其是原创性的思路</p><a id="more"></a><p>先从最简单的模式匹配算法开始说，面对这样一个问题：给定一个文本串和模式串，要求我们从文本串中查找是否存在模式串，如果存在则返回文本串中开始匹配模式串的位置，否则返回 -1。看到这个问题我们不难得到一种简单直观的思路：</p><p>保持模式串不动，用文本串第一个字符与模式串第一个字符比较，如果相等，继续比较文本串和模式串的下一个字符；如果不相等，文本串左移一个字符，下一次从第二个字符开始再次与模式串从头比较 ；如果匹配成功则返回开始匹配的位置，否则返回-1即可</p><p>这种思路其实是一种遍历的方式，找出文本串中从任一位置开始的可能情况，这里说成<strong>模式串不动，文本串每次左移一个单位</strong>会更直观一些。这属于一种<strong>暴力解法</strong>，算法的时间复杂度为<code>O(m*n)</code>(m,n为文本串和模式串的长度)。反正不论什么问题，穷举法总是可以得到正确答案，计算机嘛，这点比我们强多了，算得快，慢慢试呗，不过这种方法总觉得有点”low”啊，下面来看下大牛解决问题的思路</p><p>模式匹配的 KMP 算法：这里 KMP 三个字母分别为三位大神名字的首字母（K 我们比较熟悉了，<a href="http://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">Donald Knuth</a>）KMP 这个算法的思路很巧妙，对比上面介绍的简单算法，这里先把 KMP 算法概括为一句话：<strong>文本串固定不动，模式串右移进行匹配</strong></p><p>先回想一下我们第一个算法的弊端，时间复杂度为<code>O(m*n)</code>，分析一下不难得出原因，每次匹配失败，不管匹配了多少个字符，我们的文本串<strong>仅仅左移一个字符的位置</strong>，文本串本来就很长，这样匹配就太慢了，做了好多无用功。所以 KMP 算法的主要想法就是<strong>在比较失败时，尽可能快的让模式串全部比较完，而不是简单的从头开始。</strong>怎么做呢？这里通过右移模式串的方式来实现，那么问题来了，怎么右移模式串呢？这里需要我们了解关于前缀串和后缀串的知识，还有一个用来记录最长匹配长度的 next 数组(求next数组就是整个算法的关键问题了)，下面通过例子和代码具体说明。</p><p>我们先来人工求一个 next 数组感受一下这是怎样一个过程，在进行匹配时，模式串匹配失效的位置前面的子串我们称为S串。假设模式串为 <strong>ABABABB</strong></p><p>对于一个给定字符串，求最大匹配的前缀串和后缀串我们应该比较熟悉，而 next 数组记录的就是这个最大匹配的长度：</p><ul><li>当模式串第一个字符与文本串第一个字符不匹配时，从文本串的下一个位置与模式串继续比较，next[0] 设置为-1来表示这种特殊情况</li><li>当模式串第二个字符与文本串对应位置不匹配时，此时S串为A，不存在匹配的前缀串和后缀串，next[1] 设置为0</li><li>当模式串第三个字符与文本串对应位置不匹配时，此时S串为AB，不存在匹配的前缀串和后缀串，next[2] 设置为0</li><li>当模式串第四个字符与文本串对应位置不匹配时，此时S串为ABA，存在最大匹配的前缀串和后缀串A，next[3]设置为1</li><li>当模式串第五个字符与文本串对应位置不匹配时，此时S串为ABAB，存在最大匹配的前缀串和后缀串AB，next[4]设置为2</li><li>依次类推，可得<code>next = {-1, 0, 0, 1, 2, 3, 4}</code></li></ul><p>通过这个过程我们应该发现了，求 next 数组的过程存在一个递归调用：如果我们已经求出了<code>next[n]</code>的数值，如何求<code>next[n+1]</code>？假设<code>next[n]=k</code>，即0到 k-1 位置的子串与 n-k 到 n-1 位置的子串是匹配。这里分为两种情况：</p><ul><li>模式串下标 k 处的字符与 n 处的字符匹配，即0到k位置的子串与n-k到n位置的子串匹配，显然有 <code>next[n+1] = next[n] + 1 = k + 1</code></li><li>模式串下标k处的字符与n处的字符不匹配，这时我们需要<strong>对0到k-1位置的字符串递归的使用模式匹配</strong>，也就是为了消除n处的不匹配，我们需要“缩短”0到k-1位置的子串为0到next[k]（这个也比较好证明，根据next数组的定义作个图即可明白）<br>求 next 数组的代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNextArray</span><span class="params">(String needle, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] source = needle.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; needle.length(); i++) &#123;</span><br><span class="line">        fillNext(source, next, i, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillNext</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span>[] next, <span class="keyword">int</span> i, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next[pre] == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//  递归出口</span></span><br><span class="line">        next[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source[i - <span class="number">1</span>] == source[next[pre]]) &#123;</span><br><span class="line">            next[i] = next[pre] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            fillNext(source, next, i, next[pre]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给出 KMP 算法的代码前，我们还需要清楚关于模式串移动的问题。其实这个思路也不难理解，因为我们在前面是根据最大匹配的前缀串和后缀串来求得next数组，比如假设 <code>next[j] = k</code>，这代表j位置之前的模式串子串中，有最大长度为k的相同前缀和后缀(也就是0到k-1位置的子串与j-k到j-1位置的子串完全一样)。<strong>当模式串在j处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串右移<code>j - next[j]</code>，</strong>下面给出KMP算法的具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String haystack, String needle, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] source = haystack.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] pattern = needle.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pattern.length &amp;&amp; j &lt; source.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == source[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line">    <span class="keyword">return</span> j == pattern.length ? i - pattern.length : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过固定文本串，右移模式串的方式，我们可以在某一位置匹配失败时对文本串进行快速的检索，而不是按部就班的一个字符一个字符的移动文本串，整个算法的时间复杂度变为<code>O(m+n)</code>，为线性时间</p><p>KMP 算法的设计思路的确很巧妙，虽然整个思路不难理解，但是很多细节还是比较琐碎，建议不太清楚的时候在纸上演算一下运行过程以加深理解，尤其是对于next数组的求解部分和移动距离的理解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常编程中，字符串的使用是相当频繁的，从一个文本串中找到另一个我们需要的子串是常见的场景，所以有必要了解一下模式匹配的知识&lt;/p&gt;
&lt;p&gt;本文主要从思路上来比较简单模式匹配与 KMP 算法的不同之处，体会&lt;strong&gt;解决问题的思路&lt;/strong&gt;对于算法设计的重要性。当然程序的编写也有用到一些技巧，不过技巧这种东西随着不断练习只是时间问题，而思路这东西就未必了，尤其是原创性的思路&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="https://ryan-hou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载器</title>
    <link href="https://ryan-hou.github.io/2019/06/01/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://ryan-hou.github.io/2019/06/01/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2019-06-01T13:42:58.000Z</published>
    <updated>2020-04-17T07:19:20.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载器是什么"><a href="#类加载器是什么" class="headerlink" title="类加载器是什么"></a>类加载器是什么</h2><p>定义摘自<code>深入理解Java虚拟机</code></p><blockquote><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。而实现这个动作的代码模块称为“类加载器”</p></blockquote><p>从上面的定义中，我们可以得到如下信息：</p><a id="more"></a><ul><li>类加载器的作用：获取描述此类的二进制字节流，也就是 <code>.class</code> 文件，那么什么是 <code>.class</code> 文件？</li><li>获取类的二进制字节流只是类加载阶段中的一部分，那么整个类加载过程是怎样的？</li><li>类加载器的目的是让应用程序自己决定如何获取需要的类，这样做有什么好处？换句话说，我什么时候可能需要自己定义一个类加载器？</li></ul><h2 id="关于类加载涉及的一些定义"><a href="#关于类加载涉及的一些定义" class="headerlink" title="关于类加载涉及的一些定义"></a>关于类加载涉及的一些定义</h2><h3 id="class-文件"><a href="#class-文件" class="headerlink" title="class 文件"></a>class 文件</h3><p>每个 <code>.class</code> 文件都对应着唯一一个类或者接口的定义信息，该文件是一个二进制字节流，每个字节的数据都有严格的定义和顺序。虚拟机通过该文件实现了语言无关性，其他编程语言也可以编译为 <code>.class</code> 文件，然后使用 JVM</p><h3 id="类加载的步骤"><a href="#类加载的步骤" class="headerlink" title="类加载的步骤"></a>类加载的步骤</h3><p>包括加载，验证，准备，解析和初始化，其中验证，准备和解析合称为连接。类型的加载，连接和初始化都是在程序运行期间完成的，增加了类加载带来的性能负担但是提高了灵活性，比如：</p><blockquote><p>编写一个面向接口的应用程序，可以等到运行时再指定其实现类；用户可以通过自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分，这种组装程序的方式广泛应用于 Java 程序之中，如 JSP，OSGi 等</p></blockquote><h3 id="加载与类加载"><a href="#加载与类加载" class="headerlink" title="加载与类加载"></a>加载与类加载</h3><p>加载是类加载的第一个步骤，加载阶段虚拟机完成三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流，也就是<strong>类加载器实现的功能</strong></li><li>将这个字节流所代表的静态存储结构转为方法区的运行时数据结构</li><li>在堆内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口</li></ul><h2 id="类加载器的-parent-delegation-model"><a href="#类加载器的-parent-delegation-model" class="headerlink" title="类加载器的 parent-delegation model"></a>类加载器的 parent-delegation model</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>parent-delegation model 中文通常翻译为双亲委派模式，这里的“双亲”其实翻译的不准确，存在误导，父辈代理模型可能更恰当。为了沿用中文习惯，下文还是以双亲委派模型来指代。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（在它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。模型如下图：</p><p><img src="http://ryan-hou.github.io/assets/img/blogPic/classLoader.png" alt></p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>实现双亲委派的代码集中在 <code>java.lang.ClassLoader</code> 类的 <code>loadClass()</code> 方法中，很清晰易懂：先检查是否已被加载过，若没有则递归调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类的加载器作为父加载器。如果父加载器加载不到该类，再调用自己的 <code>findClass()</code> 方法进行加载</p><h3 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h3><p>保证 Java 程序稳定运行</p><blockquote><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</strong>例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果自己去编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但永远无法被加载运行</p></blockquote><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下应用使用默认的系统类加载器（AppClassLoader）就可以满足要求，但如果我们需要加载远程服务器的类，或者说加载网络上的不是本机上的类的时候，就需要自定义类加载器</p><p>自定义类加载器实现过程：</p><ul><li>继承 ClassLoader 类</li><li>如果只是想重新定义如何获取字节码文件的字节流，只需重写 <code>findClass()</code> 方法即可。如果需要打破默认的双亲委派模式，则需要重写 <code>loadClass()</code> 方法</li></ul><p>在 <code>ClassLoader</code> 抽象类中，有三个重要的方法：</p><ul><li><code>loadClass(String name, Boolean reslove)</code>方法，该方法前面说过了，实现了双亲委派模型，一般不重写</li><li><code>defineClass(String name, byte[] b, int off, int len)</code> 用于将原始字节码转为 Class 对象，通过 JNI 实现，一般也不用重写</li><li><code>findClass(String name)</code>方法，根据类的 binary name 来查找类的数据，把找到的 <code>.class</code> 文件的内容加载到内存的字节数组，供 defineClass() 方法使用，一般我们会改写这个方法，这里前面也描述过，一旦所有的父加载器无法加载到对应的类，就会调用自己的 <code>findClass(String name)</code> 方法来加载</li></ul><p>下面举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String CLASSLOADER_NAME;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String PATH = <span class="string">""</span>; <span class="comment">// .class file's location</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FILE_TYPE = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.CLASSLOADER_NAME = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String filePath = PATH + name + FILE_TYPE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(filePath));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (index = in.read())) &#123;</span><br><span class="line">                baos.write(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = baos.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            log.error(<span class="string">"File not found error, file path = &#123;&#125;"</span>, filePath, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"read class file error!"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"close io stream error!"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end finally</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类加载器是什么&quot;&gt;&lt;a href=&quot;#类加载器是什么&quot; class=&quot;headerlink&quot; title=&quot;类加载器是什么&quot;&gt;&lt;/a&gt;类加载器是什么&lt;/h2&gt;&lt;p&gt;定义摘自&lt;code&gt;深入理解Java虚拟机&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机设计团队把类加载阶段中的“通过一个类的全限定名获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。而实现这个动作的代码模块称为“类加载器”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的定义中，我们可以得到如下信息：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://ryan-hou.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>null awareness</title>
    <link href="https://ryan-hou.github.io/2019/04/07/null-awareness/"/>
    <id>https://ryan-hou.github.io/2019/04/07/null-awareness/</id>
    <published>2019-04-07T14:30:20.000Z</published>
    <updated>2020-04-08T07:05:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>前面翻译了一篇关于如何合理使用 null 的文章:<a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a>，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的</p><h3 id="null-是什么"><a href="#null-是什么" class="headerlink" title="null 是什么"></a>null 是什么</h3><p>null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:</p><a id="more"></a><ul><li>null 是关键字，大小写敏感</li><li>null 既不是对象也不是一种类型，它仅是一个<strong>特殊值</strong>，你可以将它赋予任何引用类型，你也可以将 null 强制转化为任何引用类型</li><li>可以使用 == 和 = 来操作 null 值，但是不能使用其他逻辑操作，在 Java 中 <code>null == null</code> 返回 true</li><li>使用作为引用类型变量默认值的 null，instanceof 操作符将会返回 false</li></ul><h3 id="null-带来的问题"><a href="#null-带来的问题" class="headerlink" title="null 带来的问题"></a>null 带来的问题</h3><p>null 本身不是一个对象，通过 null 访问对象的成员方法或者成员变量(解引用)会导致空指针异常(NPE)；由于我们很容易忽略判断一个对象是否为 null，所以想当然的进行解引用操作时会带来 NPE 问题</p><h3 id="如何规避-null-的问题"><a href="#如何规避-null-的问题" class="headerlink" title="如何规避 null 的问题"></a>如何规避 null 的问题</h3><p><strong>意识非常重要，意识非常重要，意识非常重要</strong>，重要的事情说三遍！当我们拿到一个引用类型的变量时，条件反射的就要考虑这个变量是不是 null，如果是 null 该怎么处理？我自己写的代码导致了 NPE 时，我总会反思自己: 代码里的 NPE 都解决不了，难怪现实中也没对象……</p><p>有了上面的意识，下面再介绍一些实用的方法来规避 NPE。部分内容在 <a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a> 也有提到，可以互为参考。</p><p>既然 NPE 的源头在于 null，那么避免使用 null 就可以从源头上解决这个问题。比如可以使用 Guava 提供的 <code>ImmutableMap, ImmutableList</code> 等不允许元素为 null 的集合类。尽量不要用 null 来初始化变量，函数尽量不要返回 null。对于必须要用 null 的场景考虑单独定义相应的 null object</p><p>采用防御性编程。作为函数作者，我们要对入参进行必要的校验，不允许参数为空时直接抛出异常而不是继续执行。由函数的调用者对程序异常负责；尽量不返回 null，比如可以返回 Optional 对象，或者 null object</p><p>作为函数调用者，要对返回值是否为 null 保持敏感。明确返回的 null 值含义，进行相应的检查和处理。比如远程调用时，对于返回值通常要进行判空处理</p><p>使用 @NotNull 和 @Nullable 注解配合 IntelliJ 尽量在早期发现和预防 NPE</p><p>对于链式调用要格外注意，很容易在某个调用过程发生 NPE。比如 <code>obj.methodA().methodB().methodC()</code></p><p>警惕包装类型的自动装箱和拆箱。相比基本数据类型，包装类型存在 null 这个默认值，在自动拆箱时很容易 NPE。而且正是由于这个语法糖，我们会下意识的把包装类和基本类型等同，实际上两者是很不一样的。所以对于这个语法糖我个人持弊大于利的观点。总之，在使用包装类型时，要格外留心，他们是包装类型而不是基本类型，不能闭着眼睛混用！</p><p>以上是对于 null 的总结，概括来说，就是<strong>要时刻对于 null 这个 corner case 保持警惕，然后采取合理的处理方式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面翻译了一篇关于如何合理使用 null 的文章:&lt;a href=&quot;https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/&quot;&gt;Using and avoiding null&lt;/a&gt;，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的&lt;/p&gt;
&lt;h3 id=&quot;null-是什么&quot;&gt;&lt;a href=&quot;#null-是什么&quot; class=&quot;headerlink&quot; title=&quot;null 是什么&quot;&gt;&lt;/a&gt;null 是什么&lt;/h3&gt;&lt;p&gt;null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="经验" scheme="https://ryan-hou.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Using and avoiding null</title>
    <link href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/"/>
    <id>https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/</id>
    <published>2019-04-06T15:50:20.000Z</published>
    <updated>2020-04-08T02:58:57.690Z</updated>
    
    <content type="html"><![CDATA[<p>文章翻译自 Google Guava 文档，原文链接: <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Using and avoiding null</a></p><h3 id="Why-avoid-null？"><a href="#Why-avoid-null？" class="headerlink" title="Why avoid null？"></a>Why avoid null？</h3><blockquote><p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p></blockquote><p>随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的</p><a id="more"></a><p>此外，null 非常有歧义性。很难从返回的 null 得到具体的含义－－例如，<code>Map.get(key)</code> 返回 null，既可能是因为该 key 对应的 value 是 null，也可能是因为该 key 不存在。null 可以表示失败，也可以表示成功，可以表示几乎所有东西。使用其他表意更清晰的东西而不是 null 可以增强代码可读性</p><p>上面说了，绝大部分情况下都不要随意使用 null，同时这也说明了 null 在一些场景下的使用是合理的。从内存和速度的角度来看，使用 null 很”廉价”，而且在对象数组中也不可避免。不同于类库，在应用代码中，null 通常会因表义不清，进而带来歧义和奇葩的 bug－－比如，当 <code>Map.get</code> 返回 null，它可以表示值不存在或者值存在但是为 null。更要命的是，null 不会给 null 值本身到底意味着什么提供任何提示</p><p>综上原因，只要存在可以方便使用 null 的 workaround，Guava 中相应的很多工具类都采用 fail fast 策略拒绝 null 值。此外，Guava 提供了很多工具避免你使用 null，或者在你必须要使用 null 时用起来更简单</p><h3 id="Specific-Cases"><a href="#Specific-Cases" class="headerlink" title="Specific Cases"></a>Specific Cases</h3><p>如果你想要在 <code>Set</code> 或者 <code>Map</code> 的 key 中使用 null，不要这么做！在查询操作中单独定义关于 null 值的 <strong>special-case</strong> 会使代码更加清晰</p><p>如果你想在 <code>Map</code> 中使用值为 null 的 value，那么把这个键值对单独定义出来。把 <code>Set</code> 中非空的 key (或者为空的 key)单独定义。因为我们很容易把 Map 中不存在某个 key 和 Map 中存在某个 key，该 key 对应的 value 值为 null 这两种完全不同的情景搞混。把这样的 key 单独定义出来要好得多，同时这样会<strong>强迫你去思考</strong>你的应用中一个 key 对应的 value 值为空，是怎样的一种场景</p><p>如果你在 <code>List</code> 中使用 null，而这个 List 是稀疏的，可能定义一个 <code>Map&lt;Integer, E&gt;</code> (key 为 List 元素的下标值，value 为对应的 List 元素)会让代码更加高效，同时也可能更符合你的需求</p><p>考虑一下是否存在一个 “null object” 可以使用，这种情况不总是存在，但是有些场景，比如一个枚举类可以加一个常量来代表你希望 null 值所表示的含义。例如，在 <code>java.math.RoundingMode</code> 中有一个 <code>UNNECESSARY</code> 值来表示 “do no rounding, and throw an exception if rounding would be necessary.”</p><p>如果你确实需要 null 值，那就不要使用 null-hostile 的集合类（比如 <code>ImmutableList, ImmutableMap</code>），可以使用支持 null 的集合类实现。比如，使用 <code>Collections.unmodifiableList(Collection&lt;? extends T&gt; c)</code> 而不是 <code>ImmutableList</code></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>注: JDK 1.8 中已经引入了类似的 Optional 工具类，基本思想是一致的: null 指针之所以存在问题，是因为你可以在不检查 null 的情况下访问对象的成员方法和成员变量(null 解引用导致 NPE)。使用 Optional 可以强迫你去思考 null 这种情况或者通过类似 <code>ifPresent(Consumer&lt;? super T&gt; consumer)</code> 这样的方法把判断是否为 null 和访问操作合二为一，只有不为 null 时才能进行相应操作</p><p>在很多场景下，我们程序员使用 null 是用来<strong>表示某种缺失</strong>：在某个地方可能会存在一个值，但是现在没有或者找不到。<code>Optional&lt;T&gt;</code> 把可为空的引用T替换为一个非空的 Optional 值。一个 Optional 要么包含一个非空的引用T(在这种场景下我们说这个引用是 <strong>present</strong> 的)，要么什么也不包含（在这种场景下，我们说这个引用是 <strong>absent</strong> 的）。即引用要么 present 要么 absent，不存在 <strong>contain null</strong>，避免产生歧义</p><p>下面列一些常用的操作：（注: 下述方法均为 JDK 中 <code>Optional&lt;T&gt;</code> 类的方法，使用方式和 Guava 基本一致 ）</p><h4 id="Making-an-Optional"><a href="#Making-an-Optional" class="headerlink" title="Making an Optional"></a>Making an Optional</h4><p>Optional 中的静态方法:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>Make an Optional containing the given non-null value, or fail fast on null.</td></tr><tr><td>Optional.ofNullable(T)</td><td>Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.</td></tr></tbody></table><h4 id="Query-methods"><a href="#Query-methods" class="headerlink" title="Query methods"></a>Query methods</h4><p>下面是常用的实例方法</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>boolean isPresent()</td><td>Returns true if this Optional contains a non-null instance.</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</td></tr><tr><td>T get()</td><td>Returns the contained T instance, which must be present; otherwise, throws an NoSuchElementException</td></tr><tr><td>T orElse(T other)</td><td>Return the value if present, otherwise return other.</td></tr><tr><td>Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></td><td>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an Optional describing the result.  Otherwise return an empty Optional.</td></tr></tbody></table><p>Optional 还提供了其它有用的方法，具体信息可以去看 Javadoc</p><h4 id="What’s-the-point"><a href="#What’s-the-point" class="headerlink" title="What’s the point?"></a>What’s the point?</h4><p>除了通过给 null 一个名字(缺失与否)来增强可读性，Optional 带来的最大好处在于它是 idiot-proof-ness 的，它迫使你去思考 absent 的场景到底是怎样的，否则你的程序可能会编译不过去，因为你必须手动 unwrap the Optional 并处理 absent 的情况。直接使用 null 使这些情况很容易被忽略，尽管 FindBugs 也可以提供帮助，但是我们不认为它能像 Optional 一样解决这个问题</p><p><strong>当返回一个可能存在或者可能不存在的值时，使用Optional 更加有用。</strong>对于 <code>other.method(a, b)</code>方法，相比我们在实现这个方法时忘记判断 a,b 可能为 null 这种情况，我们更容易忘记这个方法可能会返回 null。而返回 Optional 则使调用者不可能忘记处理这种情况，因为他们必须 unwrap 这个对象来使他们的代码能编译</p><h3 id="Convenience-methods"><a href="#Convenience-methods" class="headerlink" title="Convenience methods"></a>Convenience methods</h3><p>无论何时你想使用一个默认值来代替 null，可以使用 <code>MoreObjects.firstNonNull(T, T)</code>，正如该方法的名字所示，如果两个输入都是 null，该方法会通过抛出NPE来实现 fail fast。如果你在使用 Optional 对象，那么 <code>first.orElse(second)</code> 是更好的替代方法</p><p>在<code>Strings</code>类中提供了几个处理可能为空的方法，而且我们专门定义了恰当的名字：</p><ul><li>emptyToNull(String)</li><li>isNullOrEmpty(String)</li><li>nullToEmpty(String)</li></ul><p>我们想强调一下，这些方法主要是用来处理那些把 null 字符串和 empty 字符串等同看待的API。每当你写出把 null 和 empty 字符串混用的代码，Guava 团队的小伙伴都”哭了”(null 字符串和 empty 字符串混用通常是令人不安的 code smell)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章翻译自 Google Guava 文档，原文链接: &lt;a href=&quot;https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using and avoiding null&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Why-avoid-null？&quot;&gt;&lt;a href=&quot;#Why-avoid-null？&quot; class=&quot;headerlink&quot; title=&quot;Why avoid null？&quot;&gt;&lt;/a&gt;Why avoid null？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“Null sucks.” -Doug Lea&lt;br&gt;&lt;br&gt;&lt;br&gt;“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>作用域与闭包</title>
    <link href="https://ryan-hou.github.io/2019/03/08/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>https://ryan-hou.github.io/2019/03/08/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</id>
    <published>2019-03-08T15:16:52.000Z</published>
    <updated>2020-04-13T08:46:12.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>简单来说一句话：<strong>带上下文的函数</strong>，下面展开说明一下</p><p>声明：接下来的部分内容来自对 StackOverflow 回答的翻译，原答案链接 <a href="http://stackoverflow.com/questions/36636/what-is-a-closure" target="_blank" rel="noopener">What is a ‘Closure’?</a></p><p>要想理解好闭包，首先要弄清楚 <code>Scope</code>，当我们声明一个局部变量时，这个变量会有一个 Scope，通常局部变量仅在声明它的 block 或 function 中有效，比如下面 JS 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// fails</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>当我们访问一个局部变量时，大部分语言会先在当前 Scope 中寻找这个变量，找不到再去该 Scope 的父 Scope 中去寻找，直到找到根 Scope 为止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br></pre></td></tr></table></figure><p>当一个 block 或者 function 结束时，他的局部变量会被清理掉，这符合我们的预期</p><h3 id="闭包是持有局部变量的持续存在的-Scope"><a href="#闭包是持有局部变量的持续存在的-Scope" class="headerlink" title="闭包是持有局部变量的持续存在的 Scope"></a>闭包是持有局部变量的持续存在的 Scope</h3><p>闭包是一个持续存在的 Scope，该 Scope 会持有局部变量，即使在代码执行结束并跳出局部变量所在的 block 仍然有效。支持闭包的语言(如 JS，Swift 和 Ruby)允许你持有一个指向 Scope 对象(包括他的 parent scopes)的引用，即使在这些变量被声明的 block 执行完，你仍然可以在其他的地方持有指向这个 block 或者 function 的引用</p><p><strong>这些 Scope 对象和在该 Scope 下的局部变量被绑定到 function，并且只要该 function 存在，那么这些局部变量就存在 (函数和函数声明时的 scope 共存亡)</strong></p><p>这给我们使用函数提供了便利性，<strong>在函数第一次被声明的 Scope 中的局部变量会始终保持在该 Scope 中，即使我们下次从不同的 context 调用该 function 依然可以得到该局部变量</strong></p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">// works</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this returns a function</span></span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute outer to get inner</span></span><br><span class="line"><span class="keyword">var</span> fuc = outer(); </span><br><span class="line"><span class="comment">// prints the value of a, which is 1</span></span><br><span class="line">fuc(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面在一个函数中定义了一个函数，内部的函数可以访问外部函数所有的局部变量，包括 <code>a</code>，变量 a 在内部函数的父 Scope 中</p><p>通常当一个函数退出，他所声明的所有的局部变量都会被回收，然而在这里，当我们返回内部函数并把它指向变量 fnc 时，外部函数(outer)退出后，<strong>在内部函数(inner)被定义的 Scope 中的所有的局部变量会持续存在。</strong><code>变量a within a closure.</code></p><p><strong>在上面的例子中，变量 a 完全是 fnc 函数私有的(函数加数据)，这为我们在函数式语言中创建私有变量提供了一种方式。(函数加上私有变量, 是不是看起来很像 OOP 中的对象(方法加上数据), 确实可以基于 Closure 构建对象系统 )</strong></p><p>上面的示例代码中，a 属于 <code>outer</code> scope，<code>inner</code> scope 存在一个指向父scope<code>outer</code>的指针。<code>fnc</code> 是一个指向 <code>inner</code> 的变量，a 会和 <code>fnc</code> 共存亡，a 在闭包中</p><p>以上，翻译结束，下面再对照下 OO 下的闭包</p><h2 id="OO-化的闭包"><a href="#OO-化的闭包" class="headerlink" title="OO 化的闭包"></a>OO 化的闭包</h2><p>在 JS 中，函数是一等公民，可以作为参数或者返回值传递，可以用于高阶函数，但是在 Java 中，函数不能独立存在，需要依附于类或者对象(函数在类中被称为方法，其实函数应该是可以单独存在的一种抽象)，正因此才有了类似函数对象，命令模式等一些东西，看似高大上，实际上是编程语言的限制带来的无奈之举</p><p>有人曾说过，<strong>类是带函数的数据，闭包是带数据的函数</strong>，上面我们看到了在 JS 中是如何使用闭包的，下面我们看一下在 OO 中如何使用闭包</p><p>在 <code>Thinking in Java</code> 中对于闭包与回调一节曾提到过：</p><blockquote><p>闭包(closure)是一个可调用的对象，它记录了一些信息，这些信息来自于创建他的作用域。通过这个定义，可以看出<strong>内部类是面向对象的闭包</strong>，因为他不仅包含外围类对象(创建内部类对象的作用域)的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类对象有权操作外部类对象所有的成员，包括 private 成员</p></blockquote><p>举个例子(代码修改自 <code>Thinking in Java</code>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callee</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other methods...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise you'd</span></span><br><span class="line">            <span class="comment">// get an infinite recursion:</span></span><br><span class="line">            Callee.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementable callbackReference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackReference = callbackReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Other operations...</span></span><br><span class="line">        <span class="comment">// 调用回调接口</span></span><br><span class="line">        callbackReference.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee c = <span class="keyword">new</span> Callee();</span><br><span class="line">        Caller caller = <span class="keyword">new</span> Caller(c.getCallbackReference());</span><br><span class="line">        caller.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中，内部类 Closure 实现了 Incrementable，以提供一个返回 Callee 的“钩子”，而且是一个安全的钩子，无论谁获得此 Incrementable 的引用，都只能调用 increment() (如果直接使用 Callee 类的实例作为钩子，该钩子还可以调用 Callee 类的其它方法，控制的力度不够细)，除此之外没有其他的功能。Caller 的构造器需要一个 Incrementable 的引用作为参数 (也可以通过 set 方法注入的方式在运行时动态设置回调引用)，然后在以后某个时刻，Caller 对象可以使用此引用回调 Callee 类。<strong>回调的价值在于它的灵活性，可以在运行时动态的决定需要调用什么方法</strong> (更多关于回调的内容可以参考之前整理的文章: <a href="https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">回调及在Java中的使用</a>)</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最近看了R大关于闭包的一篇博客，又有了一些新的思考，原文地址: <a href="https://rednaxelafx.iteye.com/blog/245022" target="_blank" rel="noopener">关于对象与闭包的关系的一个有趣小故事</a>，总结一些要点:</p><blockquote><p>闭包的要点有两个:<br>1、一个含有自由变量的函数；<br>2、这些自由变量所在的环境。<br><strong>外部环境持有内部函数所使用的自由变量，对内部函数形成“闭包”，就这样。</strong><br>简单但不严格的说，一个函数的“自由变量”就是既不是参数也不是局部变量的变量。基于类的面向对象程序语言中有一种情况，就是方法使用的自由变量来自其所在的类的实例</p></blockquote><blockquote><p>OO 里一般不提闭包<br>面向对象的语言里一般不把类称为闭包，没为什么，就是种习惯。<br><strong>当然严格来说方法(类的成员方法)所捕获的自由变量不是类的字段 x，而是this；x 是通过 this 来访问到的，完整写出应该是 <code>this.x</code></strong></p></blockquote><p>综上，通过对象或者闭包都可以获取函数的自由变量，没有高低之分</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h2&gt;&lt;p&gt;简单来说一句话：&lt;strong&gt;带上下文的函数&lt;/strong&gt;，下面展开说明一下&lt;/p&gt;
&lt;p&gt;声明：接下来的部分内容来自对 StackOverflow 回答的翻译，原答案链接 &lt;a href=&quot;http://stackoverflow.com/questions/36636/what-is-a-closure&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is a ‘Closure’?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要想理解好闭包，首先要弄清楚 &lt;code&gt;Scope&lt;/code&gt;，当我们声明一个局部变量时，这个变量会有一个 Scope，通常局部变量仅在声明它的 block 或 function 中有效，比如下面 JS 代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;// works&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;// fails&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>重新认识信息隐藏</title>
    <link href="https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    <id>https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/</id>
    <published>2019-02-22T12:25:51.000Z</published>
    <updated>2020-04-10T07:28:04.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个重要却容易忽略的问题"><a href="#一个重要却容易忽略的问题" class="headerlink" title="一个重要却容易忽略的问题"></a>一个重要却容易忽略的问题</h2><p>在谈到 OOP 时，大家一般会想到<strong>封装，继承和多态</strong>，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，<strong>信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。</strong>那信息隐藏为什么如此重要？</p><p>引用一段<code>Effective Java</code>中的话：</p><blockquote><p>要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信</p></blockquote><a id="more"></a><p>除了设计好的需要对外公开的 API 外，其他的成员原则上都要隐藏，如果不能很好的实现信息隐藏，意外暴露的成员被客户端操作会导致对象状态的不可控，<strong>这也要求我们在写代码时要保持有意识的状态，每一行代码都是一种“承诺”</strong></p><h2 id="封装与访问控制"><a href="#封装与访问控制" class="headerlink" title="封装与访问控制"></a>封装与访问控制</h2><p>谈信息隐藏，自然避不开封装。广义上的封装仅仅只是打包，把一些数据和行为封闭到一个盒子，这个盒子可能是黑盒子也可能是白盒子。相比 C 语言，Java 的封装引入了一种<strong>新的模块机制: 把相关的数据和作用在其上的运算打包为称为类的模块，从而为域和函数(准确的说应该是成员方法)提供了一个上下文。</strong></p><p>我们通常所说的狭义的封装是指<strong>在打包的基础上加上访问控制，以实现信息隐藏；访问控制不仅仅是语法上的限制，也是语义上的规范</strong>，标有 public 的是接口，标有 private 的是实现；这种语义显然比文档注释更加直观。</p><p>访问控制是对静态代码的控制，并非牢不可破，通过反射机制一样可以访问到 private 成员，这里也引出一个常见的误区，认为信息隐藏是为了安全性，不能说错，但信息隐藏的本意并不在此，<strong>信息隐藏通过屏蔽一个模块中非本质，容易变化的部分，从而保证了内部的修改不会波及客户，它的目的是为了提高稳定性和灵活性</strong>，通过信息隐藏，一个类相当于被划分为阴阳两面，阴面的实现对于客户是透明的</p><h2 id="如何更好的隐藏信息"><a href="#如何更好的隐藏信息" class="headerlink" title="如何更好的隐藏信息"></a>如何更好的隐藏信息</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><p>这个很好理解，举个简单例子，把一个类的 <code>private</code> 成员改为 <code>public</code> 不会产生问题，反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广，具体可以采用如下操作</p><h4 id="顶层类如果可以包级私有，那就包级私有"><a href="#顶层类如果可以包级私有，那就包级私有" class="headerlink" title="顶层类如果可以包级私有，那就包级私有"></a>顶层类如果可以包级私有，那就包级私有</h4><p>我们通过 IDE 生成类时，一般会默认用 public 修饰类，这里值得商榷，一个包中的类大部分都是为本包提供服务的，没有必要作为包的 API 导出，因为一旦导出，你就要负责一直维护他</p><h4 id="在公有类中使用访问方法而非公有域"><a href="#在公有类中使用访问方法而非公有域" class="headerlink" title="在公有类中使用访问方法而非公有域"></a>在公有类中使用访问方法而非公有域</h4><p><strong>公有类永远都不应该暴露可变的域。在特殊情况下，暴露公有的静态的 final域是可以接受的，但是这里的域要么是基本类型，要么是不可变的。</strong>比如一个很常见的错误就是：<code>public Date getBirthday() { return birthday }</code> 这里即使 birthday 使用了 <code>private</code> 的访问修饰符，但仍然没用，因为 Date 类不是不可变的（当然了 Date 类是可变的属于类库设计的缺陷），这里应该提供防御性复制</p><h4 id="private-frist"><a href="#private-frist" class="headerlink" title="private frist"></a>private frist</h4><p>使用 private 不需要理由，不使用才需要理由，这也是为什么如 C# 之类的语言默认的访问修饰符是 private（Java默认是包级私有）</p><h4 id="警惕长度不为0的数组"><a href="#警惕长度不为0的数组" class="headerlink" title="警惕长度不为0的数组"></a>警惕长度不为0的数组</h4><p><strong>长度不为0的数组总是可变的，类具有公有的静态的 final 数组域或者返回这种域的访问方法，几乎总是错误的。</strong>可以通过把数组域私有，并添加一个公有方法，返回私有数组域的一个备份:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="comment">// shallow copy, Thing need to be Immutable</span></span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者很多时候，并不需要一次性返回一整个数组，而是返回数组中的某一个元素，提供这样细粒度的 API 可能会更方便，而且效率更好更安全</p><h4 id="隐藏实现方式"><a href="#隐藏实现方式" class="headerlink" title="隐藏实现方式"></a>隐藏实现方式</h4><p>信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如<code>public int computeAge()</code> 这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏</p><h3 id="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"><a href="#如果内部数据必须要暴露出来，那么要尽量使可变性最小化" class="headerlink" title="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"></a>如果内部数据必须要暴露出来，那么要尽量使可变性最小化</h3><h4 id="能设计为不可变类就不要设计为可变类"><a href="#能设计为不可变类就不要设计为可变类" class="headerlink" title="能设计为不可变类就不要设计为可变类"></a>能设计为不可变类就不要设计为可变类</h4><p>除非有很好的理由使类成为可变的，不然就应该是不可变的类。构造一个不可变的类遵循相应的规则即可(参考<code>Effective Java</code>)。不可变的类只有一种状态，那就是被创建时的状态；而且不可变的类本质上是线程安全的，不需要同步，可以被自由的共享而不用进行保护性拷贝。对于频繁用到的值，可以使用公有静态 final 常量，或者使用静态工厂替换构造器提供缓存功能。但是不可变类也有缺点，那就是每一个值都是一个对象，有时为了性能和内存考量需要提供可变的配套类，如<code>StringBuilder</code></p><h4 id="能用-final-域就不要不用"><a href="#能用-final-域就不要不用" class="headerlink" title="能用 final 域就不要不用"></a>能用 final 域就不要不用</h4><p>如果类不能做成不可变的，那也要尽可能的降低它的可变性，减少对象可存在的状态，可以更容易的分析它的行为，减少出错的几率。<strong>除非有令人信服的理由，不然所有的域都应该是  final的</strong></p><h4 id="数据修改接口慎重提供"><a href="#数据修改接口慎重提供" class="headerlink" title="数据修改接口慎重提供"></a>数据修改接口慎重提供</h4><p>不要追求 get/set 方法对称的教条，set 方法能不提供就不提供</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于信息隐藏的一些重要知识，很基础但也很重要，通过合理的信息隐藏，我们才能构建出稳健的类和包，<strong>使他们提供尽可能少的开口，以更好的面对变化，不至于失控</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;a href=&quot;#一个重要却容易忽略的问题&quot; class=&quot;headerlink&quot; title=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;/a&gt;一个重要却容易忽略的问题&lt;/h2&gt;&lt;p&gt;在谈到 OOP 时，大家一般会想到&lt;strong&gt;封装，继承和多态&lt;/strong&gt;，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，&lt;strong&gt;信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。&lt;/strong&gt;那信息隐藏为什么如此重要？&lt;/p&gt;
&lt;p&gt;引用一段&lt;code&gt;Effective Java&lt;/code&gt;中的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>回调及在Java中的使用</title>
    <link href="https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://ryan-hou.github.io/2019/02/10/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-02-10T15:39:14.000Z</published>
    <updated>2020-04-13T04:16:01.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回调是什么"><a href="#回调是什么" class="headerlink" title="回调是什么"></a>回调是什么</h2><p>维基百科的定义如下:</p><blockquote><p>In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.</p></blockquote><p>可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)</p><a id="more"></a><h2 id="回调的过程"><a href="#回调的过程" class="headerlink" title="回调的过程"></a>回调的过程</h2><p>通过上面的定义我们不难得出，使用回调有这么几个步骤：<code>1)定义回调接口/方法；2)注册回调；3)当事件发生时，调用回调方法</code></p><p>本质上来说就是我们利用某种方式(函数指针，lambda 表达式等)，把回调函数像参数一样传入中间函数(Model code as data)，在适当的时机中间函数会调用传入的回调函数。在传入一个回调函数之前，中间函数是不完整的。也就是说程序可以在运行时，通过注册不同的回调函数，来决定、改变中间函数的行为，比简单的函数调用灵活多了，使代码在空间上解耦，如果使用异步回调的话，相当于在时间上也做了解耦。像 Java 中的模版方法模式，观察者模式，策略模式等都使用了回调</p><h2 id="Java中回调的使用"><a href="#Java中回调的使用" class="headerlink" title="Java中回调的使用"></a>Java中回调的使用</h2><p>在 Java 中，因为函数不能作为参数直接传递，我们一般通过定义接口(或者抽象类也可以)的方式来封装方法以实现回调，并且经常结合匿名类表达式(Anonymous class expression)和匿名方法(lambda 表达式)一起使用</p><p>通常先定义一个回调接口，接口中定义需要被回调的方法，然后把该接口作为参数传入需要调用回调方法的中间函数，最后在需要的时候，通过传入实现了该接口的类实例或者直接使用匿名内部类或 lambda 表达式的方式来作为参数传入中间函数，回调接口中定义的回调方法，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallbackInterface</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 定义回调方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testCallback</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间函数，通过 CallbackInterface 接口封装回调方法，作为中间函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCall</span><span class="params">(<span class="keyword">int</span> a, String param, CallbackInterface callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// concrete opearaions...</span></span><br><span class="line">        <span class="comment">// 调用回调方法</span></span><br><span class="line">        callback.testCallback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Caller caller = <span class="keyword">new</span> Caller();</span><br><span class="line">        CallbackInterface callback = <span class="keyword">new</span> CallbackInterfaceImpl();</span><br><span class="line">        <span class="comment">// 1.实现回调接口的类实例注册到中间函数</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, callback);</span><br><span class="line">        <span class="comment">// 2.直接使用匿名类表达式</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, <span class="keyword">new</span> CallbackInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Test Anonymous class and callback."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 3. 使用 lambda 表达式</span></span><br><span class="line">        caller.testCall(<span class="number">1</span>, <span class="string">"test"</span>, () -&gt; &#123; System.out.println(<span class="string">"Test lambda expression and callback."</span>); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调在设计模式中的应用"><a href="#回调在设计模式中的应用" class="headerlink" title="回调在设计模式中的应用"></a>回调在设计模式中的应用</h2><p>以模版方法模式为例简单说一下，我们都知道模版方法模式的主要思想是<strong>定义出算法的骨架，然后留出扩展点供子类实现</strong>，在抽象父类中，我们通常会设计一些钩子方法，并提供默认实现，并由子类决定是否要进行覆盖，这里的<strong>钩子方法其实就是一种回调方法</strong>，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件（高层组件决定如何使用回调方法）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回调是什么&quot;&gt;&lt;a href=&quot;#回调是什么&quot; class=&quot;headerlink&quot; title=&quot;回调是什么&quot;&gt;&lt;/a&gt;回调是什么&lt;/h2&gt;&lt;p&gt;维基百科的定义如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>反转单链表三种经典的思路</title>
    <link href="https://ryan-hou.github.io/2019/01/20/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>https://ryan-hou.github.io/2019/01/20/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E6%80%9D%E8%B7%AF/</id>
    <published>2019-01-20T13:20:02.000Z</published>
    <updated>2020-04-11T10:17:12.819Z</updated>
    
    <content type="html"><![CDATA[<p>基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路</p><h2 id="头插法构建单链表"><a href="#头插法构建单链表" class="headerlink" title="头插法构建单链表"></a>头插法构建单链表</h2><p>头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 <code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    LinkNode dummy = <span class="keyword">new</span> LinkNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LinkNode cur = <span class="keyword">new</span> LinkNode(head.val);</span><br><span class="line">        cur.next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="指针移动实现反转"><a href="#指针移动实现反转" class="headerlink" title="指针移动实现反转"></a>指针移动实现反转</h2><p>反转一个单链表还有一种很直观的解决方法就是遍历这个单链表，然后依次反转每个需要反转的节点。但是这里存在一个问题，在反转当前节点的时候，当前节点的下一个节点需要先提前保存一下，不然会丢失下一个节点。对于算法的边界，需要考虑链表为空，链表只有一个节点，有两个节点和多于两个节点这几种情况。时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode pre = head;</span><br><span class="line">    LinkNode cur = head.next;</span><br><span class="line">    LinkNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// next 保存指针指向将要反转的节点原本的下一个节点</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// pre, cur 同时后移</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>链表的定义和二叉树类似，也是一个递归的定义，因此使用递归的思路来处理链表也是可行的。反转一个单链表，可以分解为，先反转单链表除了头节点之后的单链表，然后处理反转后的单链表与头节点的关系即可。递归出口是头节点为空或者头节点的下一个节点为空。使用递归这种声明式的实现方式使代码更加简洁，重在描述代码做什么而不是怎么做。空间复杂度为<code>O(n)</code>，时间复杂度为<code>O(n)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkNode <span class="title">reverse</span><span class="params">(LinkNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode headOfLeft = reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> headOfLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路&lt;/p&gt;
&lt;h2 id=&quot;头插法构建单链表&quot;&gt;&lt;a href=&quot;#头插法构建单链表&quot; class=&quot;headerlink&quot; title=&quot;头插法构建单链表&quot;&gt;&lt;/a&gt;头插法构建单链表&lt;/h2&gt;&lt;p&gt;头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 &lt;code&gt;O(n)&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; LinkNode &lt;span class=&quot;title&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LinkNode head)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LinkNode dummy = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (head != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LinkNode cur = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkNode(head.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur.next = dummy.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dummy.next = cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head = head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dummy.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="https://ryan-hou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>创建一个对象的思考</title>
    <link href="https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2019-01-01T05:59:25.000Z</published>
    <updated>2020-04-09T09:01:03.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事情可能没有看起来那么简单"><a href="#事情可能没有看起来那么简单" class="headerlink" title="事情可能没有看起来那么简单"></a>事情可能没有看起来那么简单</h2><p>Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？</p><ul><li>创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？</li><li>数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？</li><li>时间: 是立即构建，还是延迟构建呢？</li><li>形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？</li></ul><a id="more"></a><p>以上这些，在不同的场景下，我们需要做不同的考量，本文仅从构造器的弊端来谈一下静态工厂方法，工厂方法模式，抽象工厂模式和 Builder 模式</p><h2 id="构造器有什么问题"><a href="#构造器有什么问题" class="headerlink" title="构造器有什么问题"></a>构造器有什么问题</h2><p>用构造器来创建对象，是很自然也很简单的，大部分场景下直接通过构造器构建对象就足够了。但构造器也存在一些问题，下面具体谈一下</p><h3 id="构造器缺乏表现力"><a href="#构造器缺乏表现力" class="headerlink" title="构造器缺乏表现力"></a>构造器缺乏表现力</h3><p><strong>构造器的名字必须和类名保持一致，缺乏表现力。</strong>而且在构造器参数除了名字不同外(参数类型，个数和顺序完全相同)，会导致构造器的方法签名重复，比如很经典的一个例子就是用 Point 类代表平面坐标系的点，通过构造器提供直角坐标和极坐标的创建方式，代码会出现：<code>Point(double x, double y) 和 Point(double r, double theta)</code> 不仅表现力不足，而且方法签名冲突，我们可以使用<strong>静态工厂方法</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">cartesian</span><span class="params">(<span class="keyword">double</span> x, doubly y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">polar</span><span class="params">(doule r, <span class="keyword">double</span> theta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(r * Math.cos(theta), r * Math.sin(theta));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码可读性要好很多，而且不存在方法签名冲突的问题</p><h3 id="构造器的每次调用都会创建新对象"><a href="#构造器的每次调用都会创建新对象" class="headerlink" title="构造器的每次调用都会创建新对象"></a>构造器的每次调用都会创建新对象</h3><p>通常情况下每次调用构造器都会创建对象（构造器方法里做了自定义的特殊处理不考虑在内），而这并非总是合适的。不公开构造器而是借助静态方法创建对象，可以控制对象的个数。不管是出于管理的原因，如单例模式，还是出于性能的考虑，如对象池技术，这些都是单纯使用构造器做不到的。</p><p>典型的代表就是 JDK 中 Boolean 类提供的 <code>static valueOf(boolean b)</code> 方法，但是该方法提出的比较晚，Boolean 类还是可以用构造器创建多余的对象，因此 <code>valueOf</code> 方法的文档中说明了在大部分场景下应该用该方法替代构造器（除非就是需要创建一个全新的 Boolean 对象）</p><h3 id="构造器无法被继承，也就无法提供多态"><a href="#构造器无法被继承，也就无法提供多态" class="headerlink" title="构造器无法被继承，也就无法提供多态"></a>构造器无法被继承，也就无法提供多态</h3><p><strong>要使用构造器，就要知道具体的类型，这违背了针对接口编程的原则，同时也违背了依赖倒置原则(依赖尽量通过抽象来完成)，当然了这里不能一概而论，如果是依赖像 String 这样稳定的类，也是无可厚非的，但是在实际编程中，考虑减少对具体类的依赖是好的习惯</strong>，这里就可以引出工厂方法模式了</p><p>我们把创建对象的过程封装到工厂中，这实际上就是<strong>保变原则</strong>的使用，提供了一个<strong>中间层</strong>，我们的客户端代码不需要知道对象如何创建，只需要知道我去工厂里拿就可以了，这样将来创建对象的代码发生变化也不会波及客户端代码。同时<strong>工厂方法一般是一个抽象的方法，由工厂的实现类来决定要实例化的具体类是哪个，而且经常结合模版方法模式一起使用</strong>，下面是一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里经常结合模版方法模式提供一个骨架，把可扩展的部分也就是创建对象的代码交由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        pizza  = createPizza(type);</span><br><span class="line">        </span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法,由子类来具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式-抽象工厂模式与-Builder-模式"><a href="#工厂方法模式-抽象工厂模式与-Builder-模式" class="headerlink" title="工厂方法模式/抽象工厂模式与 Builder 模式"></a>工厂方法模式/抽象工厂模式与 Builder 模式</h2><p>有时候我们要创建的对象需要各种组件来构成，这些组件构成一个系列，这里我们可以使用抽象工厂模式来定义一套接口（工厂方法模式只能生产一种产品，抽象工厂模式可以生产一系列产品）。<strong>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族,而不需要明确指定具体类</strong></p><p>与工厂方法模式相比，两种模式都能将对象的创建封装起来，使应用程序解耦，并降低其对特定实现的依赖；但是，<strong>工厂方法使用继承</strong>: 把对象的创建委托给子类，子类实现工厂方法来创建对象；<strong>抽象工厂使用对象组合</strong>: 对象的创建被实现在工厂接口所暴露出的方法中；抽象工厂提供创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法，要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中，部分示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    Veggies[] createVeggies();</span><br><span class="line">    <span class="function">Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体对象的创建通过组合方式传入的具体工厂类来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory pizzaIngredientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = pizzaIngredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原料工厂生产pizza原料,代码中使用抽象类型的接口,把客户从使用的实际具体产品中解耦</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Preparing "</span> + name);</span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式是把一个对象的创建分成不同的组件，而 Builder 模式则是把创建对象分为一系列步骤，两者经常结合使用；Builder 模式不关心中间的过程，只关心最后得到的对象，符合<strong>最少知识原则</strong>，而且可以结合链式调用构造复杂的对象，Builder 模式的基本思路如下：</p><p>定义一个静态内部类，并且静态内部类的内部属性就是我们要赋值的属性。通过各个方法把我们要赋的值封装到静态内部类对象中，返回 <strong>this</strong>，目的是要使用链式的结构；定义一个方法，创建目标对象，并且传入已经封装了各个参数的静态内部类对象。目标类定义一个参数为静态内部类的构造函数；完成创建目标对象，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexObj</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String s1;</span><br><span class="line">    <span class="keyword">private</span> String s2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="comment">// getter methods and other methods...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComplexObj</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s1 = builder.s1;</span><br><span class="line">        <span class="keyword">this</span>.s2 = builder.s2;</span><br><span class="line">        <span class="keyword">this</span>.n1 = builder.n1;</span><br><span class="line">        <span class="keyword">this</span>.n2 = builder.n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String s1;</span><br><span class="line">        <span class="keyword">private</span> String s2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s1</span><span class="params">(String s1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s1 = s1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s2</span><span class="params">(String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s2 = s2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n1</span><span class="params">(<span class="keyword">int</span> n1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n1 = n1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n2</span><span class="params">(<span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n2 = n2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComplexObj <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComplexObj(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of class Builder</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实际调用时就可以通过链式调用，使代码更清晰</span></span><br><span class="line">ComplexObj test = <span class="keyword">new</span> ComplexObj.Builder()</span><br><span class="line">                    .s1(<span class="string">"test"</span>).s2(<span class="string">"ff"</span>).n2(<span class="number">2</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于使用构造器创建对象可能需要思考的各种问题，以及引出的几种设计模式，这里只是做一个介绍，并不是教条；面对不同的使用场景，需要有不同的考量，要做不同的取舍，程序设计也是设计，<strong>做设计就要懂得取舍</strong>，这需要经验，思考和功夫，共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;a href=&quot;#事情可能没有看起来那么简单&quot; class=&quot;headerlink&quot; title=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;/a&gt;事情可能没有看起来那么简单&lt;/h2&gt;&lt;p&gt;Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？&lt;/li&gt;
&lt;li&gt;数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？&lt;/li&gt;
&lt;li&gt;时间: 是立即构建，还是延迟构建呢？&lt;/li&gt;
&lt;li&gt;形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>模版方法模式VS策略模式</title>
    <link href="https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-12-22T14:58:32.000Z</published>
    <updated>2020-04-09T03:25:54.808Z</updated>
    
    <content type="html"><![CDATA[<p>模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述</p><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote><p>在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤</p></blockquote><a id="more"></a><p>模版方法模式符合<strong>好莱坞原则(Don’t call us, we’ll call u.)</strong>，好莱坞原则给我们提供了一种防止”依赖腐败”的方法(代码中的依赖关系尽量要保持单向且不循环)，在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件。换句话说，<strong>高层组件对待低层组件的方式是”别调用我们,我们会调用你”</strong></p><p>模版方法模式也符合<strong>开闭原则(OCP)</strong>，算法骨架保持稳定，对修改封闭；通过子类对扩展保持开放</p><p>下面是<code>Head First 设计模式</code>中的一段代码，代码中有关于如何在抽象基类中定义算法骨架并定义子类扩展点的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverageWithHook</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模版方法,定义算法骨架和子类扩展点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 提供钩子方法,控制部分算法的执行,由子类决定是否覆盖该钩子方法</span></span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 交由不同子类具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Boiling water"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pouring into cup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个钩子方法,通常是空的缺省实现,由子类决定是否覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版方法模式在实际使用中是很广泛的，比如 Spring 框架中 <code>BeanFactory</code> 就使用了该模式，并把 getBean() 方法交给不同的子类具体实现；JDK 中 <code>ThreadPoolExecutor</code> 类的 runWorker() 方法就定义了 <code>beforeExecute</code> 和 <code>afterExecute</code> 钩子方法。在实际工作中，我个人也比较喜欢用这个模式，当存在两个行为类似但又不完全相同的类时，可以考虑提取公共流程和可复用的代码到父类，保留不同的地方作为 abstract 方法，交由不同的子类去实现</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</p></blockquote><p>策略模式重在定义不同的算法(行为)接口，然后为每个接口提供不同的实现类，在客户端代码中，通过组合的方式使用抽象的接口，甚至可以提供动态改变算法策略的 API，利用多态和依赖注射的方式灵活的组合和替换具体的算法</p><h3 id="涉及到的设计原则"><a href="#涉及到的设计原则" class="headerlink" title="涉及到的设计原则"></a>涉及到的设计原则</h3><p><strong>封装变化</strong>: 找出应用中可能会变化的部分，把它们抽象出来，这样系统中该部分改变不会影响其他部分</p><p><strong>针对接口编程而不是针对实现编程</strong>: 这里针对接口编程的真正意思是<strong>针对超类型(supertype)编程。</strong>针对接口编程的精髓在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上（为程序提供了动态性）</p><p><strong>多用组合，少用继承(实现继承)</strong>: “有一个”可能比”是一个”更好。当将两个类组合起来使用时,就是组合(composition)，使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以在”运行时动态的改变行为”</p><p>具体的示例代码建议去看<code>Head First 设计模式</code>一书，清晰易懂</p><p>策略模式在实际应用中也比较广泛，比如在 Netty 中，<code>EventExecutorChooser</code> 作为事件执行器选择策略接口，存在<code>PowerOfTwoEventExecutorChooser</code> 和 <code>GenericEventExecutorChooser</code> 两个具体实现类，<code>DefaultEventExecutorChooserFactory</code> 的 newChooser 方法作为策略选择者，会根据执行器数量是否能被2整数选择具体的策略实现。我自己在实际工作中也用过多次，比如在重构系统中一个关于车辆出库的方法时，该方法会判断不同的出库类型，根据类型不同，执行不同的出库逻辑，整个代码通过 if-else 组合，足足有近千行，而且不同的出库逻辑会根据需求存在变动，每次变动都要修改这里的 if-else 逻辑，维护和测试很不方便。通过抽象出一个出库策略接口，然后为不同的出库方式提供不同的实现，并提供一个根据出库方式选择具体策略实现类的策略者，该方法被简化为只有几十行代码，当出库需求变动时，只需要修改需求变动的出库方式对应的出库策略实现类即可，其他的代码均保持不变，符合开闭原则</p><h2 id="比较两种模式"><a href="#比较两种模式" class="headerlink" title="比较两种模式"></a>比较两种模式</h2><ul><li>策略模式侧重于定义一个<strong>算法家族</strong>，并且让算法可以互换，强调灵活性</li><li>而模版方法模式侧重于定义出<strong>算法骨架</strong>，子类可以通过钩子方法指定部分行为。方便代码复用和框架定义，强调的是算法骨架的稳定性</li><li>策略模式采用组合的方式实现，更加有弹性; 模版方法模式采用继承的方式实现</li></ul><p>最后再举个例子，在 <code>Head Fist 设计模式</code> 中提到，Java <code>Arrays</code>类的排序方法也提供了一种模版方法模式的变式: 在 <code>mergeSort</code> 模版方法中, 依赖于 <code>comparable</code> 接口的 <code>compareTo</code> 方法来完成算法；我认为这里理解为策略模式也是合理的，<code>comparable</code> 可以理解为一个算法家族的接口，可以有不同的实现方法，当 <code>mergeSort</code> 方法接收到此类型的具体参数，实质上就是采用了某个具体的策略。从不同的角度来看，我认为这两种观点都有道理，所以说这两种模式确实存在相似性。还是一贯的观点，编程是一门实践性很强的学科，很多时候死抠概念是没意思的，况且有的概念本身就没有定论，而有自己的思考和想法非常重要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述&lt;/p&gt;
&lt;h2 id=&quot;模版方法模式&quot;&gt;&lt;a href=&quot;#模版方法模式&quot; class=&quot;headerlink&quot; title=&quot;模版方法模式&quot;&gt;&lt;/a&gt;模版方法模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的各种姿势</title>
    <link href="https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/</id>
    <published>2018-12-01T02:58:05.000Z</published>
    <updated>2020-04-08T12:49:13.491Z</updated>
    
    <content type="html"><![CDATA[<p>在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other operatons...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 防止通过反射创建多个实例</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"instance already existed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他初始化操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>优点：实现简单，线程安全(依赖 JVM 在加载这个类时创建唯一的实例)</li><li>缺点：不能延迟初始化(类加载时即创建实例对象，至于类加载时机，虚拟机规范并没有强制约束)，如果该类实例化需要的资源很多，会影响内存和性能</li></ul><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>在 jdk5 之后，通过单元素的枚举可以实现单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 其他实例方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举构造单例，写法简单，线程安全，可以防御反射攻击，并且是序列化/反序列化安全的；但是不能延迟初始化</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span> ? <span class="keyword">new</span> Singleton() : instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持延迟初始化，在使用时才去创建单例实例。但是不能保证线程安全，当有多个线程同时执行 <code>instance == null</code> 时，可能会创建多个实例</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>使用同步方法</li></ul><p>在上面代码的基础上，把 <code>getInstance()</code> 方法加上 synchronized 关键字，变为同步方法，保证了不会同时有多个线程进入这个方法</p><p>优点：简单且有效，而且 JVM 会不断优化 synchronized 关键字的实现方式，如果应用程序可以接受同步的开销，推荐使用</p><p>缺点当然是同步方法带来的开销问题，而且在这里实际上只有第一次执行时才真正需要同步，一旦设置好 instance 变量后，就不再需要同步这个方法了，所以我们有必要寻找更优的线程安全实现</p><ul><li>double-checked locking</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查实例，如果不存在才进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//  再次检查是否存在实例，不存在时才创建实例，避免创建多个实例</span></span><br><span class="line">                    <span class="comment">// volatile 关键字保证了实例化对象的指令不被重排序，避免返回未正确初始化的对象实例</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uniqueInstace;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：通过同步代码块，缩小了同步范围（实例一旦创建便不再需要同步），通过 double-checked 避免了多线程创建多个实例</p><p>缺点：在 jdk5 之前，这种实现方式是错误的，当时的 JVM 对于 volatile 的实现不能保证返回的是正确初始化的对象(jdk5 及之后的版本，volatile 增强了语义，避免了指令重排带来的问题)</p><ul><li>On demand holder idiom</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This code is guaranteed to be correct because of the initialization guarantees</span></span><br><span class="line"><span class="comment">     * for static fields; if a field is set in a static initializer, it it guaranteed</span></span><br><span class="line"><span class="comment">     * to be made visible, correctly, to any thread that accesses that class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过静态字段实例化保证了在实例变量被任何线程访问时返回正确初始化的变量，且静态字段只被初始化一次，满足了线程安全和实例唯一性；又因为静态内部类的加载不需要依附外部类，在使用时才加载，满足了延迟初始化</p><p>总结一下，上述各种单例模式的实现方式说明了<strong>在不同场景和需求下会有不同的设计方案，即使是相同场景下也可能会有不同的设计，而每种设计也存在不同的侧重和取舍</strong>。如果延迟初始化不是我们要考量的问题，推荐使用枚举方式实现单例，否则推荐最后一种实现方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下&lt;/p&gt;
&lt;h2 id=&quot;懒汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式&quot;&gt;&lt;/a&gt;懒汉模式&lt;/h2&gt;&lt;p&gt;因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Other operatons...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 防止通过反射创建多个实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;instance already existed!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://ryan-hou.github.io/2018/11/26/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ryan-hou.github.io/2018/11/26/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-11-26T13:01:39.000Z</published>
    <updated>2020-04-13T10:30:28.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间</p></blockquote><p>举个简单例子，插头与插座，通过电源适配器，可以把插头与本来不相匹配的插座进行适配，这样做的好处显然易见，<strong>既不用重新更换插头，也不用更换插座，只需要使用一个适配器就可以使插头与插座适配工作</strong>，而这也就是适配器模式的设计初衷，通过引入一个中间层，屏蔽底层变动对于上层的影响</p><a id="more"></a><h2 id="为什么需要适配器"><a href="#为什么需要适配器" class="headerlink" title="为什么需要适配器"></a>为什么需要适配器</h2><p>考虑这样的场景，在已有的系统中，希望可以使用不同厂商提供的接口，但是很不幸，这些厂商提供的接口并不完全一致，应该如何处理？</p><p>当然最笨的办法就是，每增加一个厂商，就根据该厂商提供的接口来修改我们的客户端代码，缺点显然易见，客户端代码是面向具体的实现的，耦合性强，违背开闭原则。<strong>通过适配器模式，创建适配器来进行接口转换，让不兼容的接口变的兼容，这样可以让客户端代码从实现中解耦</strong></p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>实际上有两种适配器，类适配器与对象适配器，其中类适配器需要使用多继承实现，在 Java 中没有提供多继承，所以下面主要讲述对象适配器的实现</p><p>对象适配器<strong>使用对象组合</strong>。现在的场景是，厂商提供了接口 A，而我们的客户端代码需要使用接口 B，那么适配器需要做的工作就是把接口 A 转为接口 B，整个实现过程有几个点需要关注：</p><ul><li>适配器要实现接口 B (接口B的所有方法，如果实现不了可以抛出异常)</li><li>把 A 接口的实例对象传入适配器(比如通过构造器的方式)，实现对象的组合</li><li>在适配器中实现 B 接口的方法，实际上是调用 A 接口相应的方法</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>最初 JDK 中提供了枚举器来遍历集合中的元素，如 <code>Vector</code> <code>Hashtable</code> 等都有返回实现 <code>Enumeration</code> 接口的方法，该接口中有 <code>hasMoreElements()</code> 和 <code>nextElement()</code> 方法，而在后期的集合类中使用 <code>Iterator</code> 接口来实现遍历</p><p>面对返回 Enumeration 的遗留代码，我们可以构造一个适配器来完成从 Enumeration 到 Iterator 的转换，从而在客户端代码中统一使用 Iterator 接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationAdapter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Enumeration&lt;E&gt; enumeration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumerationAdapter</span><span class="params">(Enumeration&lt;E&gt; enumeration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enumeration = enumeration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个例子，在 Java 集合类中，Set 接口实现类的内部一般都是直接调用 Map 接口实现类的方法（忽略 Map 接口实现类中的 value 域）。我们可以看到 HashSet 的源码实际上都是在调用 HashMap 的方法，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet 内部通过定义私有成员域 HashMap 来进行适配，把对于 HashSet 的方法调用适配为对 HashMap 方法的调用 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing HashMap instance has default initial</span></span><br><span class="line"><span class="comment"> * capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other operations...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个简单例子，插头与插座，通过电源适配器，可以把插头与本来不相匹配的插座进行适配，这样做的好处显然易见，&lt;strong&gt;既不用重新更换插头，也不用更换插座，只需要使用一个适配器就可以使插头与插座适配工作&lt;/strong&gt;，而这也就是适配器模式的设计初衷，通过引入一个中间层，屏蔽底层变动对于上层的影响&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式及fail-fast策略</title>
    <link href="https://ryan-hou.github.io/2018/11/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8Afail-fast%E7%AD%96%E7%95%A5/"/>
    <id>https://ryan-hou.github.io/2018/11/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8Afail-fast%E7%AD%96%E7%95%A5/</id>
    <published>2018-11-11T12:49:35.000Z</published>
    <updated>2020-04-14T14:06:57.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>迭代器模式提供了一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部数据结构的方式。把遍历的任务放在迭代器上而不是聚合上</p><h2 id="为什么需要迭代器"><a href="#为什么需要迭代器" class="headerlink" title="为什么需要迭代器"></a>为什么需要迭代器</h2><p>思考这样一个问题，客户端中有一个类，需要访问不同的聚合对象，遍历各个聚合对象的所有元素，来进行相应的操作，应该怎么做？</p><p>最简单直接的方式当然是由各个聚合对象来提供遍历的接口，在客户端的类中调用这个接口来实现遍历，这样当然可以，但我们可以思考一下这样做的弊端：</p><a id="more"></a><ul><li>由各个聚合类分别提供迭代接口可能会暴露聚合类内部的数据结构</li><li>客户端的代码需要分别遍历不同的聚合对象(通过多个循环操作实现)，存在代码冗余</li><li>客户端代码是面向具体的实现编程，而不是针对接口，灵活性差</li></ul><p>如何做？这就需要用到迭代器模式来提供统一的抽象，迭代器模式有几个要点：</p><ul><li>在面向对象对象编程中，有一个很重要的思想就是<strong>封装变化</strong>，上面例子中，发生变化的部分很明显是<strong>由不同集合类型的遍历造成的</strong>，所以我们通过迭代器模式对这个遍历操作进行封装</li><li>封装的操作其实很简单，<strong>就是定义一个迭代器接口，然后由不同的聚合类根据自己的数据结构来自定义实现遍历操作，而客户端代码只需要调用一致的迭代器接口即可，也面向接口编程</strong></li><li>把遍历相关的操作单独拿出去，作为一个接口定义，然后由具体的类来实现，符合<strong>单一责任原则</strong>，有利于创建高内聚的类或模块</li></ul><h2 id="JDK-中的实现"><a href="#JDK-中的实现" class="headerlink" title="JDK 中的实现"></a>JDK 中的实现</h2><p>根据上面的思路，我们以 ArrayList 为例来看一下 JDK 中的实现</p><p>在 java.util 包中，定义了 <code>Iterator&lt;E&gt;</code> 接口，接口中定义了遍历相关的操作，主要是: <code>boolean hasNext(); E next(); void remove();</code></p><p>在 ArrayList 类的内部，提供一个私有内部类 <code>Itr</code> 来实现了上面的迭代器接口，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor; <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面迭代器的实现，实现了 <code>fail-fast</code> 的机制，以保证在多线程并发访问时尽最大可能抛出 <code>ConcurrentModificationException</code> 异常，下面会具体谈到</p><h2 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for-each 循环"></a>for-each 循环</h2><p>借助 Iterable 接口和迭代器 Iterator，可以使用 for-each 语法糖。JDK 1.5 提供的 for-each 循环，通过隐藏迭代器或者索引变量(编译器语法糖)，避免了混乱和出错的可能性，for-each 循环不仅可以让你遍历数组和集合，还可以让你遍历任何实现了 Iterable 接口的对象。在遍历元素时，<strong>for-each循环优于传统的循环</strong> （但是需要注意参与遍历的聚合对象不能为 null，否则会 NPE）</p><h2 id="关于迭代器的-fail-fast"><a href="#关于迭代器的-fail-fast" class="headerlink" title="关于迭代器的 fail-fast"></a>关于迭代器的 fail-fast</h2><p>在迭代器创建之后，如果从<strong>结构</strong>上对其进行修改(比如删除或者增加新的元素)，除非通过<strong>迭代器本身</strong>的 <code>remove</code> 方法，其他任何方式的修改，迭代器都将尽可能抛出 <code>ConcurrentModificationException</code>。这一现象，我们称作<code>fail-fast</code></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 该操作会产生 ConcurrentModfication 异常，应该使用迭代器 iterator 自身的 remove 方法来进行操作</span></span><br><span class="line">        list.remove(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现方式可以参见 JDK 源码，主要是通过 <code>modCout</code> 和 <code>expectedModCount</code> 变量值的比对来实现</p><h2 id="为什么要-fail-fast"><a href="#为什么要-fail-fast" class="headerlink" title="为什么要 fail-fast"></a>为什么要 fail-fast</h2><p>从抛出异常 <code>ConcurrentModificationException</code> 的名字我们也可以猜到，这是为了防止多线程并发操作带来的问题而设计的，<code>modCount</code> 变量是可变共享的，我们用迭代器来迭代数据，应该保证迭代器遍历的聚合对象处于单线程操作，否则在我们迭代数据时，其他线程对于该集合结构的修改会导致当前线程出现不可预知的异常，比如<code>ArrayIndexOutOfBoundsException</code> </p><p>需要注意迭代器的 fail-fast 行为不能得到保证，也就是说迭代器只会尽最大努力抛出 ConcurrentModificationException。因此，在 JDK 源码注释中也写到，编写依赖于此异常的程序是错误的，正确做法是迭代器的 fail-fast 行为应该仅用于检测程序可能出现的错误</p><p><strong>最后，fail-fast 并不仅仅用于迭代器，它本身也是一个非常重要的设计原则，尤其是在处理在线业务时，比如当业务量突然增大，导致大量任务堆积或者阻塞时，如果没有 fail-fast，那么可能会导致整个在线系统崩溃。因此在设计系统或者接口时，fail-fast 也是一个需要重要考虑的点</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;p&gt;迭代器模式提供了一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部数据结构的方式。把遍历的任务放在迭代器上而不是聚合上&lt;/p&gt;
&lt;h2 id=&quot;为什么需要迭代器&quot;&gt;&lt;a href=&quot;#为什么需要迭代器&quot; class=&quot;headerlink&quot; title=&quot;为什么需要迭代器&quot;&gt;&lt;/a&gt;为什么需要迭代器&lt;/h2&gt;&lt;p&gt;思考这样一个问题，客户端中有一个类，需要访问不同的聚合对象，遍历各个聚合对象的所有元素，来进行相应的操作，应该怎么做？&lt;/p&gt;
&lt;p&gt;最简单直接的方式当然是由各个聚合对象来提供遍历的接口，在客户端的类中调用这个接口来实现遍历，这样当然可以，但我们可以思考一下这样做的弊端：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>动态代理实现AOP</title>
    <link href="https://ryan-hou.github.io/2018/10/30/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP/"/>
    <id>https://ryan-hou.github.io/2018/10/30/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP/</id>
    <published>2018-10-30T14:21:35.000Z</published>
    <updated>2020-04-21T03:40:04.294Z</updated>
    
    <content type="html"><![CDATA[<p>AOP(Aspect Oriented Programming)也就是我们说的面向切面编程，可以看作面向对象编程的一种补充。AOP 应用很广，比如 Spring 框架中的 @Transactional 声明式事务就是借助 AOP 实现的。</p><h3 id="为什么要使用AOP？"><a href="#为什么要使用AOP？" class="headerlink" title="为什么要使用AOP？"></a>为什么要使用AOP？</h3><p>试想这样一个场景，假如需要在所有已经实现的业务方法中添加打印日志的功能，该怎么实现？把打印日志的代码复制粘贴到每一个业务方法中？这样当然可以，但是弊端很明显：</p><a id="more"></a><ul><li><strong>代码混乱，代码量急剧膨胀：</strong>在业务模块中我们需要兼顾核心逻辑功能和系统范围内的需求，比如日志、验证、事务等，代码可读性差</li><li><strong>代码分散：</strong> 一旦需要修改，工作量可想而知</li></ul><p>基于此场景，为了解决<strong>非模块化的横切关注点</strong>所带来的问题，我们引入 AOP 的思想。而为了实现 AOP，我们需要明白动态代理的过程</p><h3 id="JDK-提供的动态代理"><a href="#JDK-提供的动态代理" class="headerlink" title="JDK 提供的动态代理"></a>JDK 提供的动态代理</h3><p>代理设计模式的原理：概括的说，就是使用一个代理将对象包装起来，然后用该代理取代原始对象，任何对原始对象的调用都要通过代理，代理对象决定是否以及何时将方法调用转到原始对象上。其实在我们日常生活中也有类似的应用，比如房屋中介，明星经纪人等都可以看作是代理</p><p>接下来，通过具体代码来了解一下调用过程，为了简洁，只写核心代码，先介绍一下背景：已知一个 <code>ArithmeticCalculator</code> 接口，接口中定义了加减乘除方法；还有一个实现该接口的<code>ArithmeticCalculatorImpl类</code>。现在给出需求，在加减乘除的运算开始和结束都要打印一下相关信息，比如方法名，参与运算的参数和结果</p><p>JDK 实现动态代理需要我们了解<strong>Proxy类</strong>和<strong>反射</strong>的相关知识。下面我们一步步来实现整个过程：</p><h4 id="明确被代理对象"><a href="#明确被代理对象" class="headerlink" title="明确被代理对象"></a>明确被代理对象</h4><p>既然是动态代理，我们首先就要有一个被代理的对象，很简单，被代理的对象自然是实现 <code>ArithmeticCalculator</code> 接口的类的对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建被代理对象</span></span><br><span class="line">ArithmeticCalculator target = <span class="keyword">new</span> ArithmeticCalculatorImpl();</span><br></pre></td></tr></table></figure><h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>这一步是关键，里面内容有点多，这里我们先给出 <code>Proxy</code> 类的<code>newProxyInstance</code> 方法再具体讲解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Proxy provides static methods for creating dynamic proxy classes and instances, </span></span><br><span class="line"><span class="comment"> * and it is also the superclass of all dynamic proxy classes created by those methods.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader</span></span></span><br><span class="line"><span class="function"><span class="params">    , Class&lt;?&gt;[] interfaces</span></span></span><br><span class="line"><span class="function"><span class="params">    , InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下这个方法中的三个参数：</p><ul><li><strong>ClassLoader:</strong>动态代理产生的对象由哪个类加载器加载。通常情况下，和被代理对象使用一样的类加载器(很好理解，明星和经纪人一般都是一个公司)</li><li><strong>Class&lt;?&gt;[]:</strong>动态代理产生的对象必须要实现的接口的<strong>Class数组</strong>。这里要强调一下，Proxy 实现的动态代理是基于接口的</li><li><strong>InvocationHandler:</strong>当调用代理对象的方法时，将产生什么行为，后面再具体解释，写到这里，我们可以给出这一步的代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object proxy = Proxy.newInstance(target.getClass().getClassLoader()</span><br><span class="line">, <span class="keyword">new</span> Class[] &#123; ArithmeticCalculator<span class="class">.<span class="keyword">class</span> &#125;</span></span><br><span class="line"><span class="class">, <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="实现-InvocationHandler"><a href="#实现-InvocationHandler" class="headerlink" title="实现 InvocationHandler"></a>实现 InvocationHandler</h4><p>关于 InvocationHandler 接口的部分文档如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InvocationHandler is the interface implemented by the invocation handler of a proxy instance.</span></span><br><span class="line"><span class="comment"> * Each proxy instance has an associated invocaiton handler.</span></span><br><span class="line"><span class="comment"> * When a method is invoked on a proxy instance, the method invocation</span></span><br><span class="line"><span class="comment"> * is encoded and dispatched to invoke method of</span></span><br><span class="line"><span class="comment"> * its invocation handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke 方法中的参数含义为：</p><ul><li><strong>proxy:</strong> 正在被返回的那个代理对像，一般不使用</li><li><strong>method:</strong> 正在被调用的方法</li><li><strong>args:</strong> 调用方法时传入的参数</li></ul><p>通过实现该接口，我们就能把需要扩展的业务逻辑和被代理对象原有的业务逻辑分离，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandler 接口的匿名实现类</span></span><br><span class="line"><span class="keyword">new</span> InvocaionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 方法执行前打印日志</span></span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + method.getName() + <span class="string">" called with "</span> + Arrays.toString(args));</span><br><span class="line">        <span class="comment">// 调用被代理对象的方法</span></span><br><span class="line">        Object res = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 方法执行结果打印</span></span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + method.getName() + <span class="string">" called with result "</span> + res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用代理对象"><a href="#使用代理对象" class="headerlink" title="使用代理对象"></a>使用代理对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArithmeticCalculatorImpl 中实现的 mul 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = i * j;</span><br><span class="line">    System.out.println(<span class="string">"res = "</span> + res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">ArithmeticCalculator proxy = (ArithmeticCalculator) Proxy.newInstance(...);</span><br><span class="line">proxy.mul(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>至此，动态代理的主要知识点和代码已经完成，通过下面的代码调用过程图我们就可以知道动态代理的流程:</p><p><img src="http://Ryan-hou.github.io/assets/img/blogPic/AOPImpl.png" alt></p><p>上图比较清晰地描述了各个参数传递的过程，建议结合代码和实际操作加以熟悉，不清楚的地方就 debug 一下代码，查看一下程序的执行过程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AOP(Aspect Oriented Programming)也就是我们说的面向切面编程，可以看作面向对象编程的一种补充。AOP 应用很广，比如 Spring 框架中的 @Transactional 声明式事务就是借助 AOP 实现的。&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用AOP？&quot;&gt;&lt;a href=&quot;#为什么要使用AOP？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用AOP？&quot;&gt;&lt;/a&gt;为什么要使用AOP？&lt;/h3&gt;&lt;p&gt;试想这样一个场景，假如需要在所有已经实现的业务方法中添加打印日志的功能，该怎么实现？把打印日志的代码复制粘贴到每一个业务方法中？这样当然可以，但是弊端很明显：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Checked&amp;Unchecked Exception</title>
    <link href="https://ryan-hou.github.io/2018/10/07/Checked-Unchecked-Exception/"/>
    <id>https://ryan-hou.github.io/2018/10/07/Checked-Unchecked-Exception/</id>
    <published>2018-10-07T12:12:50.000Z</published>
    <updated>2020-04-16T03:48:59.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Is-checked-exception-necessary"><a href="#Is-checked-exception-necessary" class="headerlink" title="Is checked exception necessary?"></a>Is checked exception necessary?</h2><p>很多言论认为 Java 受检异常(checked exception，也就是那些你需要明确的捕获或者 rethrow 的异常)的存在是没有必要的，例如在 C# 语言中就取消了受检异常，而且大部分的语言都没有受检异常这一概念，无论何时直接声明异常为 RuntimeException 或其子类(即 unchecked exception)会更加方便，事实是如此吗？</p><a id="more"></a><h2 id="Oracle-的官方声明"><a href="#Oracle-的官方声明" class="headerlink" title="Oracle 的官方声明"></a>Oracle 的官方声明</h2><p>关于这个争议，Oracle 在官方文档中作出过解释，下面是一些重要观点的翻译：</p><p>因为 Java 语言不强制要求方法捕获或处理非受检异常(RuntionException, Error 及其子类)，所以程序员会倾向于让自己的异常类继承 RuntimeException，从而只抛出非受检的异常。这种“捷径”使程序员的代码不受编译器编译错误的影响，也不用费心去捕获或处理任何异常。这种方式看似非常便捷，但是破坏了 <code>catch</code> 和 <code>specity</code> 的设计目的，对其他程序员操作自己的方法也埋下了隐患</p><p>为什么设计者会要求去处理方法中抛出的所有受检异常呢？因为任何可以被方法抛出的异常都是该方法的公共编程接口。<strong>其他调用该方法的用户必须知道当前方法可能抛出的异常，以便于作出合理的处理。这些异常和方法中的参数列表及返回值一样，都是方法接口的一部分。</strong>那么接下来一个问题就是，“如果把方法 API 文档化(包括该方法的异常)有这么多好处，那为什么不对 runtime exception 也做这种特殊的处理呢？” 那是因为<strong>运行时异常是程序代码错误导致的，因此调用 API 的用户不应该也不知道如何恢复或处理这类异常</strong>。导致运行时异常的问题有算术异常，比如除数为0；空指针异常；数组下标越界异常等等，这类异常可以发生在程序代码中的任何地方，因而数量也是很多的，如果把这类异常加到方法声明中，会降级程序的可读性。因此编译器不会强制要求捕获或处理非受检异常(当然你可以处理，但是大多数情况下没有必要)</p><p>总的来说，不能仅仅因为你不想处理方法抛出的异常就粗暴的使用 RuntimeException 或他的子类</p><h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><p>如果方法的调用者可以合理的处理或者恢复这个异常，那么该异常应该被声明为受检的异常；如果方法的调用者不需要关心或者无法做出合理的处理，那么就声明该异常为非受检的异常。Never swallow the Exception！</p><h2 id="实践中的问题"><a href="#实践中的问题" class="headerlink" title="实践中的问题"></a>实践中的问题</h2><p>在实际编程中，尤其是一些框架(比如 iBatis )和类库，通常会把抛出 RuntimeException 作为习惯用法，这是出于对向后兼容性和设计库函数的难度(在设计一个公用组件时，很难把所有可能出现的异常都考虑清楚)的折衷，但是我们在写一些特定的业务代码时，个人还是建议，根据这个异常是否需要被处理或者能不能被用户处理，把异常声明为受检异常或者非受检异常，而不是直接无脑的抛出 RuntimeException。<strong>正确的使用异常对于程序的正确性和健壮性至关重要，无论何时都要仔细思考程序的边界和可能出现的所有情况，尤其是在分布式环境下，异常的处理往往比正常情况的处理逻辑更加复杂，也更加考验一个程序员思考问题的严谨性。</strong></p><p>关于受检异常和非受检异常，要在合适的情况下进行判断和选用，不能偏废，关于这方面的讨论，推荐两篇阅读文章:</p><ul><li><a href="http://www.yinwang.org/blog-cn/2017/05/23/kotlin" target="_blank" rel="noopener">Kotlin 和 Checked Exception</a></li><li><a href="https://zhuanlan.zhihu.com/p/33731510" target="_blank" rel="noopener">有人知道Java异常声明的正确用法吗？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Is-checked-exception-necessary&quot;&gt;&lt;a href=&quot;#Is-checked-exception-necessary&quot; class=&quot;headerlink&quot; title=&quot;Is checked exception necessary?&quot;&gt;&lt;/a&gt;Is checked exception necessary?&lt;/h2&gt;&lt;p&gt;很多言论认为 Java 受检异常(checked exception，也就是那些你需要明确的捕获或者 rethrow 的异常)的存在是没有必要的，例如在 C# 语言中就取消了受检异常，而且大部分的语言都没有受检异常这一概念，无论何时直接声明异常为 RuntimeException 或其子类(即 unchecked exception)会更加方便，事实是如此吗？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型与通配符</title>
    <link href="https://ryan-hou.github.io/2018/10/04/Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>https://ryan-hou.github.io/2018/10/04/Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/</id>
    <published>2018-10-04T13:34:50.000Z</published>
    <updated>2020-04-14T07:56:32.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从一个问题说起"><a href="#从一个问题说起" class="headerlink" title="从一个问题说起"></a>从一个问题说起</h2><p>String 类是 Object 类的 subtype，但是 <code>List&lt;String&gt;</code> 却不是  <code>List&lt;Object&gt;</code>的 subtype，为什么？</p><p>最核心的原因在于<strong>不满足里氏替换原则(LSP)</strong>，这就引出了里氏替换原则的定义，简单来说，A 是 B 的子类型当且仅当一个有效的使用了 B 类型的程序，把其中所有的 B 类型换成 A 类型，程序的有效性依然存在，那么类型 A 就是类型 B 的子类型 (<strong>里式替换原则要求所有使用 supertype 的地方都可以透明的使用其 subtype</strong>)</p><a id="more"></a><p>根据里氏替换原则，下面这个有效(可以正确编译)的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doThing</span><span class="params">(List&lt;Object&gt; x)</span> </span>&#123;</span><br><span class="line">    x.add(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>List&lt;Object&gt;</code> 可以正确的被替换为 <code>List&lt;String&gt;</code>,那么 <code>List&lt;String&gt;</code> 就是 <code>List&lt;Object&gt;</code> 的子类型，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doThing</span><span class="params">(List&lt;String&gt; y)</span> </span>&#123;</span><br><span class="line">    y.add(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然上面的代码不能编译通过，也就是说 <code>List&lt;String&gt;</code> 不是 <code>List&lt;Object&gt;</code> 的子类型，那么问题来了，各种参数化类型集合的超类是谁呢？答案是 <code>Collection&lt;?&gt;</code> 念做 <strong>collection of unknow</strong> 其中 <code>?</code> 是一个泛型通配符，可以匹配任何类型，下面展开介绍</p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p><strong>注：任何关于Java语言的概念，最权威的参考一定是 JLS，这里给出链接 <a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html" target="_blank" rel="noopener">Wildcards</a>，下面的内容会参考 JLS 来做说明。</strong></p><p>由上面我们知道了，各种参数化类型集合的超类是 <code>Collection&lt;?&gt;</code>，<strong>?</strong> 就是我们说的通配符，有了这个超类，我们就可以构造一个方法来接收任何参数实例化的 Collection 了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中我们读取集合中的每一个元素时都转为 Object，这样做总是安全的，因为 Object 是任何一个元素类型的超类。但是像下面这样就是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">c.add(<span class="string">"test"</span>); <span class="comment">// Compiler error</span></span><br></pre></td></tr></table></figure><p>因为当类型参数是 <strong>?</strong> 时，代表这是一个未知的类型，所以我们不能向其传入任何类型的参数，只有一个例外，那就是 <code>null</code> (所用引用类型变量的默认值)，后面在说 <strong>&lt;? extends T&gt; vs &lt;? super T&gt;</strong> 时会再谈到</p><h2 id="受限的类型参数"><a href="#受限的类型参数" class="headerlink" title="受限的类型参数"></a>受限的类型参数</h2><p>在实际使用中，我们可能需要限制泛型的类型参数，比如，一个方法接收数字类型的参数，那么就可以把泛型的类型参数限定为 Number 类型或者他的子类型，使用的语法是：<strong>列出该参数的名字，然后跟上 extends 关键字，再跟上 upper bound</strong>，比如： <code>List&lt;T extends Number&gt;</code></p><p><strong>注意，在上面的上下文语境中，extends 既代表类中的 extends，也代表接口中的 implements</strong></p><p>一个类型参数可以同时存在有多个上界，比如：<code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code>, 该类型参数就是 B1，B2 和 B3 的子类型，B1，B2，B3 中只能存在一个 class，且该 class 必须放在第一个位置上</p><p>这里 <code>&amp;</code> 还可以用于返回值中，也只能存在一个 class，比如：<br><code>return (Comparator&lt;T&gt; &amp; Serializable) a</code> 表示 a 被转型为 Comparator <strong>and</strong> Serializable (也就是一个可序列化的比较器)</p><h2 id="lt-T-extends-Comparable-lt-super-T-gt-gt-怎么理解"><a href="#lt-T-extends-Comparable-lt-super-T-gt-gt-怎么理解" class="headerlink" title="&lt;T extends Comparable&lt;? super T&gt;&gt;怎么理解"></a><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code>怎么理解</h2><p>在 <code>Collections.sort</code> 的 javadoc 中我们可以看到这样的签名：<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>，我们可能会有这样的疑问，为什么不写成<code>&lt;T implements Comparable&lt;T&gt;&gt;</code>?</p><p>首先在上面受限的泛型参数中说到 extends 既可以表示 extends 也可以表示 implements；其次，javadoc 中的方法签名表示 T 能够实现 <code>Comparable&lt;? super T&gt;</code> 而不仅仅是 <code>Comparable&lt;T&gt;</code>。举个例子，一个 Student 类可以实现 <code>Comparable&lt;Person&gt;</code>，其中 Student 是 Person 的子类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Other operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person that)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，一个 <code>List&lt;Student&gt;</code> 可以被 Collections.sort() 方法进行排序，但是<strong>只能根据 Person 类的属性</strong>，因为把 Student 实例传入 compareTo 方法中是按照超类型 Person 来处理的(除非你自己 downcast)</p><p>在实际使用中，我们不会用 Student 类来实现 <code>Comparable&lt;Person&gt;</code>，因为 Person 类很可能已经实现了 <code>Comparable&lt;Person&gt;</code> 接口，Student 类会继承该实现，但结果是一样的，你可以把 <code>List&lt;Student&gt;</code> 传给 Collections.sort() 调用，但还是根据 Person 的属性来排序</p><h2 id="lt-extends-T-gt-VS-lt-super-T-gt"><a href="#lt-extends-T-gt-VS-lt-super-T-gt" class="headerlink" title="&lt;? extends T&gt; VS &lt;? super T&gt;"></a>&lt;? extends T&gt; VS &lt;? super T&gt;</h2><p>解释这种用法的最佳例子就是 <code>Collections.copy()</code> 方法:<br><code>public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></p><p>注意到在这个方法签名中，src list 声明为 extends，允许我传入相关的 List 类型的 family，保证会产生类型 T 或者他的子类型，但是不能向 src list 中添加新的元素，因为我们无法确定元素的类型</p><p>dest list 声明为 super, 允许我们传入相关的 List 类型的  family(类型 T 或者其超类)，保证我可以写入一个 T 类型元素到该 list 中。但是不能保证从该 list 中读出的元素是 T 类型的元素</p><p>使用上面的泛型通配符，我们可以用一个方法签名，满足下面不同方法的调用，大大增强了算法的普适性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy(dest, src)</span></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Number&gt;(), <span class="keyword">new</span> ArrayList&lt;Number&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Number&gt;(), <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Object&gt;(), <span class="keyword">new</span> ArrayList&lt;Number&gt;());</span><br><span class="line"></span><br><span class="line">Collections.copy(<span class="keyword">new</span> ArrayList&lt;Object&gt;(), <span class="keyword">new</span> ArrayList&lt;Double&gt;());</span><br></pre></td></tr></table></figure><p>总结来说就是：<strong>PECS（Producer Extends, Consumer Super）</strong>。其中 Producer 和 Consumer 都是相对集合对象自身来说的</p><ul><li>Producer Extends: 如果你需要一个 List 来产生 T 类型的值(也就是说你想从 List 中读取 T 类型的值)，你需要使用 <code>? extends T</code>，即<code>List&lt;? extends T&gt;</code>。但是你不能往该 list 中添加元素</li><li>Consumer Super: 如果你需要一个 List 来消费 T 类型的值(也就是说你想把 T 类型的值写入到 list 中)，你需要使用 <code>？ super T</code>，即 <code>List&lt;? super T&gt;</code>。但是不能保证你从 list 中读取的值的类型是 T</li><li>如果你需要同时从 list 中进行读和写，那么就不要使用通配符，即 <code>List&lt;T&gt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从一个问题说起&quot;&gt;&lt;a href=&quot;#从一个问题说起&quot; class=&quot;headerlink&quot; title=&quot;从一个问题说起&quot;&gt;&lt;/a&gt;从一个问题说起&lt;/h2&gt;&lt;p&gt;String 类是 Object 类的 subtype，但是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 却不是  &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;的 subtype，为什么？&lt;/p&gt;
&lt;p&gt;最核心的原因在于&lt;strong&gt;不满足里氏替换原则(LSP)&lt;/strong&gt;，这就引出了里氏替换原则的定义，简单来说，A 是 B 的子类型当且仅当一个有效的使用了 B 类型的程序，把其中所有的 B 类型换成 A 类型，程序的有效性依然存在，那么类型 A 就是类型 B 的子类型 (&lt;strong&gt;里式替换原则要求所有使用 supertype 的地方都可以透明的使用其 subtype&lt;/strong&gt;)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简谈Java泛型</title>
    <link href="https://ryan-hou.github.io/2018/10/01/%E7%AE%80%E8%B0%88Java%E6%B3%9B%E5%9E%8B/"/>
    <id>https://ryan-hou.github.io/2018/10/01/%E7%AE%80%E8%B0%88Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2018-10-01T13:09:25.000Z</published>
    <updated>2020-04-14T06:28:35.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关术语和入门使用"><a href="#相关术语和入门使用" class="headerlink" title="相关术语和入门使用"></a>相关术语和入门使用</h2><p><strong>关于泛型的几个术语</strong></p><ul><li>ArrayList<e> 中的 <code>&lt;&gt;</code> 念作 <code>typeof</code>，E 称为类型参数变量</e></li><li><code>ArrayList&lt;Integer&gt;</code> 中的 Integer 称为实际类型参数</li><li>整个 <code>ArrayList&lt;E&gt;</code> 称为泛型类型；整个 <code>ArrayList&lt;Integer&gt;</code> 称为参数化的类型</li></ul><p>关于泛型几个需要注意的点: (由于 Java 的泛型采用类型擦除来现实，存在相关问题，后面会继续讨论)</p><a id="more"></a><ul><li>泛型的类型参数必须是引用数据类型</li><li>泛型类型实例化时，两边的实际类型参数必须完全一致，或者一边带实际类型参数，一边不带(&lt;&gt;: the diamond)</li><li>Java 泛型是编译器提供的语法糖，可用于<strong>限定集合的输入类型；让编译器在源码级别上即可防止非法数据的插入</strong>，但是编译生成 class 文件后，将不再存在泛型信息，这个过程叫做<strong>擦除</strong>(在类的元数据中通过反射还可以取到泛型信息，所以我们可以通过反射来绕过泛型)　</li><li>泛型在编译阶段保证了类型安全，在后续使用中也避免了强制类型转换，但牺牲了一定的代码简洁性</li></ul><p><strong>定义泛型方法和泛型类</strong></p><p>使用场景：需要传入或返回一个<strong>暂时未知</strong>的类型，而 Java 中遵循<strong>先定义再使用</strong>，可以通过泛型来解决这个问题</p><p>使用泛型方法可以接收不同类型的参数，返回值不需要强转</p><ul><li>泛型方法</li></ul><p>Java 程序中，普通方法，构造方法和静态方法都可以使用泛型。方法使用泛型前，必须对泛型进行声明，语法为：<code>&lt;T&gt;</code>，T 可以是任意字母，但通常大写，<code>&lt;T&gt;</code> 通常需要放在方法的返回类型之前，如：<code>public &lt;T&gt; T test(T t) { return t; }</code>，这样在调用该方法时，比如 <code>test(&quot;aaa&quot;)</code>，返回值的类型就是 <code>String</code>，不需要强转</p><ul><li>泛型类</li></ul><p>如果在一个类中多次用到同一个泛型参数，就可以把该参数提取到类的定义上来，使用泛型类，比如 JDK 中的 Map 接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A map entry(key-value pair).</span></span><br><span class="line"><span class="comment">     * The Map.entrySet method returns a collection-view</span></span><br><span class="line"><span class="comment">     * of the map, whose elements are of this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举个实际使用的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"first"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"second"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// Use Integer instead of int to avoid NPE</span></span><br><span class="line">    Integer key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要引入泛型"><a href="#为什么要引入泛型" class="headerlink" title="为什么要引入泛型"></a>为什么要引入泛型</h2><p>主要有两方面原因：</p><ul><li>在编译期进行类型检查，比如 <code>ArrayList&lt;Integer&gt;</code> 只能插入 Integer 类型的数据，同时在使用时可以省去强制类型的转换的麻烦（<strong>Stronger type checks at compile time.</strong>）</li><li>更重要的是提供了对于泛型范式的支持，对于一个方法，我们可以抽象出方法的算法骨架，通过泛型的支持，使同一个算法应用到不同的数据类型，增强了方法的普适性，举个例子：</li></ul><p>reverse 数组中的元素(数组的元素可以是字符串类型，Integer 类型等，算法思路：定义首尾两个指针，然后同时移动)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个泛型方法，接收任意类型数组，并颠倒数组中的所有元素</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"arr is null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        T tmp = arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-泛型的问题"><a href="#Java-泛型的问题" class="headerlink" title="Java 泛型的问题"></a>Java 泛型的问题</h2><p>Java 泛型是在 JDK5 中新增的语言特性，为了兼容之前的类库，采用了类型擦除的实现方式(个人觉得这样实现改动最小也是很重要的一个原因，在泛型之前，通过使用共同父类 Object 来实现的容器类运行良好，采用泛型擦除只需要编译器提供自动转换和类型检查的语法糖即可，runtime 不用改动)，这也导致外界对 Java 的泛型实现一直存在批判</p><p>因为采用类型擦除的实现方式，那么一个类的类型参数 E 的实际类型在运行期是被擦除的(全部为 Object 类型，这也是为什么泛型类型参数必须是引用数据类型)，这对于Java 泛型的使用带来了一定的制约，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123;</span><br><span class="line">            <span class="comment">// Compiler error</span></span><br><span class="line">            <span class="comment">// The type used with instanceof has to be reifiable, </span></span><br><span class="line">            <span class="comment">// which means that all information about the type has to be available at runtime</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compiler error</span></span><br><span class="line">        <span class="comment">// You can't create an instance of a type parameter</span></span><br><span class="line">        E item2 = <span class="keyword">new</span> E(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类也不能继承 Throwable 类，因为 catch 语句在运行时无法确定该执行哪个，例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compiler error ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GenericException&lt;Integer&gt;();</span><br><span class="line">&#125; <span class="keyword">catch</span> (GenericException&lt;Integer&gt; e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (GenericException&lt;String&gt; e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型参数也不能用于类中的静态变量，因为泛型类的类型参数可能会对应不同的实际类型参数，而静态变量是一个类的所有实例共享的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Compiler error</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建参数化类型的数组也是非法的：<code>List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</code></p><p>类型擦除会影响方法重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// Compiler error</span></span><br><span class="line">    <span class="comment">// The overloads would all share the same classfile representation and will generate a compile-time error.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多具体内容参见 Oracle 官方文档: <a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html" target="_blank" rel="noopener">Restrictions on Generics</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;相关术语和入门使用&quot;&gt;&lt;a href=&quot;#相关术语和入门使用&quot; class=&quot;headerlink&quot; title=&quot;相关术语和入门使用&quot;&gt;&lt;/a&gt;相关术语和入门使用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关于泛型的几个术语&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList&lt;e&gt; 中的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 念作 &lt;code&gt;typeof&lt;/code&gt;，E 称为类型参数变量&lt;/e&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt; 中的 Integer 称为实际类型参数&lt;/li&gt;
&lt;li&gt;整个 &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt; 称为泛型类型；整个 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt; 称为参数化的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于泛型几个需要注意的点: (由于 Java 的泛型采用类型擦除来现实，存在相关问题，后面会继续讨论)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
