<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x08 0x17</title>
  
  <subtitle>Build something useful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ryan-hou.github.io/"/>
  <updated>2020-04-06T15:17:19.530Z</updated>
  <id>https://ryan-hou.github.io/</id>
  
  <author>
    <name>0x08 0x17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Using and avoiding null</title>
    <link href="https://ryan-hou.github.io/2018/05/31/Using-and-avoiding-null/"/>
    <id>https://ryan-hou.github.io/2018/05/31/Using-and-avoiding-null/</id>
    <published>2018-05-31T03:18:10.000Z</published>
    <updated>2020-04-06T15:17:19.530Z</updated>
    
    <content type="html"><![CDATA[<p>不合理的使用null会带来各种可能出现的bug，针对如何合理的使用 null，Google Guava 里给出了一篇很好文档和相应的工具类，这里翻译一下，原文链接：<a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Using and avoiding null</a></p><blockquote><p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p></blockquote><p>(上面给出了两个大神的言论，质疑权威虽然是理工科出身的我们的好习惯，但是很多时候，权威说的话确实值得我们思考)</p><a id="more"></a><p>随意的使用null会带来数量令人吃惊的bug。在研究了Google内部的代码后，我们发现大约在95%的情况下，collections 中不应该有任何的null值，在往collections中添加null时，提供fail fast 而不是默认接受对于开发者来说是很有帮助的</p><p>此外，null值非常有歧义性。很难从返回的null值得到具体的含义－－例如，<code>Map.get(key)</code> 返回null值，既可能是因为该key对应的value是null，也可能是因为该key不存在。Null可以表示失败，可以表示成功，可以表示几乎所有的东西。使用其他的东西而不是null来让你的代码表义清晰</p><p>上面说了，绝大部分情况下都不要随意使用null，也就是说，null在一些场景下的使用也是正确合理的。从内存和速度来说，使用null很廉价，而且在对象数组中是不可避免的。相比类库，在应用代码中，null通常会带来表义不清，从而导致困难和奇葩的bug－－比如，当 <code>Map.get</code> 返回null，它可以表示值不存在或者值存在但是为null。更重要的是，null不会给null值到底意味着什么任何提示</p><p>综上原因，只要存在 null 友好的 workaround，Guava 中的很多工具类对于null值都使用 fail fast 策略而不允许使用null。此外，Guava 提供了很多工具在你必须要使用null时，让使用null更加容易并帮助你避免使用null</p><h3 id="Specific-Cases"><a href="#Specific-Cases" class="headerlink" title="Specific Cases"></a>Specific Cases</h3><p>如果你想要在 <code>Set</code> 或者 <code>Map</code> 的key中使用<br>null，不要这么做！单独定义明确的关于null的 <strong>special-case</strong>会使得在查询操作中代码更加清晰(毫不意外)</p><p>如果你想在<code>Map</code>中使用值为null的value，那么把这个键值对单独定义出来。把<code>Set</code>中非空的key(或者为空的key)单独定义。很容易把Map中不存在某个key和Map中存在某个key，该key对应的value值为null这两种完全不同的情景搞混。把这样的key单独定义出来要好得多，同时这样会让你思考你的应用中一个key对应的value值为空，是怎样的一种场景</p><p>如果你在<code>List</code>中使用null，如果这个List是稀疏的，可能定义一个<code>Map&lt;Integer, E&gt;</code>会让代码更加高效，同时很可能更加符合你的需求</p><p>考虑一下是否存在一个“null object”可以使用，这种情况不总是存在的，但是有些场景，比如一个枚举类可以加一个常量来代表你希望null值所表示的含义。例如，在 <code>java.math.RoundingMode</code> 中有一个 <code>UNNECESSARY</code> 值来表示“do no rounding, and throw an exception if rounding would be necessary.”</p><p>如果你确实需要null值，使用 null-hostile 的集合类存在问题，那么可以使用支持null的集合类实现。比如，使用 <code>Collections.unmodifiableList(Lists.newArrayList())</code> 而不是 <code>ImmutableList</code></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>在很多场景下，我们程序员使用null是用来表示某种缺失：在某个地方可能会存在一个值，但是现在没有或者找不到。比如，<code>Map.get</code>在找不到某个key对应的value值时返回null</p><p><code>Optional&lt;T&gt;</code>是一种把可为空的引用T替换为一个不可为空的值工具类。一个 Optional 要么包含一个非空的引用T(在这种场景下我们说这个引用是<strong>present</strong>的)，要么什么也不包含（在这种场景下，我们说这个引用是<strong>absent</strong>的）。绝不存在<strong>contain null</strong>这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; possible = Optional.of(<span class="number">5</span>);</span><br><span class="line">possible.isPresent(); <span class="comment">// returns true</span></span><br><span class="line">possible.get(); <span class="comment">// returns 5</span></span><br></pre></td></tr></table></figure><p>Optional 并不是作为实现别的语言已经存在的”option”或者”maybe”语言结构而存在的，尽管存在一些相似性</p><p>在下面列一些常用的操作：</p><h4 id="Making-an-Optional"><a href="#Making-an-Optional" class="headerlink" title="Making an Optional"></a>Making an Optional</h4><p>Optional 中的静态方法。</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>Make an Optional containing the given non-null value, or fail fast on null.</td></tr><tr><td>Optional.absent()</td><td>Return an absent Optional of some type.</td></tr><tr><td>Optional.fromNullable(T)</td><td>Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.    </td></tr></tbody></table><h4 id="Query-methods"><a href="#Query-methods" class="headerlink" title="Query methods"></a>Query methods</h4><p>下面是常用的实例方法</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>boolean isPresent()</td><td>Returns true if this Optional contains a non-null instance.</td></tr><tr><td>T get()</td><td>Returns the contained T instance, which must be present; otherwise, throws an IllegalStateException.</td></tr><tr><td>T or(T)</td><td>Returns the present value in this Optional, or if there is none, returns the specified default.</td></tr><tr><td>T orNull()</td><td>Returns the present value in this Optional, or if there is none, returns null. The inverse operation of fromNullable</td></tr><tr><td>Set<t> asSet()</t></td><td>Returns an immutable singleton Set containing the instance in this Optional, if there is one, or otherwise an empty immutable set.</td></tr></tbody></table><p>Optional 还提供了其它有用的方法，具体信息可以去看 Javadoc</p><h4 id="What’s-the-point"><a href="#What’s-the-point" class="headerlink" title="What’s the point?"></a>What’s the point?</h4><p>除了通过给null一个名字来增强可读性，Optional带来的最大好处在于它是 idiot-proof-ness 的，它迫使你去思考 absent 的场景到底是怎样的，否则你的程序可能会编译不过去，因为你必须手动 unwrap the Optional 并处理 absent 的情况。直接使用 null 使这些情况很容易被忽略，尽管 FindBugs 也可以提供帮助，但是我们不认为它能像 Optional 一样解决这个问题</p><p>当返回一个可能存在或者可能不存在的值时，使用Optional 更加有用。对于 <code>other.method(a, b)</code>方法，相比我们在实现这个方法时可能会忘记判断 a 可能为 null 这种情况，我们更容易忘记这个方法可能会返回 null。而返回 Optional 则使调用者不可能忘记处理这种情况，因为他们必须unwrap这个对象来使他们的代码能编译</p><h3 id="Convenience-methods"><a href="#Convenience-methods" class="headerlink" title="Convenience methods"></a>Convenience methods</h3><p>无论何时你想使用一个默认值来代替null，可以使用 <code>MoreObjects.firstNonNull(T, T)</code>。正如该方法的名字所示，如果两个输入都是null，该方法会通过抛出NPE来实现 fail fast。如果你在使用 Optional 对象，那么 first.or(second) 是更好的替代方法</p><p>在<code>Strings</code>类中提供了几个处理可能为空的方法，而且我们专门定义了恰当的名字：</p><ul><li>emptyToNull(String)</li><li>isNullOrEmpty(String)</li><li>nullToEmpty(String)</li></ul><p>我们想强调一下，这些方法主要是用来和那些把 null 字符串和 empty 字符串等同看待的API进行交互。每次你写出把null和empty字符串混用的代码，Guava 团队的小伙伴都哭了(把 null 字符串和 empty 字符串混用通常是令人困惑的 code smell)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不合理的使用null会带来各种可能出现的bug，针对如何合理的使用 null，Google Guava 里给出了一篇很好文档和相应的工具类，这里翻译一下，原文链接：&lt;a href=&quot;https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using and avoiding null&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Null sucks.” -Doug Lea&lt;br&gt;&lt;br&gt;&lt;br&gt;“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(上面给出了两个大神的言论，质疑权威虽然是理工科出身的我们的好习惯，但是很多时候，权威说的话确实值得我们思考)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
