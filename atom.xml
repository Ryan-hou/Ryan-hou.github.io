<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x08 0x17</title>
  
  <subtitle>Build something useful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ryan-hou.github.io/"/>
  <updated>2020-04-08T07:05:56.745Z</updated>
  <id>https://ryan-hou.github.io/</id>
  
  <author>
    <name>0x08 0x17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>null awareness</title>
    <link href="https://ryan-hou.github.io/2019/04/07/null-awareness/"/>
    <id>https://ryan-hou.github.io/2019/04/07/null-awareness/</id>
    <published>2019-04-07T14:30:20.000Z</published>
    <updated>2020-04-08T07:05:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>前面翻译了一篇关于如何合理使用 null 的文章:<a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a>，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的</p><h3 id="null-是什么"><a href="#null-是什么" class="headerlink" title="null 是什么"></a>null 是什么</h3><p>null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:</p><a id="more"></a><ul><li>null 是关键字，大小写敏感</li><li>null 既不是对象也不是一种类型，它仅是一个<strong>特殊值</strong>，你可以将它赋予任何引用类型，你也可以将 null 强制转化为任何引用类型</li><li>可以使用 == 和 = 来操作 null 值，但是不能使用其他逻辑操作，在 Java 中 <code>null == null</code> 返回 true</li><li>使用作为引用类型变量默认值的 null，instanceof 操作符将会返回 false</li></ul><h3 id="null-带来的问题"><a href="#null-带来的问题" class="headerlink" title="null 带来的问题"></a>null 带来的问题</h3><p>null 本身不是一个对象，通过 null 访问对象的成员方法或者成员变量(解引用)会导致空指针异常(NPE)；由于我们很容易忽略判断一个对象是否为 null，所以想当然的进行解引用操作时会带来 NPE 问题</p><h3 id="如何规避-null-的问题"><a href="#如何规避-null-的问题" class="headerlink" title="如何规避 null 的问题"></a>如何规避 null 的问题</h3><p><strong>意识非常重要，意识非常重要，意识非常重要</strong>，重要的事情说三遍！当我们拿到一个引用类型的变量时，条件反射的就要考虑这个变量是不是 null，如果是 null 该怎么处理？我自己写的代码导致了 NPE 时，我总会反思自己: 代码里的 NPE 都解决不了，难怪现实中也没对象……</p><p>有了上面的意识，下面再介绍一些实用的方法来规避 NPE。部分内容在 <a href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/">Using and avoiding null</a> 也有提到，可以互为参考。</p><p>既然 NPE 的源头在于 null，那么避免使用 null 就可以从源头上解决这个问题。比如可以使用 Guava 提供的 <code>ImmutableMap, ImmutableList</code> 等不允许元素为 null 的集合类。尽量不要用 null 来初始化变量，函数尽量不要返回 null。对于必须要用 null 的场景考虑单独定义相应的 null object</p><p>采用防御性编程。作为函数作者，我们要对入参进行必要的校验，不允许参数为空时直接抛出异常而不是继续执行。由函数的调用者对程序异常负责；尽量不返回 null，比如可以返回 Optional 对象，或者 null object</p><p>作为函数调用者，要对返回值是否为 null 保持敏感。明确返回的 null 值含义，进行相应的检查和处理。比如远程调用时，对于返回值通常要进行判空处理</p><p>使用 @NotNull 和 @Nullable 注解配合 IntelliJ 尽量在早期发现和预防 NPE</p><p>对于链式调用要格外注意，很容易在某个调用过程发生 NPE。比如 <code>obj.methodA().methodB().methodC()</code></p><p>警惕包装类型的自动装箱和拆箱。相比基本数据类型，包装类型存在 null 这个默认值，在自动拆箱时很容易 NPE。而且正是由于这个语法糖，我们会下意识的把包装类和基本类型等同，实际上两者是很不一样的。所以对于这个语法糖我个人持弊大于利的观点。总之，在使用包装类型时，要格外留心，他们是包装类型而不是基本类型，不能闭着眼睛混用！</p><p>以上是对于 null 的总结，概括来说，就是<strong>要时刻对于 null 这个 corner case 保持警惕，然后采取合理的处理方式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面翻译了一篇关于如何合理使用 null 的文章:&lt;a href=&quot;https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/&quot;&gt;Using and avoiding null&lt;/a&gt;，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的&lt;/p&gt;
&lt;h3 id=&quot;null-是什么&quot;&gt;&lt;a href=&quot;#null-是什么&quot; class=&quot;headerlink&quot; title=&quot;null 是什么&quot;&gt;&lt;/a&gt;null 是什么&lt;/h3&gt;&lt;p&gt;null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="经验" scheme="https://ryan-hou.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Using and avoiding null</title>
    <link href="https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/"/>
    <id>https://ryan-hou.github.io/2019/04/06/Using-and-avoiding-null/</id>
    <published>2019-04-06T15:50:20.000Z</published>
    <updated>2020-04-08T02:58:57.690Z</updated>
    
    <content type="html"><![CDATA[<p>文章翻译自 Google Guava 文档，原文链接: <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">Using and avoiding null</a></p><h3 id="Why-avoid-null？"><a href="#Why-avoid-null？" class="headerlink" title="Why avoid null？"></a>Why avoid null？</h3><blockquote><p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p></blockquote><p>随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的</p><a id="more"></a><p>此外，null 非常有歧义性。很难从返回的 null 得到具体的含义－－例如，<code>Map.get(key)</code> 返回 null，既可能是因为该 key 对应的 value 是 null，也可能是因为该 key 不存在。null 可以表示失败，也可以表示成功，可以表示几乎所有东西。使用其他表意更清晰的东西而不是 null 可以增强代码可读性</p><p>上面说了，绝大部分情况下都不要随意使用 null，同时这也说明了 null 在一些场景下的使用是合理的。从内存和速度的角度来看，使用 null 很”廉价”，而且在对象数组中也不可避免。不同于类库，在应用代码中，null 通常会因表义不清，进而带来歧义和奇葩的 bug－－比如，当 <code>Map.get</code> 返回 null，它可以表示值不存在或者值存在但是为 null。更要命的是，null 不会给 null 值本身到底意味着什么提供任何提示</p><p>综上原因，只要存在可以方便使用 null 的 workaround，Guava 中相应的很多工具类都采用 fail fast 策略拒绝 null 值。此外，Guava 提供了很多工具避免你使用 null，或者在你必须要使用 null 时用起来更简单</p><h3 id="Specific-Cases"><a href="#Specific-Cases" class="headerlink" title="Specific Cases"></a>Specific Cases</h3><p>如果你想要在 <code>Set</code> 或者 <code>Map</code> 的 key 中使用 null，不要这么做！在查询操作中单独定义关于 null 值的 <strong>special-case</strong> 会使代码更加清晰</p><p>如果你想在 <code>Map</code> 中使用值为 null 的 value，那么把这个键值对单独定义出来。把 <code>Set</code> 中非空的 key (或者为空的 key)单独定义。因为我们很容易把 Map 中不存在某个 key 和 Map 中存在某个 key，该 key 对应的 value 值为 null 这两种完全不同的情景搞混。把这样的 key 单独定义出来要好得多，同时这样会<strong>强迫你去思考</strong>你的应用中一个 key 对应的 value 值为空，是怎样的一种场景</p><p>如果你在 <code>List</code> 中使用 null，而这个 List 是稀疏的，可能定义一个 <code>Map&lt;Integer, E&gt;</code> (key 为 List 元素的下标值，value 为对应的 List 元素)会让代码更加高效，同时也可能更符合你的需求</p><p>考虑一下是否存在一个 “null object” 可以使用，这种情况不总是存在，但是有些场景，比如一个枚举类可以加一个常量来代表你希望 null 值所表示的含义。例如，在 <code>java.math.RoundingMode</code> 中有一个 <code>UNNECESSARY</code> 值来表示 “do no rounding, and throw an exception if rounding would be necessary.”</p><p>如果你确实需要 null 值，那就不要使用 null-hostile 的集合类（比如 <code>ImmutableList, ImmutableMap</code>），可以使用支持 null 的集合类实现。比如，使用 <code>Collections.unmodifiableList(Collection&lt;? extends T&gt; c)</code> 而不是 <code>ImmutableList</code></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>注: JDK 1.8 中已经引入了类似的 Optional 工具类，基本思想是一致的: null 指针之所以存在问题，是因为你可以在不检查 null 的情况下访问对象的成员方法和成员变量(null 解引用导致 NPE)。使用 Optional 可以强迫你去思考 null 这种情况或者通过类似 <code>ifPresent(Consumer&lt;? super T&gt; consumer)</code> 这样的方法把判断是否为 null 和访问操作合二为一，只有不为 null 时才能进行相应操作</p><p>在很多场景下，我们程序员使用 null 是用来<strong>表示某种缺失</strong>：在某个地方可能会存在一个值，但是现在没有或者找不到。<code>Optional&lt;T&gt;</code> 把可为空的引用T替换为一个非空的 Optional 值。一个 Optional 要么包含一个非空的引用T(在这种场景下我们说这个引用是 <strong>present</strong> 的)，要么什么也不包含（在这种场景下，我们说这个引用是 <strong>absent</strong> 的）。即引用要么 present 要么 absent，不存在 <strong>contain null</strong>，避免产生歧义</p><p>下面列一些常用的操作：（注: 下述方法均为 JDK 中 <code>Optional&lt;T&gt;</code> 类的方法，使用方式和 Guava 基本一致 ）</p><h4 id="Making-an-Optional"><a href="#Making-an-Optional" class="headerlink" title="Making an Optional"></a>Making an Optional</h4><p>Optional 中的静态方法:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>Make an Optional containing the given non-null value, or fail fast on null.</td></tr><tr><td>Optional.ofNullable(T)</td><td>Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.</td></tr></tbody></table><h4 id="Query-methods"><a href="#Query-methods" class="headerlink" title="Query methods"></a>Query methods</h4><p>下面是常用的实例方法</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>boolean isPresent()</td><td>Returns true if this Optional contains a non-null instance.</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</td></tr><tr><td>T get()</td><td>Returns the contained T instance, which must be present; otherwise, throws an NoSuchElementException</td></tr><tr><td>T orElse(T other)</td><td>Return the value if present, otherwise return other.</td></tr><tr><td>Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></td><td>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an Optional describing the result.  Otherwise return an empty Optional.</td></tr></tbody></table><p>Optional 还提供了其它有用的方法，具体信息可以去看 Javadoc</p><h4 id="What’s-the-point"><a href="#What’s-the-point" class="headerlink" title="What’s the point?"></a>What’s the point?</h4><p>除了通过给 null 一个名字(缺失与否)来增强可读性，Optional 带来的最大好处在于它是 idiot-proof-ness 的，它迫使你去思考 absent 的场景到底是怎样的，否则你的程序可能会编译不过去，因为你必须手动 unwrap the Optional 并处理 absent 的情况。直接使用 null 使这些情况很容易被忽略，尽管 FindBugs 也可以提供帮助，但是我们不认为它能像 Optional 一样解决这个问题</p><p><strong>当返回一个可能存在或者可能不存在的值时，使用Optional 更加有用。</strong>对于 <code>other.method(a, b)</code>方法，相比我们在实现这个方法时忘记判断 a,b 可能为 null 这种情况，我们更容易忘记这个方法可能会返回 null。而返回 Optional 则使调用者不可能忘记处理这种情况，因为他们必须 unwrap 这个对象来使他们的代码能编译</p><h3 id="Convenience-methods"><a href="#Convenience-methods" class="headerlink" title="Convenience methods"></a>Convenience methods</h3><p>无论何时你想使用一个默认值来代替 null，可以使用 <code>MoreObjects.firstNonNull(T, T)</code>，正如该方法的名字所示，如果两个输入都是 null，该方法会通过抛出NPE来实现 fail fast。如果你在使用 Optional 对象，那么 <code>first.orElse(second)</code> 是更好的替代方法</p><p>在<code>Strings</code>类中提供了几个处理可能为空的方法，而且我们专门定义了恰当的名字：</p><ul><li>emptyToNull(String)</li><li>isNullOrEmpty(String)</li><li>nullToEmpty(String)</li></ul><p>我们想强调一下，这些方法主要是用来处理那些把 null 字符串和 empty 字符串等同看待的API。每当你写出把 null 和 empty 字符串混用的代码，Guava 团队的小伙伴都”哭了”(null 字符串和 empty 字符串混用通常是令人不安的 code smell)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章翻译自 Google Guava 文档，原文链接: &lt;a href=&quot;https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using and avoiding null&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Why-avoid-null？&quot;&gt;&lt;a href=&quot;#Why-avoid-null？&quot; class=&quot;headerlink&quot; title=&quot;Why avoid null？&quot;&gt;&lt;/a&gt;Why avoid null？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“Null sucks.” -Doug Lea&lt;br&gt;&lt;br&gt;&lt;br&gt;“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="翻译" scheme="https://ryan-hou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>重新认识信息隐藏</title>
    <link href="https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    <id>https://ryan-hou.github.io/2019/02/22/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/</id>
    <published>2019-02-22T12:25:51.000Z</published>
    <updated>2020-04-10T06:55:48.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个重要却容易忽略的问题"><a href="#一个重要却容易忽略的问题" class="headerlink" title="一个重要却容易忽略的问题"></a>一个重要却容易忽略的问题</h2><p>在谈到 OOP 时，大家一般会想到<strong>封装，继承和多态</strong>，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，<strong>信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。</strong>那信息隐藏为什么如此重要？</p><p>引用一段<code>Effective Java</code>中的话：</p><blockquote><p>要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信</p></blockquote><a id="more"></a><p>除了设计好的需要对外公开的 API 外，其他的成员原则上都要隐藏，如果不能很好的实现信息隐藏，意外暴露的成员被客户端操作会导致对象状态的不可控，<strong>这也要求我们在写代码时要保持有意识的状态，每一行代码都是一种“承诺”</strong></p><h2 id="封装与访问控制"><a href="#封装与访问控制" class="headerlink" title="封装与访问控制"></a>封装与访问控制</h2><p>谈信息隐藏，自然避不开封装。广义上的封装仅仅只是打包，把一些数据和行为封闭到一个盒子，这个盒子可能是黑盒子也可能是白盒子。相比 C 语言，Java 的封装引入了一种<strong>新的模块机制: 把相关的数据和作用在其上的运算打包为称为类的模块，从而为域和函数(准确的说应该是成员方法)提供了一个上下文。</strong></p><p>我们通常所说的狭义的封装是指<strong>在打包的基础上加上访问控制，以实现信息隐藏；访问控制不仅仅是语法上的限制，也是语义上的规范</strong>，标有 public 的是接口，标有 private 的是实现；这种语义显然比文档注释更加直观。</p><p>访问控制是对静态代码的控制，并非牢不可破，通过反射机制一样可以访问到 private 成员，这里也引出一个常见的误区，认为信息隐藏是为了安全性，不能说错，但信息隐藏的本意并不在此，<strong>信息隐藏通过屏蔽一个模块中非本质，容易变化的部分，从而保证了内部的修改不会波及客户，它的目的是为了提高稳定性和灵活性</strong>，通过信息隐藏，一个类相当于被划分为阴阳两面，阴面的实现对于客户是透明的</p><h2 id="如何更好的隐藏信息"><a href="#如何更好的隐藏信息" class="headerlink" title="如何更好的隐藏信息"></a>如何更好的隐藏信息</h2><h3 id="使类和成员的可访问性最小化-这个很好理解，举个简单例子，把一个类的-private-成员改为-public-不会产生问题，反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广，具体可以采用如下操作"><a href="#使类和成员的可访问性最小化-这个很好理解，举个简单例子，把一个类的-private-成员改为-public-不会产生问题，反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广，具体可以采用如下操作" class="headerlink" title="使类和成员的可访问性最小化: 这个很好理解，举个简单例子，把一个类的 private 成员改为 public 不会产生问题，反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广，具体可以采用如下操作"></a>使类和成员的可访问性最小化: 这个很好理解，举个简单例子，把一个类的 <code>private</code> 成员改为 <code>public</code> 不会产生问题，反过来那就不一定了。访问范围越大，越不容易控制，一旦变动影响的面也会更广，具体可以采用如下操作</h3><h4 id="顶层类如果可以包级私有，那就包级私有"><a href="#顶层类如果可以包级私有，那就包级私有" class="headerlink" title="顶层类如果可以包级私有，那就包级私有"></a>顶层类如果可以包级私有，那就包级私有</h4><p>我们通过 IDE 生成类时，一般会默认用 public 修饰类，这里值得商榷，一个包中的类大部分都是为本包提供服务的，没有必要作为包的 API 导出，因为一旦导出，你就要负责一直维护他</p><h4 id="在公有类中使用访问方法而非公有域"><a href="#在公有类中使用访问方法而非公有域" class="headerlink" title="在公有类中使用访问方法而非公有域"></a>在公有类中使用访问方法而非公有域</h4><p><strong>公有类永远都不应该暴露可变的域。在特殊情况下，暴露公有的静态的 final域是可以接受的，但是这里的域要么是基本类型，要么是不可变的。</strong>比如一个很常见的错误就是：<code>public Date getBirthday() { return birthday }</code> 这里即使 birthday 使用了 <code>private</code> 的访问修饰符，但仍然没用，因为 Date 类不是不可变的（当然了 Date 类是可变的属于类库设计的缺陷），这里应该提供防御性复制</p><h4 id="使用-private-不需要理由，不使用才需要理由，这也是为什么如-C-之类的语言默认的访问修饰符是-private（Java默认是包级私有）"><a href="#使用-private-不需要理由，不使用才需要理由，这也是为什么如-C-之类的语言默认的访问修饰符是-private（Java默认是包级私有）" class="headerlink" title="使用 private 不需要理由，不使用才需要理由，这也是为什么如 C# 之类的语言默认的访问修饰符是 private（Java默认是包级私有）"></a>使用 private 不需要理由，不使用才需要理由，这也是为什么如 C# 之类的语言默认的访问修饰符是 private（Java默认是包级私有）</h4><h4 id="警惕长度不为0的数组"><a href="#警惕长度不为0的数组" class="headerlink" title="警惕长度不为0的数组"></a>警惕长度不为0的数组</h4><p><strong>长度不为0的数组总是可变的，类具有公有的静态的 final 数组域或者返回这种域的访问方法，几乎总是错误的。</strong>可以通过把数组域私有，并添加一个公有方法，返回私有数组域的一个备份:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="comment">// shallow copy, Thing need to be Immutable</span></span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者很多时候，并不需要一次性返回一整个数组，而是返回数组中的某一个元素，提供这样细粒度的 API 可能会更方便，而且效率更好更安全</p><h4 id="信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如public-int-computeAge-这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏"><a href="#信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如public-int-computeAge-这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏" class="headerlink" title="信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如public int computeAge() 这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏"></a>信息隐藏不仅要隐藏数据结构，还包括实现方式和策略，如<code>public int computeAge()</code> 这样的API实际上暴露了实现方式即年龄是计算出来的，不符合信息隐藏</h4><h3 id="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"><a href="#如果内部数据必须要暴露出来，那么要尽量使可变性最小化" class="headerlink" title="如果内部数据必须要暴露出来，那么要尽量使可变性最小化"></a>如果内部数据必须要暴露出来，那么要尽量使可变性最小化</h3><h4 id="不要追求-get-set-方法对称的教条，set-方法能不提供就不提供"><a href="#不要追求-get-set-方法对称的教条，set-方法能不提供就不提供" class="headerlink" title="不要追求 get/set 方法对称的教条，set 方法能不提供就不提供"></a>不要追求 get/set 方法对称的教条，set 方法能不提供就不提供</h4><h4 id="能设计为不可变类就不要设计为可变类"><a href="#能设计为不可变类就不要设计为可变类" class="headerlink" title="能设计为不可变类就不要设计为可变类"></a>能设计为不可变类就不要设计为可变类</h4><p>除非有很好的理由使类成为可变的，不然就应该是不可变的类。构造一个不可变的类遵循相应的规则即可(参考<code>Effective Java</code>)。不可变的类只有一种状态，那就是被创建时的状态；而且不可变的类本质上是线程安全的，不需要同步，可以被自由的共享而不用进行保护性拷贝。对于频繁用到的值，可以使用公有静态 final 常量，或者使用静态工厂替换构造器提供缓存功能。但是不可变类也有缺点，那就是每一个值都是一个对象，有时为了性能和内存考量需要提供可变的配套类，如<code>StringBuilder</code></p><h4 id="能用-final-域就不要不用"><a href="#能用-final-域就不要不用" class="headerlink" title="能用 final 域就不要不用"></a>能用 final 域就不要不用</h4><p>如果类不能做成不可变的，那也要尽可能的降低它的可变性，减少对象可存在的状态，可以更容易的分析它的行为，减少出错的几率。<strong>除非有令人信服的理由，不然所有的域都应该是  final的</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于信息隐藏的一些重要知识，很基础但也很重要，通过合理的信息隐藏，我们才能构建出稳健的类和包，<strong>使他们提供尽可能少的开口，以更好的面对变化，不至于失控</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;a href=&quot;#一个重要却容易忽略的问题&quot; class=&quot;headerlink&quot; title=&quot;一个重要却容易忽略的问题&quot;&gt;&lt;/a&gt;一个重要却容易忽略的问题&lt;/h2&gt;&lt;p&gt;在谈到 OOP 时，大家一般会想到&lt;strong&gt;封装，继承和多态&lt;/strong&gt;，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，&lt;strong&gt;信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。&lt;/strong&gt;那信息隐藏为什么如此重要？&lt;/p&gt;
&lt;p&gt;引用一段&lt;code&gt;Effective Java&lt;/code&gt;中的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>创建一个对象的思考</title>
    <link href="https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://ryan-hou.github.io/2019/01/01/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2019-01-01T05:59:25.000Z</published>
    <updated>2020-04-09T09:01:03.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事情可能没有看起来那么简单"><a href="#事情可能没有看起来那么简单" class="headerlink" title="事情可能没有看起来那么简单"></a>事情可能没有看起来那么简单</h2><p>Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？</p><ul><li>创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？</li><li>数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？</li><li>时间: 是立即构建，还是延迟构建呢？</li><li>形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？</li></ul><a id="more"></a><p>以上这些，在不同的场景下，我们需要做不同的考量，本文仅从构造器的弊端来谈一下静态工厂方法，工厂方法模式，抽象工厂模式和 Builder 模式</p><h2 id="构造器有什么问题"><a href="#构造器有什么问题" class="headerlink" title="构造器有什么问题"></a>构造器有什么问题</h2><p>用构造器来创建对象，是很自然也很简单的，大部分场景下直接通过构造器构建对象就足够了。但构造器也存在一些问题，下面具体谈一下</p><h3 id="构造器缺乏表现力"><a href="#构造器缺乏表现力" class="headerlink" title="构造器缺乏表现力"></a>构造器缺乏表现力</h3><p><strong>构造器的名字必须和类名保持一致，缺乏表现力。</strong>而且在构造器参数除了名字不同外(参数类型，个数和顺序完全相同)，会导致构造器的方法签名重复，比如很经典的一个例子就是用 Point 类代表平面坐标系的点，通过构造器提供直角坐标和极坐标的创建方式，代码会出现：<code>Point(double x, double y) 和 Point(double r, double theta)</code> 不仅表现力不足，而且方法签名冲突，我们可以使用<strong>静态工厂方法</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">cartesian</span><span class="params">(<span class="keyword">double</span> x, doubly y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">polar</span><span class="params">(doule r, <span class="keyword">double</span> theta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(r * Math.cos(theta), r * Math.sin(theta));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码可读性要好很多，而且不存在方法签名冲突的问题</p><h3 id="构造器的每次调用都会创建新对象"><a href="#构造器的每次调用都会创建新对象" class="headerlink" title="构造器的每次调用都会创建新对象"></a>构造器的每次调用都会创建新对象</h3><p>通常情况下每次调用构造器都会创建对象（构造器方法里做了自定义的特殊处理不考虑在内），而这并非总是合适的。不公开构造器而是借助静态方法创建对象，可以控制对象的个数。不管是出于管理的原因，如单例模式，还是出于性能的考虑，如对象池技术，这些都是单纯使用构造器做不到的。</p><p>典型的代表就是 JDK 中 Boolean 类提供的 <code>static valueOf(boolean b)</code> 方法，但是该方法提出的比较晚，Boolean 类还是可以用构造器创建多余的对象，因此 <code>valueOf</code> 方法的文档中说明了在大部分场景下应该用该方法替代构造器（除非就是需要创建一个全新的 Boolean 对象）</p><h3 id="构造器无法被继承，也就无法提供多态"><a href="#构造器无法被继承，也就无法提供多态" class="headerlink" title="构造器无法被继承，也就无法提供多态"></a>构造器无法被继承，也就无法提供多态</h3><p><strong>要使用构造器，就要知道具体的类型，这违背了针对接口编程的原则，同时也违背了依赖倒置原则(依赖尽量通过抽象来完成)，当然了这里不能一概而论，如果是依赖像 String 这样稳定的类，也是无可厚非的，但是在实际编程中，考虑减少对具体类的依赖是好的习惯</strong>，这里就可以引出工厂方法模式了</p><p>我们把创建对象的过程封装到工厂中，这实际上就是<strong>保变原则</strong>的使用，提供了一个<strong>中间层</strong>，我们的客户端代码不需要知道对象如何创建，只需要知道我去工厂里拿就可以了，这样将来创建对象的代码发生变化也不会波及客户端代码。同时<strong>工厂方法一般是一个抽象的方法，由工厂的实现类来决定要实例化的具体类是哪个，而且经常结合模版方法模式一起使用</strong>，下面是一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里经常结合模版方法模式提供一个骨架，把可扩展的部分也就是创建对象的代码交由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        pizza  = createPizza(type);</span><br><span class="line">        </span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法,由子类来具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式-抽象工厂模式与-Builder-模式"><a href="#工厂方法模式-抽象工厂模式与-Builder-模式" class="headerlink" title="工厂方法模式/抽象工厂模式与 Builder 模式"></a>工厂方法模式/抽象工厂模式与 Builder 模式</h2><p>有时候我们要创建的对象需要各种组件来构成，这些组件构成一个系列，这里我们可以使用抽象工厂模式来定义一套接口（工厂方法模式只能生产一种产品，抽象工厂模式可以生产一系列产品）。<strong>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族,而不需要明确指定具体类</strong></p><p>与工厂方法模式相比，两种模式都能将对象的创建封装起来，使应用程序解耦，并降低其对特定实现的依赖；但是，<strong>工厂方法使用继承</strong>: 把对象的创建委托给子类，子类实现工厂方法来创建对象；<strong>抽象工厂使用对象组合</strong>: 对象的创建被实现在工厂接口所暴露出的方法中；抽象工厂提供创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法，要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中，部分示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    Veggies[] createVeggies();</span><br><span class="line">    <span class="function">Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体对象的创建通过组合方式传入的具体工厂类来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory pizzaIngredientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = pizzaIngredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原料工厂生产pizza原料,代码中使用抽象类型的接口,把客户从使用的实际具体产品中解耦</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Preparing "</span> + name);</span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式是把一个对象的创建分成不同的组件，而 Builder 模式则是把创建对象分为一系列步骤，两者经常结合使用；Builder 模式不关心中间的过程，只关心最后得到的对象，符合<strong>最少知识原则</strong>，而且可以结合链式调用构造复杂的对象，Builder 模式的基本思路如下：</p><p>定义一个静态内部类，并且静态内部类的内部属性就是我们要赋值的属性。通过各个方法把我们要赋的值封装到静态内部类对象中，返回 <strong>this</strong>，目的是要使用链式的结构；定义一个方法，创建目标对象，并且传入已经封装了各个参数的静态内部类对象。目标类定义一个参数为静态内部类的构造函数；完成创建目标对象，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexObj</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String s1;</span><br><span class="line">    <span class="keyword">private</span> String s2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="comment">// getter methods and other methods...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComplexObj</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s1 = builder.s1;</span><br><span class="line">        <span class="keyword">this</span>.s2 = builder.s2;</span><br><span class="line">        <span class="keyword">this</span>.n1 = builder.n1;</span><br><span class="line">        <span class="keyword">this</span>.n2 = builder.n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String s1;</span><br><span class="line">        <span class="keyword">private</span> String s2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s1</span><span class="params">(String s1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s1 = s1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">s2</span><span class="params">(String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.s2 = s2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n1</span><span class="params">(<span class="keyword">int</span> n1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n1 = n1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">n2</span><span class="params">(<span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n2 = n2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComplexObj <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComplexObj(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of class Builder</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实际调用时就可以通过链式调用，使代码更清晰</span></span><br><span class="line">ComplexObj test = <span class="keyword">new</span> ComplexObj.Builder()</span><br><span class="line">                    .s1(<span class="string">"test"</span>).s2(<span class="string">"ff"</span>).n2(<span class="number">2</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于使用构造器创建对象可能需要思考的各种问题，以及引出的几种设计模式，这里只是做一个介绍，并不是教条；面对不同的使用场景，需要有不同的考量，要做不同的取舍，程序设计也是设计，<strong>做设计就要懂得取舍</strong>，这需要经验，思考和功夫，共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;a href=&quot;#事情可能没有看起来那么简单&quot; class=&quot;headerlink&quot; title=&quot;事情可能没有看起来那么简单&quot;&gt;&lt;/a&gt;事情可能没有看起来那么简单&lt;/h2&gt;&lt;p&gt;Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？&lt;/li&gt;
&lt;li&gt;数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？&lt;/li&gt;
&lt;li&gt;时间: 是立即构建，还是延迟构建呢？&lt;/li&gt;
&lt;li&gt;形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>模版方法模式VS策略模式</title>
    <link href="https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ryan-hou.github.io/2018/12/22/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-12-22T14:58:32.000Z</published>
    <updated>2020-04-09T03:25:54.808Z</updated>
    
    <content type="html"><![CDATA[<p>模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述</p><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote><p>在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤</p></blockquote><a id="more"></a><p>模版方法模式符合<strong>好莱坞原则(Don’t call us, we’ll call u.)</strong>，好莱坞原则给我们提供了一种防止”依赖腐败”的方法(代码中的依赖关系尽量要保持单向且不循环)，在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件。换句话说，<strong>高层组件对待低层组件的方式是”别调用我们,我们会调用你”</strong></p><p>模版方法模式也符合<strong>开闭原则(OCP)</strong>，算法骨架保持稳定，对修改封闭；通过子类对扩展保持开放</p><p>下面是<code>Head First 设计模式</code>中的一段代码，代码中有关于如何在抽象基类中定义算法骨架并定义子类扩展点的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverageWithHook</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模版方法,定义算法骨架和子类扩展点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 提供钩子方法,控制部分算法的执行,由子类决定是否覆盖该钩子方法</span></span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 交由不同子类具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Boiling water"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pouring into cup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个钩子方法,通常是空的缺省实现,由子类决定是否覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版方法模式在实际使用中是很广泛的，比如 Spring 框架中 <code>BeanFactory</code> 就使用了该模式，并把 getBean() 方法交给不同的子类具体实现；JDK 中 <code>ThreadPoolExecutor</code> 类的 runWorker() 方法就定义了 <code>beforeExecute</code> 和 <code>afterExecute</code> 钩子方法。在实际工作中，我个人也比较喜欢用这个模式，当存在两个行为类似但又不完全相同的类时，可以考虑提取公共流程和可复用的代码到父类，保留不同的地方作为 abstract 方法，交由不同的子类去实现</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</p></blockquote><p>策略模式重在定义不同的算法(行为)接口，然后为每个接口提供不同的实现类，在客户端代码中，通过组合的方式使用抽象的接口，甚至可以提供动态改变算法策略的 API，利用多态和依赖注射的方式灵活的组合和替换具体的算法</p><h3 id="涉及到的设计原则"><a href="#涉及到的设计原则" class="headerlink" title="涉及到的设计原则"></a>涉及到的设计原则</h3><p><strong>封装变化</strong>: 找出应用中可能会变化的部分，把它们抽象出来，这样系统中该部分改变不会影响其他部分</p><p><strong>针对接口编程而不是针对实现编程</strong>: 这里针对接口编程的真正意思是<strong>针对超类型(supertype)编程。</strong>针对接口编程的精髓在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上（为程序提供了动态性）</p><p><strong>多用组合，少用继承(实现继承)</strong>: “有一个”可能比”是一个”更好。当将两个类组合起来使用时,就是组合(composition)，使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以在”运行时动态的改变行为”</p><p>具体的示例代码建议去看<code>Head First 设计模式</code>一书，清晰易懂</p><p>策略模式在实际应用中也比较广泛，比如在 Netty 中，<code>EventExecutorChooser</code> 作为事件执行器选择策略接口，存在<code>PowerOfTwoEventExecutorChooser</code> 和 <code>GenericEventExecutorChooser</code> 两个具体实现类，<code>DefaultEventExecutorChooserFactory</code> 的 newChooser 方法作为策略选择者，会根据执行器数量是否能被2整数选择具体的策略实现。我自己在实际工作中也用过多次，比如在重构系统中一个关于车辆出库的方法时，该方法会判断不同的出库类型，根据类型不同，执行不同的出库逻辑，整个代码通过 if-else 组合，足足有近千行，而且不同的出库逻辑会根据需求存在变动，每次变动都要修改这里的 if-else 逻辑，维护和测试很不方便。通过抽象出一个出库策略接口，然后为不同的出库方式提供不同的实现，并提供一个根据出库方式选择具体策略实现类的策略者，该方法被简化为只有几十行代码，当出库需求变动时，只需要修改需求变动的出库方式对应的出库策略实现类即可，其他的代码均保持不变，符合开闭原则</p><h2 id="比较两种模式"><a href="#比较两种模式" class="headerlink" title="比较两种模式"></a>比较两种模式</h2><ul><li>策略模式侧重于定义一个<strong>算法家族</strong>，并且让算法可以互换，强调灵活性</li><li>而模版方法模式侧重于定义出<strong>算法骨架</strong>，子类可以通过钩子方法指定部分行为。方便代码复用和框架定义，强调的是算法骨架的稳定性</li><li>策略模式采用组合的方式实现，更加有弹性; 模版方法模式采用继承的方式实现</li></ul><p>最后再举个例子，在 <code>Head Fist 设计模式</code> 中提到，Java <code>Arrays</code>类的排序方法也提供了一种模版方法模式的变式: 在 <code>mergeSort</code> 模版方法中, 依赖于 <code>comparable</code> 接口的 <code>compareTo</code> 方法来完成算法；我认为这里理解为策略模式也是合理的，<code>comparable</code> 可以理解为一个算法家族的接口，可以有不同的实现方法，当 <code>mergeSort</code> 方法接收到此类型的具体参数，实质上就是采用了某个具体的策略。从不同的角度来看，我认为这两种观点都有道理，所以说这两种模式确实存在相似性。还是一贯的观点，编程是一门实践性很强的学科，很多时候死抠概念是没意思的，况且有的概念本身就没有定论，而有自己的思考和想法非常重要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述&lt;/p&gt;
&lt;h2 id=&quot;模版方法模式&quot;&gt;&lt;a href=&quot;#模版方法模式&quot; class=&quot;headerlink&quot; title=&quot;模版方法模式&quot;&gt;&lt;/a&gt;模版方法模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的各种姿势</title>
    <link href="https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>https://ryan-hou.github.io/2018/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/</id>
    <published>2018-12-01T02:58:05.000Z</published>
    <updated>2020-04-08T12:49:13.491Z</updated>
    
    <content type="html"><![CDATA[<p>在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other operatons...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 防止通过反射创建多个实例</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"instance already existed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他初始化操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>优点：实现简单，线程安全(依赖 JVM 在加载这个类时创建唯一的实例)</li><li>缺点：不能延迟初始化(类加载时即创建实例对象，至于类加载时机，虚拟机规范并没有强制约束)，如果该类实例化需要的资源很多，会影响内存和性能</li></ul><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>在 jdk5 之后，通过单元素的枚举可以实现单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 其他实例方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举构造单例，写法简单，线程安全，可以防御反射攻击，并且是序列化/反序列化安全的；但是不能延迟初始化</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span> ? <span class="keyword">new</span> Singleton() : instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持延迟初始化，在使用时才去创建单例实例。但是不能保证线程安全，当有多个线程同时执行 <code>instance == null</code> 时，可能会创建多个实例</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>使用同步方法</li></ul><p>在上面代码的基础上，把 <code>getInstance()</code> 方法加上 synchronized 关键字，变为同步方法，保证了不会同时有多个线程进入这个方法</p><p>优点：简单且有效，而且 JVM 会不断优化 synchronized 关键字的实现方式，如果应用程序可以接受同步的开销，推荐使用</p><p>缺点当然是同步方法带来的开销问题，而且在这里实际上只有第一次执行时才真正需要同步，一旦设置好 instance 变量后，就不再需要同步这个方法了，所以我们有必要寻找更优的线程安全实现</p><ul><li>double-checked locking</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查实例，如果不存在才进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//  再次检查是否存在实例，不存在时才创建实例，避免创建多个实例</span></span><br><span class="line">                    <span class="comment">// volatile 关键字保证了实例化对象的指令不被重排序，避免返回未正确初始化的对象实例</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uniqueInstace;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：通过同步代码块，缩小了同步范围（实例一旦创建便不再需要同步），通过 double-checked 避免了多线程创建多个实例</p><p>缺点：在 jdk5 之前，这种实现方式是错误的，当时的 JVM 对于 volatile 的实现不能保证返回的是正确初始化的对象(jdk5 及之后的版本，volatile 增强了语义，避免了指令重排带来的问题)</p><ul><li>On demand holder idiom</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This code is guaranteed to be correct because of the initialization guarantees</span></span><br><span class="line"><span class="comment">     * for static fields; if a field is set in a static initializer, it it guaranteed</span></span><br><span class="line"><span class="comment">     * to be made visible, correctly, to any thread that accesses that class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过静态字段实例化保证了在实例变量被任何线程访问时返回正确初始化的变量，且静态字段只被初始化一次，满足了线程安全和实例唯一性；又因为静态内部类的加载不需要依附外部类，在使用时才加载，满足了延迟初始化</p><p>总结一下，上述各种单例模式的实现方式说明了<strong>在不同场景和需求下会有不同的设计方案，即使是相同场景下也可能会有不同的设计，而每种设计也存在不同的侧重和取舍</strong>。如果延迟初始化不是我们要考量的问题，推荐使用枚举方式实现单例，否则推荐最后一种实现方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下&lt;/p&gt;
&lt;h2 id=&quot;懒汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式&quot;&gt;&lt;/a&gt;懒汉模式&lt;/h2&gt;&lt;p&gt;因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Other operatons...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 防止通过反射创建多个实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;instance already existed!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://ryan-hou.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://ryan-hou.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
